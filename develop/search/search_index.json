{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#network-scenario-generator-genet","title":"Network Scenario Generator (GeNet)","text":"<p>GeNet provides tools to represent and work with a multi-modal transport network with public transport (PT) services. It is based on MATSim's representation of such networks.</p> <p>The goal of GeNet is to:</p> <ul> <li>Provide a formalised in-memory data structure for representing a multi-modal network with a PT service</li> <li>Enable using the data structure for tasks such as generating auxiliary MATSim files e.g. Road Pricing</li> <li>Simplify the process of modifying a network and provide a simple change log to track the differences between the input and output networks.</li> <li>Provide validation methods to check for simple errors such as: whether a <code>Route</code> has more than one <code>Stop</code> or that the underlying graph doesn't have any dead-ends or sources (a place which you can leave but cannot get back to).</li> </ul> <p>The underlying network available to PT services (roads, railways, but also ferry/flight connections) uses a <code>networkx.MultiDiGraph</code> with additional methods for <code>'links'</code> which are unique in <code>genet.Network</code> (<code>networkx.MultiDiGraph</code> accepts multiple edges between the same from and to node pair; referring to an edge in <code>networkx.MultiDiGraph</code> and <code>genet.Network</code> has the same effects, i.e. the result is a dictionary indexed by the multi edge index). The PT services are represented through the <code>genet.Schedule</code> class which relies on other <code>genet</code> classes: the <code>Schedule</code> relies on a list of <code>genet.Service</code>'s, which in turn consists of a list of <code>genet.Route</code>'s. Each <code>Route</code> class object has an attribute <code>stops</code> which consists of <code>genet.Stops</code> objects. The <code>Stops</code> carry spatial information for the PT stop.</p> <p>You can use GeNet's CLI to run pre-baked modifications or checks on networks. You can also write your own python scripts, importing genet as a package, use IPython shell or Jupyter Notebook to load up a network, inspect or change it and save it out to file.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>GeNet is an actively maintained and utilised project.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>to report issues, request features, or exchange with our community, just follow the links below.</p> <p>Is something not working?</p> <p> Report a bug</p> <p>Missing information in our docs?</p> <p> Report a docs issue</p> <p>Want to submit an idea?</p> <p> Request a change</p> <p>Have a question or need help?</p> <p> Ask a question</p>"},{"location":"contributing/#developing-genet","title":"Developing genet","text":"<p>To find beginner-friendly existing bugs and feature requests you may like to start out with, take a look at our good first issues.</p>"},{"location":"contributing/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>To create a development environment for genet, with all libraries required for development and quality assurance installed, it is easiest to install genet using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the genet repository: <code>git clone git@github.com:arup-group/genet.git</code></li> <li>Change into the <code>genet</code> directory: <code>cd genet</code></li> <li>Create the genet mamba environment: <code>mamba create -n genet -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt</code></li> <li>Activate the genet mamba environment: <code>mamba activate genet</code></li> <li>Install the cml-genet package into the environment, in editable mode and ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps -e .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/genet.git\ncd genet\nmamba create -n genet -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt\nmamba activate genet\npip install --no-deps -e .\nipython kernel install --user --name=genet\n</code></pre> <p>If installing directly with pip, you can install these libraries using the <code>dev</code> option, i.e., <code>pip install -e '.[dev]'</code> Either way, you should add your environment as a jupyter kernel, so the example notebooks can run in the tests: <code>ipython kernel install --user --name=genet</code> If you plan to make changes to the code then please make regular use of the following tools to verify the codebase while you work:</p> <ul> <li><code>pre-commit</code>: run <code>pre-commit install</code> in your command line to load inbuilt checks that will run every time you commit your changes. The checks are: 1. check no large files have been staged, 2. lint python files for major errors, 3. format python files to conform with the PEP8 standard. You can also run these checks yourself at any time to ensure staged changes are clean by calling <code>pre-commit</code>.</li> <li><code>pytest</code> - run the unit test suite and check test coverage.</li> </ul> <p>Note</p> <p>If you already have an environment called <code>genet</code> on your system (e.g., for a stable installation of the package), you will need to chose a different environment name. You will then need to add this as a pytest argument when running the tests: <code>pytest --nbmake-kernel=[my-env-name]</code>.</p>"},{"location":"contributing/#rapid-fire-testing","title":"Rapid-fire testing","text":"<p>The following options allow you to strip down the test suite to the bare essentials:</p> <ol> <li>The test suite includes unit tests and integration tests (in the form of jupyter notebooks found in the <code>examples</code> directory). The integration tests can be slow, so if you want to avoid them during development, you should run <code>pytest tests/</code>.</li> <li>You can avoid generating coverage reports, by adding the <code>--no-cov</code> argument: <code>pytest --no-cov</code>.</li> </ol> <p>All together:</p> <pre><code>pytest tests/ --no-cov\n</code></pre> <p>Note</p> <p>If you are debugging failing tests using the <code>--pdb</code> flag, tests will only run on one thread instead of the default (which is the maximum number of threads your machine has available). This will slow down your tests, so do not use <code>--pdb</code> unless you are actively debugging.</p>"},{"location":"contributing/#updating-the-project-when-the-template-updates","title":"Updating the project when the template updates","text":"<p>This project has been built with cruft based on the Arup Cookiecutter template. When changes are made to the base template, they can be merged into this project by running <code>cruft update</code> from the  <code>genet</code> conda environment.</p> <p>You may be prompted to do this when you open a Pull Request, if our automated checks identify that the template is newer than that used in the project.</p>"},{"location":"contributing/#submitting-changes","title":"Submitting changes","text":"<p>To contribute changes:</p> <ol> <li>Fork the project on GitHub.</li> <li>Create a feature branch to work on in your fork (<code>git checkout -b new-fix-or-feature</code>).</li> <li>Test your changes using <code>pytest</code>.</li> <li>Commit your changes to the feature branch (you should have <code>pre-commit</code> installed to ensure your code is correctly formatted when you commit changes).</li> <li>Push the branch to GitHub (<code>git push origin new-fix-or-feature</code>).</li> <li>On GitHub, create a new pull request from the feature branch.</li> </ol>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Before submitting a pull request, check whether you have:</p> <ul> <li>Added your changes to <code>CHANGELOG.md</code>.</li> <li>Added or updated documentation for your changes.</li> <li>Added tests if you implemented new functionality or fixed a bug.</li> </ul> <p>When opening a pull request, please provide a clear summary of your changes!</p>"},{"location":"contributing/#commit-messages","title":"Commit messages","text":"<p>Please try to write clear commit messages. One-line messages are fine for small changes, but bigger changes should look like this:</p> <pre><code>A brief summary of the commit (max 50 characters)\n\nA paragraph or bullet-point list describing what changed and its impact,\ncovering as many lines as needed.\n</code></pre>"},{"location":"contributing/#code-conventions","title":"Code conventions","text":"<p>Start reading our code and you'll get the hang of it.</p> <p>We mostly follow the official Style Guide for Python Code (PEP8).</p> <p>We have chosen to use the uncompromising code formatter <code>black</code> and the linter <code>ruff</code>. When run from the root directory of this repo, <code>pyproject.toml</code> should ensure that formatting and linting fixes are in line with our custom preferences (e.g., 100 character maximum line length). The philosophy behind using <code>black</code> is to have uniform style throughout the project dictated by code. Since <code>black</code> is designed to minimise diffs, and make patches more human readable, this also makes code reviews more efficient. To make this a smooth experience, you should run <code>pre-commit install</code> after setting up your development environment, so that <code>black</code> makes all the necessary fixes to your code each time you commit, and so that <code>ruff</code> will highlight any errors in your code. If you prefer, you can also set up your IDE to run these two tools whenever you save your files, and to have <code>ruff</code> highlight erroneous code directly as you type. Take a look at their documentation for more information on configuring this.</p> <p>We require all new contributions to have docstrings for all modules, classes and methods. When adding docstrings, we request you use the Google docstring style.</p>"},{"location":"contributing/#release-checklist","title":"Release checklist","text":""},{"location":"contributing/#pre-release","title":"Pre-release","text":"<ul> <li> Make sure all unit and integration tests pass (This is best done by creating a pre-release pull request).</li> <li> Re-run tutorial Jupyter notebooks (<code>pytest examples/ --overwrite</code>).</li> <li> Make sure documentation builds without errors (<code>mike deploy [version]</code>, where <code>[version]</code> is the current minor release of the form <code>X.Y</code>).</li> <li> Make sure the changelog is up-to-date, especially that new features and backward incompatible changes are clearly marked.</li> </ul>"},{"location":"contributing/#create-release","title":"Create release","text":"<ul> <li> Bump the version number in <code>src/genet/__init__.py</code></li> <li> Update the changelog with final version number of the form <code>vX.Y.Z</code>, release date, and github <code>compare</code> link (at the bottom of the page).</li> <li> Commit with message <code>Release vX.Y.Z</code>, then add a <code>vX.Y.Z</code> tag.</li> <li> Create a release pull request to verify that the conda package builds successfully.</li> <li> Once the PR is approved and merged, create a release through the GitHub web interface, using the same tag, titling it <code>Release vX.Y.Z</code> and include all the changelog elements that are not flagged as internal.</li> </ul>"},{"location":"contributing/#post-release","title":"Post-release","text":"<ul> <li> Update the changelog, adding a new <code>[Unreleased]</code> heading.</li> <li> Update <code>src/genet/__init__.py</code> to the next version appended with <code>.dev0</code>, in preparation for the next main commit.</li> </ul>"},{"location":"docker/","title":"Using GeNet as a Docker image","text":"<p>If you have installed GeNet as a Docker image, you can follow the steps here to run the GeNet CLI and to run your own scripts.</p>"},{"location":"docker/#using-the-cli-inside-a-container","title":"Using the cli inside a container","text":"<p>Use <code>docker run cml-genet genet ...</code> to run the command line scripts within the Docker image, e.g.:</p> <pre><code>docker run cml-genet genet simplify-network --network /path/to/network.xml [...]\n</code></pre> <p>Note</p> <p>You will reference data outside the docker container as inputs, the docker command will need the path to data mounted and be referenced according to the alias given, e.g.</p> <pre><code>docker run -v /local/path/:/mnt/ cml-genet genet simplify-network --network /mnt/network.xml [...]\n</code></pre> <p>If the input network file lives at <code>/local/path/network.xml</code>.</p> <p>A full list of the available command line scripts is given on our CLI page. You can also get a list of options directly from the image:</p> <pre><code>docker run cml-genet genet --help\n</code></pre> <p>to show the list of available commands, and e.g.</p> <pre><code>docker run cml-genet genet simplify-network --help\n</code></pre> <p>to show description of the command and parameters.</p>"},{"location":"docker/#running-custom-script-inside-a-container","title":"Running custom script inside a container","text":"<p>Say you write a script <code>/local/path/my_genet_scripts/script.py</code> and you want to run it inside a docker container. You will need to mount the local path to the container for the script to be found and use the generic <code>python</code> as part of your command:</p> <pre><code>docker run -v /local/path/:/mnt/ cml-genet python /mnt/my_genet_scripts/script.py\n</code></pre> <p>Note</p> <p>If you reference data inside your script, or pass them as arguments to the script, they need to reference the aliased path inside the container. Here: <code>/mnt/</code>, rather than the path <code>/local/path/</code>.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-docker","title":"Using Docker","text":"<p>If you want to avoid Python environments, you can use a Docker image to run GeNet. To build the image:</p> <pre><code>git clone git@github.com:arup-group/genet.git\ncd genet\ndocker build -t \"cml-genet\" .\n</code></pre> <p>Instructions for running GeNet from within the Docker image can be found here.</p>"},{"location":"installation/#setting-up-a-user-environment","title":"Setting up a user environment","text":"<p>As a <code>genet</code> user, it is easiest to install using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the genet repository: <code>git clone git@github.com:{{ cookiecutter.repository_owner }}/genet.git</code></li> <li>Change into the <code>genet</code> directory: <code>cd genet</code></li> <li>Create the genet mamba environment: <code>mamba create -n genet -c conda-forge -c city-modelling-lab --file requirements/base.txt</code></li> <li>Activate the genet mamba environment: <code>mamba activate genet</code></li> <li>Install the cml-genet package into the environment, ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/genet.git\ncd genet\nmamba create -n genet -c conda-forge -c city-modelling-lab --file requirements/base.txt\nmamba activate genet\npip install --no-deps .\n</code></pre>"},{"location":"installation/#running-the-example-notebooks","title":"Running the example notebooks","text":"<p>If you have followed the non-developer installation instructions above, you will need to install <code>jupyter</code> into your <code>genet</code> environment to run the example notebooks:</p> <pre><code>mamba install -n genet jupyter\n</code></pre> <p>With Jupyter installed, it's easiest to then add the environment as a jupyter kernel:</p> <pre><code>mamba activate genet\nipython kernel install --user --name=genet\njupyter notebook\n</code></pre>"},{"location":"installation/#choosing-a-different-environment-name","title":"Choosing a different environment name","text":"<p>If you would like to use a different name to <code>genet</code> for your mamba environment, the installation becomes (where <code>[my-env-name]</code> is your preferred name for the environment):</p> <pre><code>mamba create -n [my-env-name] -c conda-forge -c city-modelling-lab --file requirements/base.txt\nmamba activate [my-env-name]\nipython kernel install --user --name=[my-env-name]\n</code></pre>"},{"location":"installation/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>The install instructions are slightly different to create a development environment compared to a user environment:</p> <pre><code>git clone git@github.com:arup-group/genet.git\ncd genet\nmamba create -n genet -c conda-forge -c city-modelling-lab --file requirements/base.txt --file requirements/dev.txt\nmamba activate genet\npip install --no-deps -e .\nipython kernel install --user --name=genet\n</code></pre> <p>For more detailed installation instructions specific to developing the genet codebase, see our development documentation.</p>"},{"location":"installation/#a-note-on-the-mathematical-solver","title":"A note on the mathematical solver","text":"<p>Note</p> <p>The default CBC solver is pre-installed inside GeNet's Docker image, which can save you some installation effort.</p> <p>To use methods which snap public transit to the graph, GeNet uses a mathematical solver. If you won't be using such functionality, you do not need to install this solver. Methods default to CBC, an open source solver. On Non-Windows devices, you can install this solver (<code>coin-or-cbc</code>) along with your other requirements when creating the environment: <code>mamba create -n genet -c conda-forge -c city-modelling-lab coin-or-cbc --file requirements/base.txt</code>, or install it after the fact <code>mamba install -n genet coin-or-cbc</code></p> <p>Any solver supported by Pyomo can be used. Another good open source choice is GLPK. The solver you use needs to support MILP - mixed integer linear programming.</p>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#genet","title":"genet","text":"<p>GeNet Command Line Tool.</p> <p>Usage:</p> <pre><code>genet [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-add-elevation-to-network","title":"genet add-elevation-to-network","text":"<p>Add elevation data to network nodes, validate it, and calculate link slopes.</p> <p>Usage:</p> <pre><code>genet add-elevation-to-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-el</code>, <code>--elevation</code> path Path to the elevation tif file _required <code>-nv</code>, <code>--null_value</code> float Value that represents null in the elevation tif file <code>0.0</code> <code>-nwe</code>, <code>--no-write_elevation_to_network</code> boolean Do not write node elevation data as attribute to the network <code>True</code> <code>-nwsn</code>, <code>--no-write_slope_to_network</code> boolean Do not write link slope data as attribute to the network <code>True</code> <code>-nwsoa</code>, <code>--no-write_slope_to_object_attribute_file</code> boolean Do not write link slope data to object attribute file <code>True</code> <code>-nsj</code>, <code>--no-save_jsons</code> boolean Do not save elevation and slope dictionaries and report <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-auto-schedule-fixes","title":"genet auto-schedule-fixes","text":"<p>Script to check and correct, if needed, the speed and headway of services in the schedule.</p> <p>Checks and corrects for:    - zero headways - we check that there are no 0 minute headways.      that would mean two of the same trips start at the same time.      To correct this we delete one of the trips, treating it as a duplicate.    - infinite speeds - We calculate speed between each stop pair for services.      We use the declared times at stops and crow-fly distance * 1.3 network factor.      This is done also for routed modes like bus to simplify things,      as we are only after infinite speeds which will show up whether we use the true route or not.      Infinite speeds exist as a consequence of division by zero (time).      This is corrected by recalculating the arrival and departure times at the problem stops;      the times at other stops are kept the same as much as possible.</p> <p>Usage:</p> <pre><code>genet auto-schedule-fixes [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-s</code>, <code>--schedule</code> path Location of the input schedule.xml file _required <code>-v</code>, <code>--vehicles</code> path Location of the input vehicles.xml file None <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-vsc</code>, <code>--vehicle_scalings</code> text Comma delimited list of scales for vehicles <code>1,10</code> <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-generate-standard-outputs","title":"genet generate-standard-outputs","text":"<p>Generate Standard outputs for a network and/or schedule</p> <p>Usage:</p> <pre><code>genet generate-standard-outputs [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-s</code>, <code>--schedule</code> path Location of the input schedule.xml file None <code>-v</code>, <code>--vehicles</code> path Location of the input vehicles.xml file None <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-inspect-google-directions-requests-for-network","title":"genet inspect-google-directions-requests-for-network","text":"<p>Generate Google Directions API requests for a network for inspection</p> <p>Usage:</p> <pre><code>genet inspect-google-directions-requests-for-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-sc</code>, <code>--subset_conditions</code> text Comma delimited list of values to subset the network by using attributes-osm:way:highway network attributes, e.g., <code>primary,motorway</code>} None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-intermodal-access-egress-network","title":"genet intermodal-access-egress-network","text":"<p>Process to add access and egress links for PT stops of given modes.</p> <p>Intended to generate PT schedules to work with SBB extensions in MATSim: https://github.com/matsim-org/matsim-libs/tree/master/contribs/sbb-extensions#intermodal-access-and-egress</p> <p>Usage:</p> <pre><code>genet intermodal-access-egress-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-s</code>, <code>--schedule</code> path Location of the input schedule.xml file None <code>-v</code>, <code>--vehicles</code> path Location of the input vehicles.xml file None <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-pm</code>, <code>--pt_modes</code> text Comma delimited list of modes to subset stops of interest. A stop is linked to a mode via a transit route using that stop. Optional, otherwise considers all stops None <code>-nm</code>, <code>--network_snap_modes</code> text Comma delimited list of modes to subset the network graph. The links from this modal subgraph will be considered for the stop to graph relationship. Two new attributes (per mode) will be added to PT stops:xmodeAccessible = true and accessLinkId_xmode = link_id <code>car</code> <code>-tm</code>, <code>--teleport_modes</code> text Comma delimited list of (teleported) modes to enable for given PT stops No links will be found for these modes. One new attributes (per mode) will be added to PT stops: xmodeAccessible = true None <code>-ss</code>, <code>--step_size</code> float In metres. This process finds links in the nearest neighbourhood of a stop. The size of the neighbourhood increases by <code>step_size</code> value each time until it finds links to relate to stops. <code>25</code> <code>-dt</code>, <code>--distance_threshold</code> float In metres. This is the limit of how wide the search area for a link can be for each stop. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-make-pt-network","title":"genet make-pt-network","text":"<p>Create a PT MATSim network</p> <p>Usage:</p> <pre><code>genet make-pt-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file None <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-oc</code>, <code>--osm_config</code> file Location of the config file defining what and how to read from the osm file None <code>-o</code>, <code>--osm</code> file Location of the osm file None <code>-gd</code>, <code>--gtfs_day</code> text gtfs day to use in the format <code>YYYYMMDD</code> _required <code>-g</code>, <code>--gtfs</code> path Location of the gtfs zip file of folder with gtfs text files _required <code>-pp</code>, <code>--processes</code> integer Number of parallel processes to split process across <code>1</code> <code>-sd</code>, <code>--snapping_distance</code> float Distance for snapping network nodes to transit stops <code>30</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-make-road-only-network","title":"genet make-road-only-network","text":"<p>Create a road-only MATSim network</p> <p>Usage:</p> <pre><code>genet make-road-only-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-oc</code>, <code>--osm_config</code> file Location of the config file defining what and how to read from the osm file _required <code>-o</code>, <code>--osm</code> file Location of the osm file _required <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-pp</code>, <code>--processes</code> integer Number of parallel processes to split process across <code>1</code> <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-cc</code>, <code>--connected_components</code> integer Number of connected components within graph for modes <code>walk</code>,<code>bike</code>,<code>car</code> <code>1</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-reproject-network","title":"genet reproject-network","text":"<p>Reproject a MATSim network</p> <p>Usage:</p> <pre><code>genet reproject-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-s</code>, <code>--schedule</code> path Location of the input schedule.xml file None <code>-v</code>, <code>--vehicles</code> path Location of the input vehicles.xml file None <code>-pp</code>, <code>--processes</code> integer Number of parallel processes to split process across <code>1</code> <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-cp</code>, <code>--current_projection</code> text The projection network is currently in, eg. \"epsg:27700\" _required <code>-np</code>, <code>--new_projection</code> text The projection desired, eg. \"epsg:27700\" _required <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-scale-vehicles","title":"genet scale-vehicles","text":"<p>Scale PT Schedule vehicles</p> <p>Usage:</p> <pre><code>genet scale-vehicles [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-s</code>, <code>--schedule</code> path Location of the input schedule.xml file None <code>-v</code>, <code>--vehicles</code> path Location of the input vehicles.xml file None <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-vsc</code>, <code>--vehicle_scalings</code> text Comma delimited list of scales for vehicles <code>1,10</code> <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-send-google-directions-requests-for-network","title":"genet send-google-directions-requests-for-network","text":"<p>Generate and send Google Directions API requests</p> <p>Usage:</p> <pre><code>genet send-google-directions-requests-for-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-sc</code>, <code>--subset_conditions</code> text Comma delimited list of values to subset the network by using attributes-osm:way:highway network attributes, e.g., <code>primary,motorway</code>} None <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-t</code>, <code>--requests_threshold</code> integer Max number of API requests you are happy to send. If exceeded, will fail without sending any _required <code>-k</code>, <code>--api_key</code> text Google Directions API key if not using AWS secrets manager None <code>-sn</code>, <code>--secret_name</code> text Secret name in AWS Secrets manager, if not passing the API key directly None <code>-rn</code>, <code>--region_name</code> text Region name in AWS, if not passing the API key directly None <code>-tm</code>, <code>--traffic_model</code> text Google Directions API traffic model to consider when calculating time in traffic for choices. See https://developers.google.com/maps/documentation/directions/get-directions#traffic_model <code>best_guess</code> <code>-dp</code>, <code>--departure_time</code> text desired time of departure, in unix time, or <code>now</code> for current traffic conditions <code>now</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-separate-modes-in-network","title":"genet separate-modes-in-network","text":"<p>Generate new links, each for the use of a singular mode in a MATSim network.</p> <p>This creates separate modal subgraphs for the given modes. It can be used with MATSim to ensure the two modes do not come in contact.</p> <p>Examples:</p> <pre><code>```python\n[1] network.link(\"LINK_ID\")\n[out] {\"id\": \"LINK_ID\", \"modes\": {\"car\", \"bike\"}, \"freespeed\": 5, ...}\n```\n\nThe new bike link will assume all the same attributes apart from the \"modes\":\n```python\n[1] network.link(\"bike---LINK_ID\")`\n[out] {\"id\": \"bike---LINK_ID\", \"modes\": {\"bike\"}, \"freespeed\": 5, ...}\n```\n\nIn the case when a link already has a single dedicated mode, it will be replaced aby a link with a new, prefixed ID.\nOther links modes will have changed also.\nSo, any simulation outputs may not be valid with this new network.\n</code></pre> <p>Usage:</p> <pre><code>genet separate-modes-in-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-m</code>, <code>--modes</code> text Comma delimited list of modes to split from the network _required <code>-ic</code>, <code>--increase_capacity</code> boolean Sets capacity on detached links to 9999 <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-simplify-network","title":"genet simplify-network","text":"<p>Simplify a MATSim network by removing intermediate links from paths</p> <p>Usage:</p> <pre><code>genet simplify-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-s</code>, <code>--schedule</code> path Location of the input schedule.xml file None <code>-v</code>, <code>--vehicles</code> path Location of the input vehicles.xml file None <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-pp</code>, <code>--processes</code> integer Number of parallel processes to split process across <code>1</code> <code>-vsc</code>, <code>--vehicle_scalings</code> text Comma delimited list of scales for vehicles <code>1,10</code> <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-fc</code>, <code>--force_strongly_connected_graph</code> boolean If True, checks for disconnected subgraphs for modes <code>walk</code>, <code>bike</code> and <code>car</code>. If there are more than one strongly connected subgraph, genet connects them with links at closest points in the graph. The links used to connect are weighted at 20% of surrounding freespeed and capacity values. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-squeeze-external-area","title":"genet squeeze-external-area","text":"<p>Changes <code>freespeed</code> and <code>capacity</code> values for links outside of the given <code>study_area</code> by given factors.</p> <p>To squeeze links within the study area, refer to the <code>squeeze_urban_links</code> command.</p> <p>Usage:</p> <pre><code>genet squeeze-external-area [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-c</code>, <code>--capacity</code> float Factor, e.g. 0.5, to reduce the 'capacity' attribute for the roads being squeezed. The current value will be multiplied by this factor. <code>1</code> <code>-f</code>, <code>--freespeed</code> float Factor, e.g. 0.5, to reduce the 'freespeed' attribute for the roads being squeezed. The current value will be multiplied by this factor. <code>1</code> <code>-sa</code>, <code>--study_area</code> path Geojson or shp file that when read into geopandas produces a table with a geometry column that describes the area which should be left unaffected by speed and capacity factors. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-squeeze-urban-links","title":"genet squeeze-urban-links","text":"<p>Tag minor network links as urban, given geometries: <code>urban_geometries</code>.</p> <p>Minor links are defined as anything other than: osm way highway tags: motorway, motorway_link, trunk, trunk_link, primary, primary_link. Urban geometries are passed via geojson input with a specific format, see command arguments for description. Passing <code>study_area</code> subsets the urban geometries and links to be squeezed - only links in the study area will be tagged and squeezed. This is useful if your geometries covers a larger area. The script then reduces capacity and/or freespeed by a factor of current value on those links.</p> <p>To squeeze links outside the study area, refer to the <code>squeeze_external_area.py</code> command.</p> <p>Usage:</p> <pre><code>genet squeeze-urban-links [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>-ug</code>, <code>--urban_geometries</code> path Geojson or shp file that when read into geopandas produces a table with columns: \"label\" (with at least some of the values in this column being a string: \"urban\") and \"geometry\" (polygons defining urban areas) _required <code>-c</code>, <code>--capacity</code> float Factor, e.g. 0.5, to reduce the 'capacity' attribute for the roads being squeezed. The current value will be multiplied by this factor. <code>1</code> <code>-f</code>, <code>--freespeed</code> float Factor, e.g. 0.5, to reduce the 'freespeed' attribute for the roads being squeezed. The current value will be multiplied by this factor. <code>1</code> <code>-sa</code>, <code>--study_area</code> path Geojson or shp file that when read into geopandas produces a table with a geometry column that describes the area which should be left unaffected by speed and capacity factors. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#genet-validate-network","title":"genet validate-network","text":"<p>Run MATSim specific validation methods on a MATSim network</p> <p>Usage:</p> <pre><code>genet validate-network [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--network</code> path Location of the input network.xml file _required <code>-s</code>, <code>--schedule</code> path Location of the input schedule.xml file None <code>-v</code>, <code>--vehicles</code> path Location of the input vehicles.xml file None <code>-p</code>, <code>--projection</code> text The projection network is in, eg. \"epsg:27700\" _required <code>-od</code>, <code>--output_dir</code> directory Output directory _required <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"examples/1_intro_to_genet/","title":"1. Introduction to GeNet","text":"In\u00a0[1]: Copied! <pre>from genet import Network\n</pre> from genet import Network <p>To initialise an empty <code>Network</code>, you need a coordinate system. We've gone with the British National Grid.</p> In\u00a0[2]: Copied! <pre>n = Network(epsg=\"epsg:27700\")\n</pre> n = Network(epsg=\"epsg:27700\") <p>You can get quick stats on the <code>Network</code> by calling <code>n.print()</code> method or just running the cell with network object.</p> In\u00a0[3]: Copied! <pre>n\n</pre> n Out[3]: <pre>&lt;Network instance at 140419464489296: with \ngraph: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 0\nNumber of edges: 0\n and \nschedule Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0</pre> In\u00a0[4]: Copied! <pre>n.print()\n</pre> n.print() <pre>Graph info: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 0\nNumber of edges: 0\n \nSchedule info: Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0\n</pre> <p>Right now the <code>Network</code> is empty. You can fill it in with MATSim network data, using Open Street Map (OSM) data (Please refer to notebooks on reading data) or we can add links ourselves. A single link or a few links at once.</p> In\u00a0[5]: Copied! <pre>link_id = n.add_link(link_id=\"1\", u=\"A\", v=\"B\", attribs={\"modes\": [\"car\", \"walk\"]})\n</pre> link_id = n.add_link(link_id=\"1\", u=\"A\", v=\"B\", attribs={\"modes\": [\"car\", \"walk\"]}) <pre>2022-07-14 15:15:47,508 - Added Link with index 1, from node:A to node:B, under multi-index:0, and data={'modes': ['car', 'walk'], 'from': 'A', 'to': 'B', 'id': '1'}\n</pre> In\u00a0[6]: Copied! <pre>link_id\n</pre> link_id Out[6]: <pre>'1'</pre> <p>Even though you specify a link id in this method, this id can change if there already exists a link with that id in the <code>Network</code>. This is why this method returns the link id under which the link was added. Let's try to add the same link again.</p> In\u00a0[7]: Copied! <pre>link_id = n.add_link(link_id=\"1\", u=\"A\", v=\"B\", attribs={\"modes\": [\"car\", \"walk\"]})\n</pre> link_id = n.add_link(link_id=\"1\", u=\"A\", v=\"B\", attribs={\"modes\": [\"car\", \"walk\"]}) <pre>2022-07-14 15:15:47,548 - Generated 1 link ids.\n2022-07-14 15:15:47,563 - Generated link id 0.\n2022-07-14 15:15:47,565 - `1` already exists. Generated a new unique_index: `0`\n2022-07-14 15:15:47,582 - Added Link with index 0, from node:A to node:B, under multi-index:1, and data={'modes': ['car', 'walk'], 'from': 'A', 'to': 'B', 'id': '0'}\n</pre> In\u00a0[8]: Copied! <pre>link_id\n</pre> link_id Out[8]: <pre>'0'</pre> <p>If you are adding many edges between the same two nodes you can also specify which multi index you want a link to use</p> In\u00a0[9]: Copied! <pre>link_id = n.add_link(\n    link_id=\"1\", u=\"A\", v=\"B\", attribs={\"modes\": [\"car\", \"walk\"]}, multi_edge_idx=5\n)\n</pre> link_id = n.add_link(     link_id=\"1\", u=\"A\", v=\"B\", attribs={\"modes\": [\"car\", \"walk\"]}, multi_edge_idx=5 ) <pre>2022-07-14 15:15:47,638 - Generated 1 link ids.\n2022-07-14 15:15:47,642 - Generated link id 2.\n2022-07-14 15:15:47,643 - `1` already exists. Generated a new unique_index: `2`\n2022-07-14 15:15:47,650 - Added Link with index 2, from node:A to node:B, under multi-index:5, and data={'modes': ['car', 'walk'], 'from': 'A', 'to': 'B', 'id': '2'}\n</pre> <p>To add several links it is faster to use the <code>add_links</code> method. This expects a dictionary with keys referring to desired link ids and the values being attribute dictionaries saved on those links. At the minimum each attribute dictionary needs a <code>'from'</code> and <code>'to'</code> key referring to from and to nodes the link is connecting.</p> In\u00a0[10]: Copied! <pre>reindexing_dict, links_and_attributes = n.add_links(\n    links_and_attributes={\n        \"1\": {\"from\": \"A\", \"to\": \"B\", \"modes\": [\"bike\"]},\n        \"10\": {\"from\": \"B\", \"to\": \"A\", \"modes\": [\"bike\"]},\n    }\n)\n</pre> reindexing_dict, links_and_attributes = n.add_links(     links_and_attributes={         \"1\": {\"from\": \"A\", \"to\": \"B\", \"modes\": [\"bike\"]},         \"10\": {\"from\": \"B\", \"to\": \"A\", \"modes\": [\"bike\"]},     } ) <pre>2022-07-14 15:15:47,690 - Generated 1 link ids.\n2022-07-14 15:15:47,699 - Added 2 links\n</pre> <p>This method also checks for links with clashing indices and returns a dictionary showing which ids we're reindex and what their new indices are, as well as an updated links_and_attributes dictionary showing final link attributes added to the <code>Network</code>.</p> In\u00a0[11]: Copied! <pre>reindexing_dict\n</pre> reindexing_dict Out[11]: <pre>{'1': '3'}</pre> In\u00a0[12]: Copied! <pre>links_and_attributes\n</pre> links_and_attributes Out[12]: <pre>{'3': {'from': 'A', 'to': 'B', 'modes': ['bike'], 'id': '3'},\n '10': {'from': 'B', 'to': 'A', 'modes': ['bike'], 'id': '10'}}</pre> <p>Each node should have a spatial reference. For now we worked with nodes <code>A</code> and <code>B</code>, which dont have this information. To check what information is saved under nodes or links</p> In\u00a0[13]: Copied! <pre>n.node_attribute_summary(data=False)\n</pre> n.node_attribute_summary(data=False) <pre>attribute\n</pre> In\u00a0[14]: Copied! <pre>n.link_attribute_summary(data=True)\n</pre> n.link_attribute_summary(data=True) <pre>attribute\n\u251c\u2500\u2500 modes: ['walk', 'car', 'bike']\n\u251c\u2500\u2500 from: ['B', 'A']\n\u251c\u2500\u2500 to: ['B', 'A']\n\u2514\u2500\u2500 id: ['1', '2', '3', '0', '10']\n</pre> <p>To add spatial information to nodes we can use <code>apply_attributes_to_node</code> or <code>apply_attributes_to_nodes</code> methods. We have two nodes so let's use the latter. GeNet expects values <code>x</code> and <code>y</code> in the coordinate system declared at the time of initiating the <code>Network</code>.</p> In\u00a0[15]: Copied! <pre>n.apply_attributes_to_nodes(\n    new_attributes={\n        \"A\": {\"x\": 528704.1425925883, \"y\": 182068.78193707118},\n        \"B\": {\"x\": 528835.203274008, \"y\": 182006.27331298392},\n    }\n)\n</pre> n.apply_attributes_to_nodes(     new_attributes={         \"A\": {\"x\": 528704.1425925883, \"y\": 182068.78193707118},         \"B\": {\"x\": 528835.203274008, \"y\": 182006.27331298392},     } ) <pre>2022-07-14 15:15:47,798 - Changed Node attributes for 2 nodes\n</pre> In\u00a0[16]: Copied! <pre>n.node_attribute_summary(data=False)\n</pre> n.node_attribute_summary(data=False) <pre>attribute\n\u251c\u2500\u2500 x\n\u2514\u2500\u2500 y\n</pre> <p>Now that we have spatial information for the nodes, we can do a quick plot of the <code>Network</code>.</p> In\u00a0[17]: Copied! <pre># n.plot()\n</pre> # n.plot() <p>The plots get much more interesting the more links you have in the <code>Network</code>. Any additions and changes we made are recorded in the <code>Network</code>s changelog.</p> In\u00a0[18]: Copied! <pre>n.change_log.head(10)\n</pre> n.change_log.head(10) Out[18]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 0 2022-07-14 15:15:47 add link None 1 None {'modes': ['car', 'walk'], 'from': 'A', 'to': ... [(add, , [('modes', ['car', 'walk']), ('from',... 1 2022-07-14 15:15:47 add link None 0 None {'modes': ['car', 'walk'], 'from': 'A', 'to': ... [(add, , [('modes', ['car', 'walk']), ('from',... 2 2022-07-14 15:15:47 add link None 2 None {'modes': ['car', 'walk'], 'from': 'A', 'to': ... [(add, , [('modes', ['car', 'walk']), ('from',... 3 2022-07-14 15:15:47 add link None 3 None {'from': 'A', 'to': 'B', 'modes': ['bike'], 'i... [(add, , [('from', 'A'), ('to', 'B'), ('modes'... 4 2022-07-14 15:15:47 add link None 10 None {'from': 'B', 'to': 'A', 'modes': ['bike'], 'i... [(add, , [('from', 'B'), ('to', 'A'), ('modes'... 5 2022-07-14 15:15:47 modify node A A {} {'x': 528704.1425925883, 'y': 182068.78193707118} [(add, , [('x', 528704.1425925883), ('y', 1820... 6 2022-07-14 15:15:47 modify node B B {} {'x': 528835.203274008, 'y': 182006.27331298392} [(add, , [('x', 528835.203274008), ('y', 18200... <p>Another important part of the <code>Network</code> is the <code>Schedule</code> element describing public transit.</p> In\u00a0[19]: Copied! <pre>from genet import Schedule\n</pre> from genet import Schedule In\u00a0[20]: Copied! <pre>n.schedule.print()\n</pre> n.schedule.print() <pre>Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0\n</pre> <p>It is initiated empty with a <code>Network</code>. Right now, GeNet does not have nice methods to add and change Schedules. You can generate a <code>Schedule</code> using different <code>Schedule</code> elements: <code>Service</code>, <code>Route</code> and <code>Stop</code>, or by reading GTFS data (Please refer to notebooks on reading data).</p> In\u00a0[21]: Copied! <pre>from genet import Route, Service, Stop\n</pre> from genet import Route, Service, Stop <p>Each <code>Schedule</code> consists of <code>Services</code>. A <code>Service</code> corresponds to a specific transit line, for example the Piccadilly London Underground line. Each <code>Service</code> will have a number of <code>Routes</code> which are characterised by an ordered sequence of <code>Stop</code>s. For a network to be a valid multimodal network each <code>Route</code> needs to have a valid reference to <code>Network</code> links. Let's create a <code>Schedule</code> with a bus <code>Service</code>.</p> In\u00a0[22]: Copied! <pre>s = Schedule(\n    epsg=\"epsg:27700\",\n    services=[\n        Service(\n            id=\"service1\",\n            routes=[\n                Route(\n                    id=\"1\",\n                    route_short_name=\"route1\",\n                    mode=\"bus\",\n                    stops=[\n                        Stop(\n                            id=\"0\",\n                            x=529455.7452394223,\n                            y=182401.37630677427,\n                            epsg=\"epsg:27700\",\n                            linkRefId=\"0\",\n                        ),\n                        Stop(\n                            id=\"1\",\n                            x=529350.7866124967,\n                            y=182388.0201078112,\n                            epsg=\"epsg:27700\",\n                            linkRefId=\"1\",\n                        ),\n                    ],\n                    trips={\n                        \"trip_id\": [\"route1_04:40:00\"],\n                        \"trip_departure_time\": [\"04:40:00\"],\n                        \"vehicle_id\": [\"veh_bus_0\"],\n                    },\n                    arrival_offsets=[\"00:00:00\", \"00:02:00\"],\n                    departure_offsets=[\"00:00:00\", \"00:02:00\"],\n                    route=[\"0\", \"1\"],\n                ),\n                Route(\n                    id=\"2\",\n                    route_short_name=\"route2\",\n                    mode=\"bus\",\n                    stops=[\n                        Stop(\n                            id=\"1\",\n                            x=529455.7452394223,\n                            y=182401.37630677427,\n                            epsg=\"epsg:27700\",\n                            linkRefId=\"1\",\n                        ),\n                        Stop(\n                            id=\"2\",\n                            x=529350.7866124967,\n                            y=182388.0201078112,\n                            epsg=\"epsg:27700\",\n                            linkRefId=\"2\",\n                        ),\n                    ],\n                    trips={\n                        \"trip_id\": [\"route2_05:40:00\"],\n                        \"trip_departure_time\": [\"05:40:00\"],\n                        \"vehicle_id\": [\"veh_bus_1\"],\n                    },\n                    arrival_offsets=[\"00:00:00\", \"00:03:00\"],\n                    departure_offsets=[\"00:00:00\", \"00:05:00\"],\n                    route=[\"1\", \"2\"],\n                ),\n            ],\n        )\n    ],\n)\n</pre> s = Schedule(     epsg=\"epsg:27700\",     services=[         Service(             id=\"service1\",             routes=[                 Route(                     id=\"1\",                     route_short_name=\"route1\",                     mode=\"bus\",                     stops=[                         Stop(                             id=\"0\",                             x=529455.7452394223,                             y=182401.37630677427,                             epsg=\"epsg:27700\",                             linkRefId=\"0\",                         ),                         Stop(                             id=\"1\",                             x=529350.7866124967,                             y=182388.0201078112,                             epsg=\"epsg:27700\",                             linkRefId=\"1\",                         ),                     ],                     trips={                         \"trip_id\": [\"route1_04:40:00\"],                         \"trip_departure_time\": [\"04:40:00\"],                         \"vehicle_id\": [\"veh_bus_0\"],                     },                     arrival_offsets=[\"00:00:00\", \"00:02:00\"],                     departure_offsets=[\"00:00:00\", \"00:02:00\"],                     route=[\"0\", \"1\"],                 ),                 Route(                     id=\"2\",                     route_short_name=\"route2\",                     mode=\"bus\",                     stops=[                         Stop(                             id=\"1\",                             x=529455.7452394223,                             y=182401.37630677427,                             epsg=\"epsg:27700\",                             linkRefId=\"1\",                         ),                         Stop(                             id=\"2\",                             x=529350.7866124967,                             y=182388.0201078112,                             epsg=\"epsg:27700\",                             linkRefId=\"2\",                         ),                     ],                     trips={                         \"trip_id\": [\"route2_05:40:00\"],                         \"trip_departure_time\": [\"05:40:00\"],                         \"vehicle_id\": [\"veh_bus_1\"],                     },                     arrival_offsets=[\"00:00:00\", \"00:03:00\"],                     departure_offsets=[\"00:00:00\", \"00:05:00\"],                     route=[\"1\", \"2\"],                 ),             ],         )     ], ) In\u00a0[23]: Copied! <pre>s.print()\n</pre> s.print() <pre>Schedule:\nNumber of services: 1\nNumber of routes: 2\nNumber of stops: 3\n</pre> In\u00a0[24]: Copied! <pre># s.plot()\n</pre> # s.plot() <p>You can replace the <code>Network</code> schedule by your new <code>Schedule</code>.</p> In\u00a0[25]: Copied! <pre>n.schedule = s\n</pre> n.schedule = s In\u00a0[26]: Copied! <pre>n.print()\n</pre> n.print() <pre>Graph info: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 2\nNumber of edges: 5\nAverage in degree:   2.5000\nAverage out degree:   2.5000 \nSchedule info: Schedule:\nNumber of services: 1\nNumber of routes: 2\nNumber of stops: 3\n</pre>"},{"location":"examples/1_intro_to_genet/#1-introduction-to-genet","title":"1. Introduction to GeNet\u00b6","text":"<p>This section goes through basic usage examples. Available as a jupyter notebook and a wiki page.</p>"},{"location":"examples/1_intro_to_genet/#network-data-structure","title":"<code>Network</code> data structure\u00b6","text":"<p>Main schema:</p> <ul> <li>nodes: exist uniquely, hold spatial information.<ul> <li>e.g. A</li> </ul> </li> <li>edges: directed pairs of <code>from</code> and <code>to</code> nodes, often more than one link exists for one <code>(from, to)</code> nodes pair. Sometimes unique.<ul> <li>e.g. A-B has 3 links: Bus, Car and a combined Walk+Bike</li> </ul> </li> <li>links: single edge between a <code>(from, to)</code> nodes pair. Always unique.<ul> <li>e.g. the A-B Bus link (Bus lane going from A to B)</li> </ul> </li> </ul> <p>Data is stored on nodes and edges, where:</p> <ul> <li>nodes hold spatial information</li> <li>each edge/link holds information such as mode of transport allowed, speed, capacity, length, OSM-inherited tags</li> </ul> <p></p> <p><code>Schedule</code> consists of:</p> <ul> <li>List of <code>Service</code>s, where each <code>Service</code> has:<ul> <li>List of <code>Route</code>s, where each <code>Route</code> has:<ul> <li>List of <code>Stop</code>s (The order of <code>Stop</code>s characterises the <code>Route</code> object), where each <code>Stop</code> has:<ul> <li>Spatial information</li> <li>For a multimodal transport network each <code>Stop</code> should reference a link on the network</li> </ul> </li> <li>Dictionary of trips which share that route (with time at first stop and vehicle ID)</li> <li>List of offsets for arrival and departure from <code>Stop</code>s</li> </ul> </li> </ul> </li> <li><code>minimal_transfer_times</code> between <code>Stop</code>s, optional.</li> <li><code>vehicles</code>: dictionary of vehicle IDs from Route objects, mapping them to vehicle types in vehicle_types. Looks like this: <code>{veh_id : {'type': 'bus'}}</code>. Defaults to None and generates itself from the vehicles IDs in Routes, maps to the mode of the Route. Checks if those modes are defined in the <code>vehicle_types</code>.</li> <li><code>vehicle types</code>: dictionary of vehicle types and their specification. Indexed by the vehicle type that vehicles in the <code>vehicles</code> attribute are referring to. E.g.</li> </ul> <pre>{'bus' : {\n    'capacity': {'seats': {'persons': '70'}, 'standingRoom': {'persons': '0'}},\n    'length': {'meter': '18.0'},\n    'width': {'meter': '2.5'},\n    'accessTime': {'secondsPerPerson': '0.5'},\n    'egressTime': {'secondsPerPerson': '0.5'},\n    'doorOperation': {'mode': 'serial'},\n    'passengerCarEquivalents': {'pce': '2.8'}}}\n</pre>"},{"location":"examples/1_intro_to_genet/#setting-up-a-network-object","title":"Setting-up a Network object\u00b6","text":""},{"location":"examples/2_1_reading_data_matsim/","title":"2.1. Reading data: MATSim networks","text":"In\u00a0[1]: Copied! <pre>import os\nfrom pprint import pprint\n\nfrom genet import read_matsim\n</pre> import os from pprint import pprint  from genet import read_matsim In\u00a0[2]: Copied! <pre>path_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\n</pre> path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") <p>We can read the network, schedule and vehicles <code>xml</code> files. You can read only the network, without the schedule, but we wary that some of the operations that you can perform in GeNet may have an impact on the schedule file. For example, simplifying the <code>Network</code> graph will result in a lot of new, simplified, links with different ids. This means the network routes contained for services in the schedule need to be updated and validated.</p> In\u00a0[3]: Copied! <pre>n = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n</pre> n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) In\u00a0[4]: Copied! <pre>n.print()\n</pre> n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> <p>Calling <code>plot</code> method on the network will plot the graph and highlight the schedule's network routes</p> In\u00a0[5]: Copied! <pre># n.plot()\n</pre> # n.plot() <p>You can also just plot the graph on its' own using <code>plot_graph</code></p> In\u00a0[6]: Copied! <pre># n.plot_graph()\n</pre> # n.plot_graph() <p>And the schedule, showing stop-to-stop connections, using <code>plot_schedule</code></p> In\u00a0[7]: Copied! <pre># n.plot_schedule()\n</pre> # n.plot_schedule() <p>We can check what kind of data is stored for nodes:</p> In\u00a0[8]: Copied! <pre>n.node_attribute_summary(data=True)\n</pre> n.node_attribute_summary(data=True) <pre>attribute\n\u251c\u2500\u2500 id: ['9521031', '3826581164', '1678452821', '4074522300', '185620606']\n\u251c\u2500\u2500 x: [528387.4250512555, 528391.4406755936, 528393.2742107178, 528396.6287644263, 528396.3513181042]\n\u251c\u2500\u2500 y: [181547.5850354673, 181552.72935927223, 181558.10532352765, 181559.970402835, 181562.0370527053]\n\u251c\u2500\u2500 lon: [-0.15178558709839862, -0.135349787087776, -0.122919287085967, -0.13766218709633904, -0.14629008709559344]\n\u251c\u2500\u2500 lat: [51.52643403323907, 51.51609983324067, 51.51595583324104, 51.5182034332405, 51.52410423323943]\n\u2514\u2500\u2500 s2_id: [5221390710015643649, 5221390314367946753, 5221366508477440003, 5221390682291777543, 5221390739236081673]\n</pre> <p><code>s2_id</code> refers to S2 Geometry id of that point. We can check what kind of data is stored for links:</p> In\u00a0[9]: Copied! <pre>n.link_attribute_summary(data=False)\n</pre> n.link_attribute_summary(data=False) <pre>attribute\n\u251c\u2500\u2500 id\n\u251c\u2500\u2500 from\n\u251c\u2500\u2500 to\n\u251c\u2500\u2500 freespeed\n\u251c\u2500\u2500 capacity\n\u251c\u2500\u2500 permlanes\n\u251c\u2500\u2500 oneway\n\u251c\u2500\u2500 modes\n\u251c\u2500\u2500 s2_from\n\u251c\u2500\u2500 s2_to\n\u251c\u2500\u2500 attributes\n\u2502   \u251c\u2500\u2500 osm:way:access\n\u2502   \u251c\u2500\u2500 osm:way:highway\n\u2502   \u251c\u2500\u2500 osm:way:id\n\u2502   \u251c\u2500\u2500 osm:way:name\n\u2502   \u251c\u2500\u2500 osm:relation:route\n\u2502   \u251c\u2500\u2500 osm:way:lanes\n\u2502   \u251c\u2500\u2500 osm:way:oneway\n\u2502   \u251c\u2500\u2500 osm:way:tunnel\n\u2502   \u251c\u2500\u2500 osm:way:psv\n\u2502   \u251c\u2500\u2500 osm:way:vehicle\n\u2502   \u251c\u2500\u2500 osm:way:traffic_calming\n\u2502   \u251c\u2500\u2500 osm:way:junction\n\u2502   \u2514\u2500\u2500 osm:way:service\n\u2514\u2500\u2500 length\n</pre> <p>A MATSim network will often have additional data stored under link attributes, e.g.</p> <pre>&lt;link id=\"1\" from=\"1\" to=\"2\" length=\"3\" freespeed=\"4\" capacity=\"600.0\" permlanes=\"1.0\" oneway=\"1\" modes=\"car\" &gt;\n  &lt;attributes&gt;\n    &lt;attribute name=\"osm:way:highway\" class=\"java.lang.String\" &gt;unclassified&lt;/attribute&gt;\n    &lt;attribute name=\"osm:way:id\" class=\"java.lang.Long\" &gt;26997928&lt;/attribute&gt;\n    &lt;attribute name=\"osm:way:name\" class=\"java.lang.String\" &gt;Brunswick Place&lt;/attribute&gt;\n  &lt;/attributes&gt;\n</pre> <p>GeNet handles this as a nested <code>attributes</code> dictionary saved on the links, i.e.</p> In\u00a0[10]: Copied! <pre>pprint(n.link(\"1\"))\n</pre> pprint(n.link(\"1\")) <pre>{'attributes': {'osm:way:access': 'permissive',\n                'osm:way:highway': 'unclassified',\n                'osm:way:id': 26997928.0,\n                'osm:way:name': 'Brunswick Place'},\n 'capacity': 600.0,\n 'freespeed': 4.166666666666667,\n 'from': '25508485',\n 'id': '1',\n 'length': 52.765151087870265,\n 'modes': {'car'},\n 'oneway': '1',\n 'permlanes': 1.0,\n 's2_from': 5221390301001263407,\n 's2_to': 5221390302696205321,\n 'to': '21667818'}\n</pre> <p>GeNet assumes data types for python objects based on the class declared in the file. Below are the mappings responsible for these assumptions:</p> In\u00a0[11]: Copied! <pre>from pprint import pprint\n\nfrom genet.utils.java_dtypes import JAVA_DTYPE_MAP, PYTHON_DTYPE_MAP\n\npprint(JAVA_DTYPE_MAP)\n</pre> from pprint import pprint  from genet.utils.java_dtypes import JAVA_DTYPE_MAP, PYTHON_DTYPE_MAP  pprint(JAVA_DTYPE_MAP) <pre>{'java.lang.Array': &lt;class 'list'&gt;,\n 'java.lang.Boolean': &lt;class 'bool'&gt;,\n 'java.lang.Byte': &lt;class 'int'&gt;,\n 'java.lang.Char': &lt;class 'str'&gt;,\n 'java.lang.Double': &lt;class 'float'&gt;,\n 'java.lang.Float': &lt;class 'float'&gt;,\n 'java.lang.Integer': &lt;class 'int'&gt;,\n 'java.lang.Long': &lt;class 'float'&gt;,\n 'java.lang.Short': &lt;class 'int'&gt;,\n 'java.lang.String': &lt;class 'str'&gt;}\n</pre> In\u00a0[12]: Copied! <pre>pprint(PYTHON_DTYPE_MAP)\n</pre> pprint(PYTHON_DTYPE_MAP) <pre>{&lt;class 'bool'&gt;: 'java.lang.Boolean',\n &lt;class 'float'&gt;: 'java.lang.Float',\n &lt;class 'list'&gt;: 'java.lang.Array',\n &lt;class 'int'&gt;: 'java.lang.Integer',\n &lt;class 'set'&gt;: 'java.lang.Array',\n &lt;class 'str'&gt;: 'java.lang.String'}\n</pre>"},{"location":"examples/2_1_reading_data_matsim/#21-reading-data-matsim-networks","title":"2.1. Reading data: MATSim networks\u00b6","text":"<p>This page goes through methods for reading in MATSim networks. Available as a jupyter notebook or a wiki page.</p>"},{"location":"examples/2_2_reading_data_osm/","title":"2.2. Reading data: OSM","text":"In\u00a0[1]: Copied! <pre>import importlib_resources\n\nfrom genet import read_osm\n</pre> import importlib_resources  from genet import read_osm <p>We use the <code>read_osm</code> method pointing at the osm file we want to read and a config defining which OSM tags to read and which modes to assign to the resulting <code>Network</code> links. For details on how to set up the config head over to the wiki page.</p> <p>GeNet ingests OSM data with .osm or .osm.pbf extensions, which can be obtained from</p> <ul> <li>http://download.geofabrik.de/ for well-defined regions/countries</li> <li>through JOSM for small subsets and saved to the aforementioned extensions</li> </ul> In\u00a0[2]: Copied! <pre>n = read_osm(\n    \"example_data/example.osm\",\n    importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"slim_config.yml\",\n    num_processes=2,\n    epsg=\"epsg:27700\",\n)\n</pre> n = read_osm(     \"example_data/example.osm\",     importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"slim_config.yml\",     num_processes=2,     epsg=\"epsg:27700\", ) <pre>2022-07-14 15:27:55,774 - Building OSM graph from file example_data/example.osm\n2022-07-14 15:27:56,540 - Creating networkx graph from OSM data\n2022-07-14 15:27:56,541 - OSM: Extract Nodes and Paths from OSM data\n2022-07-14 15:27:56,898 - OSM: Add each OSM way (aka, path) to the OSM graph\n2022-07-14 15:27:56,899 - 1 or 2 batches of size 64 ish\n2022-07-14 15:27:56,925 - Created OSM edges\n2022-07-14 15:27:56,943 - 1 or 2 batches of size 4348 ish\n2022-07-14 15:27:58,563 - Added 8695 nodes\n2022-07-14 15:27:58,566 - 2 or 3 batches of size 401 ish\n2022-07-14 15:28:03,352 - Generated 802 link ids.\n2022-07-14 15:28:03,577 - Added 802 links\n2022-07-14 15:28:03,579 - Deleting isolated nodes which have no edges.\n2022-07-14 15:28:03,989 - Removed 8132 nodes.\n</pre> In\u00a0[3]: Copied! <pre>n.print()\n</pre> n.print() <pre>Graph info: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 563\nNumber of edges: 802\nAverage in degree:   1.4245\nAverage out degree:   1.4245 \nSchedule info: Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0\n</pre> In\u00a0[4]: Copied! <pre># n.plot()\n</pre> # n.plot() In\u00a0[5]: Copied! <pre>n.node_attribute_summary(data=False)\n</pre> n.node_attribute_summary(data=False) <pre>attribute\n\u251c\u2500\u2500 id\n\u251c\u2500\u2500 x\n\u251c\u2500\u2500 y\n\u251c\u2500\u2500 lat\n\u251c\u2500\u2500 lon\n\u2514\u2500\u2500 s2_id\n</pre> In\u00a0[6]: Copied! <pre>n.link_attribute_summary(data=False)\n</pre> n.link_attribute_summary(data=False) <pre>attribute\n\u251c\u2500\u2500 permlanes\n\u251c\u2500\u2500 freespeed\n\u251c\u2500\u2500 capacity\n\u251c\u2500\u2500 oneway\n\u251c\u2500\u2500 modes\n\u251c\u2500\u2500 from\n\u251c\u2500\u2500 to\n\u251c\u2500\u2500 s2_from\n\u251c\u2500\u2500 s2_to\n\u251c\u2500\u2500 length\n\u251c\u2500\u2500 attributes\n\u2502   \u251c\u2500\u2500 osm:way:highway\n\u2502   \u251c\u2500\u2500 osm:way:osmid\n\u2502   \u251c\u2500\u2500 osm:way:lanes\n\u2502   \u251c\u2500\u2500 osm:way:psv\n\u2502   \u251c\u2500\u2500 osm:way:tunnel\n\u2502   \u251c\u2500\u2500 osm:way:railway\n\u2502   \u2514\u2500\u2500 osm:way:access\n\u2514\u2500\u2500 id\n</pre> In\u00a0[7]: Copied! <pre>n.link(\"1\")\n</pre> n.link(\"1\") Out[7]: <pre>{'permlanes': 1.0,\n 'freespeed': 22.22,\n 'capacity': 1500.0,\n 'oneway': '1',\n 'modes': ['bike', 'car', 'walk'],\n 'from': '107319',\n 'to': '2440641461',\n 's2_from': 5221390693512237449,\n 's2_to': 5221390693522407815,\n 'length': 7.300429822404873,\n 'attributes': {'osm:way:highway': 'primary', 'osm:way:osmid': 24865179},\n 'id': '1'}</pre>"},{"location":"examples/2_2_reading_data_osm/#22-reading-data-osm","title":"2.2. Reading data: OSM\u00b6","text":"<p>Reading OSM data can be configured. You will find example config in the configs directory. Available as a jupyter notebook or wiki page.</p>"},{"location":"examples/2_2_reading_data_osm/#setting-up-the-config","title":"Setting up the config\u00b6","text":"<p>OSM data contains wast amount of information, to restrict what is being read, you can adjust the tags for OSM nodes and links that make it through</p> <pre><code>yml\nOSM_TAGS:\n  # tags that are included when reading OSM data\n  USEFUL_TAGS_NODE:\n    - ref\n    - highway\n  USEFUL_TAGS_PATH:\n    - bridge\n    - tunnel\n    - oneway\n    - lanes\n    - highway\n    - service\n    - access\n    - railway\n    - route\n    - lanes\n    - oneway\n    - psv\n    - vehicle\n    - junction\n    - osmid\n</code></pre> <p>GeNet will only read the ways in OSM with tags defined in <code>MODES:  MODE_INDICATORS:</code>---you need to define the mode for specific OSM way tags, GeNet will read only the network edges for which it understands in terms of which mode of transport can move on it. For example in the <code>slim_config.yml</code>:</p> <pre><code>yml\nMODES:\n  MODE_INDICATORS:\n    # These refer to tags stored in OSM, the mode assignment to tags is manual and definitely not exhaustive. \n    # If a tag is not listed here, it will not be read into the network. This is where you should define how dense\n    # you want your network to be.\n    highway:\n      motorway:\n        - car\n      motorway_link:\n        - car\n      trunk:\n        - car\n      trunk_link:\n        - car\n      primary:\n        - car\n        - walk\n        - bike\n      primary_link:\n        - car\n        - walk\n        - bike\n      secondary:\n        - car\n        - walk\n        - bike\n      secondary_link:\n        - car\n        - walk\n        - bike\n      tertiary:\n        - car\n        - walk\n        - bike\n      tertiary_link:\n        - car\n        - walk\n        - bike\n      unclassified:\n        - car\n        - walk\n        - bike\n</code></pre> <p>GeNet has pre-defined default capacity and speed values for a number of OSM tags. These can be found in genet/outputs_handler/matsim_xml_values.py. In the config for reading OSM, you can decide which tag a particular mode should default to if values for it do not exist.</p> <pre><code>yml\n  DEFAULT_OSM_TAG_VALUE:\n  # GeNet will first look at OSM tags to infer the matsim values the link should have. For the types and values head over to \n  # outputs_handler/matsim_xml_values.py.\n    car: secondary\n    bus: secondary\n    rail: railway\n    subway: railway\n    bike: living_street\n    walk: pedestrian\n</code></pre> <p>There are currently two caveats:</p> <ul> <li>The number of lanes in a link, i.e. <code>permlanes</code> is taken from OSM data if present (and read by config under <code>OSM_TAGS: USEFUL_TAGS_PATH</code> and <code>OSM_TAGS: PUMA_GRAPH_TAGS</code>) and integer convertible (e.g. not <code>'2;3'</code>)</li> <li><code>capacity</code> given in <code>matsim_xml_values.py</code> is for a single lane, the output network will feature a <code>capacity</code> value which is the result of <code>permlanes * capacity</code>, where the latter <code>capacity</code> is the base lane capacity defined in <code>matsim_xml_values.py</code></li> </ul>"},{"location":"examples/2_2_reading_data_osm/#reading-osm","title":"Reading OSM\u00b6","text":"<p>GeNet ingests OSM data with .osm or .osm.pbf extensions, which can be obtained from</p> <ul> <li>http://download.geofabrik.de/ for well-defined regions/countries</li> <li>through JOSM for small subsets and saved to the aforementioned extensions</li> </ul> <p>GeNet creates a Multi Directed Graph from OSM data, meaning that there can be more than one edge between the same pair of nodes directed from <code>origin_node</code> to <code>destination_node</code>, if that is the case within the OSM file.</p>"},{"location":"examples/2_2_reading_data_osm/#remark","title":"Remark:\u00b6","text":"<p>A graph generated from OSM is most likely not strongly connected which is something that MATSim expects for the mode <code>car</code> and if using <code>multimodal.contrib</code> also for modes <code>walk</code> and <code>bike</code>.</p>"},{"location":"examples/2_3_reading_data_gtfs/","title":"2.3. Reading data: GTFS","text":"In\u00a0[1]: Copied! <pre>from genet import read_gtfs\n</pre> from genet import read_gtfs <p>We initiate an empty <code>Schedule</code></p> In\u00a0[2]: Copied! <pre>s = read_gtfs(\"example_data/example_gtfs\", \"20190603\")\n</pre> s = read_gtfs(\"example_data/example_gtfs\", \"20190603\") <pre>2022-07-14 15:27:50,737 - Reading GTFS from example_data/example_gtfs\n2022-07-14 15:27:50,740 - Reading the calendar for GTFS\n2022-07-14 15:27:50,743 - Reading GTFS data into usable format\n2022-07-14 15:27:50,745 - Reading stop times\n2022-07-14 15:27:50,784 - Reading trips\n2022-07-14 15:27:50,810 - Reading stops\n2022-07-14 15:27:50,823 - Reading routes\n</pre> <p>GTFS is assumed to be in <code>epsg:4326</code>, you need to project the Schedule to projection you require.</p> In\u00a0[3]: Copied! <pre>s.reproject(\"epsg:27700\")\n</pre> s.reproject(\"epsg:27700\") In\u00a0[4]: Copied! <pre>s.print()\n</pre> s.print() <pre>Schedule:\nNumber of services: 2\nNumber of routes: 2\nNumber of stops: 4\n</pre> In\u00a0[5]: Copied! <pre># s.plot()\n</pre> # s.plot()"},{"location":"examples/2_3_reading_data_gtfs/#23-reading-data-gtfs","title":"2.3. Reading data: GTFS\u00b6","text":"<p>This page goes through methods for reading in GTFS (General Transit Feed Specification). Here is the reference page for the schema of GTFS data.</p> <p>GeNet ingests zipped or unzipped GTFS feeds. The following files are required in the unzipped folder, or inside the zip file:</p> <ul> <li><code>calendar.txt</code></li> <li><code>stop_times.txt</code></li> <li><code>stops.txt</code></li> <li><code>trips.txt</code></li> <li><code>routes.txt</code></li> </ul> <p>When reading a GTFS feed, GeNet expects a date in <code>YYYYMMDD</code> format. It will raise an error if the selected date yields no services.</p> <p>GeNet does support extraction of services/routes/stops in the output <code>genet.Schedule</code> object based on a geographical area (Methods: <code>services_on_spatial_condition</code>, <code>routes_on_spatial_condition</code>, <code>stops_on_spatial_condition</code>, more information in notebook on using genet Network), but you might like to use gtfs-lib prior to ingestion in GeNet.</p> <p>The user assumes responsibility for the quality of their input GTFS feed. There are various validation tools that can be used with GTFS feeds before using with GeNet, see this page for a summary of validation tools.</p>"},{"location":"examples/2_4_reading_data_csv/","title":"2.4. Reading data: CSV","text":"In\u00a0[1]: Copied! <pre>csv_nodes = \"example_data/example_csv/nodes.csv\"\ncsv_links = \"example_data/example_csv/links.csv\"\n</pre> csv_nodes = \"example_data/example_csv/nodes.csv\" csv_links = \"example_data/example_csv/links.csv\" In\u00a0[2]: Copied! <pre>from genet import read_csv\n\nn = read_csv(csv_nodes, csv_links, epsg=\"epsg:27700\")\n</pre> from genet import read_csv  n = read_csv(csv_nodes, csv_links, epsg=\"epsg:27700\") <pre>2022-07-14 15:30:48,943 - Reading nodes from example_data/example_csv/nodes.csv\n2022-07-14 15:30:48,949 - Reading links from example_data/example_csv/nodes.csv\n2022-07-14 15:30:49,024 - Added 4 nodes\n2022-07-14 15:30:49,034 - Added 2 links\n</pre> In\u00a0[3]: Copied! <pre>n.print()\n</pre> n.print() <pre>Graph info: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 4\nNumber of edges: 2\nAverage in degree:   0.5000\nAverage out degree:   0.5000 \nSchedule info: Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0\n</pre> <p>For reading <code>Schedule</code> from csv inputs, head over to Section/Notebook 2.3. Reading GTFS data</p>"},{"location":"examples/2_4_reading_data_csv/#24-reading-data-csv","title":"2.4. Reading data: CSV\u00b6","text":"<p>Available as a jupyter notebook or wiki page.</p> <p>You can read a network from node and link CSV files. For it to be a valid MATSim network, the CSVs need to have the following data columns:</p> <p>Nodes:</p> <ul> <li>id - unique ID for the Node</li> <li>x - x spatial coordinate in a given projection</li> <li>y - y spatial coordinate in a given projection</li> </ul> <p>Links:</p> <ul> <li>id - unique ID for the Link</li> <li>from - source Node ID</li> <li>to - target Node ID</li> <li>length - link length in metres</li> <li>freespeed - meter/seconds speed</li> <li>capacity - vehicles/hour</li> <li>permlanes - number of lanes</li> <li>modes - set of modes</li> </ul> <p>Following the MATSim network schema. As well as be strongly connected for modes available to agents. Check out Section/Notebook 6.1. Validating Network - MATSim Specific for more details about validating Network.</p>"},{"location":"examples/2_5_reading_data_json_geojson/","title":"2.5. Reading data: JSON &amp; GeoJSON","text":"In\u00a0[1]: Copied! <pre>from genet import read_json, read_json_network, read_json_schedule\n</pre> from genet import read_json, read_json_network, read_json_schedule In\u00a0[2]: Copied! <pre>n = read_json_network(\"example_data/example_json/network.json\", \"epsg:27700\")\n</pre> n = read_json_network(\"example_data/example_json/network.json\", \"epsg:27700\") <pre>2022-07-14 15:31:04,968 - Reading Network from example_data/example_json/network.json\n2022-07-14 15:31:05,058 - Added 4 nodes\n2022-07-14 15:31:05,067 - Added 2 links\n</pre> <p>The JSON Schedule should follow this format:</p> <pre>{\n  \"schedule\": {\n    \"stops\": {\n      \"unique_stop_ID\": {\n        \"id\": \"unique_stop_ID\",\n        \"name\": \"Stop Name\", (optional but useful)\n        \"x\": y_spatial_coordinate,\n        \"y\": x_spatial_coordinate,\n        \"linkRefId\": \"netowrk_link_ID\", (reference to a link in the network graph)\n      }\n    },\n    \"services\": {\n      \"unique_service_ID\": {\n        \"id\": \"unique_service_ID\",\n        \"name\": \"N55\", (optional but useful)\n        \"routes\": {\n          \"unique_route_ID\": {\n            \"id\": \"unique_route_ID\",\n            \"route_short_name\": \"N55\", (optional but useful)\n            \"mode\": \"bus\", (PT mode)\n            \"trips\": {\n              \"trip_id\": [\n                \"unique_trip_ID\"\n              ],\n              \"trip_departure_time\": [\n                \"HH:MM:SS\" (departure time for the trip)\n              ],\n              \"vehicle_id\": [\n                \"unique_vehicle_ID\"\n              ]\n            },\n            \"arrival_offsets\": [ (arrival offsets from trip departure time for each stop in route)\n              \"00:00:00\",\n              \"00:02:20\"\n            ],\n            \"departure_offsets\": [ (departure offsets from trip departure time for each stop in route)\n              \"00:00:00\",\n              \"00:02:20\"\n            ],\n            \"route_long_name\": \"\", (optional but useful)\n            \"route\": [ (network route for the route)\n              \"1\",\n              \"10\"\n            ],\n            \"ordered_stops\": [\n              \"unique_stop_ID_1\",\n              \"unique_stop_ID_2\"\n            ]\n          }\n        }\n      }\n    },\n    \"minimal_transfer_times\": {\n      \"unique_stop_ID_1\": {\n        \"stop\": \"unique_stop_ID_2\",\n        \"transferTime\": 100.0\n      },\n      \"unique_stop_ID_2\": {\n        \"stop\": \"unique_stop_ID_1\",\n        \"transferTime\": 100.0\n      }\n    }\n  },\n  \"vehicles\": {\n    \"vehicle_types\": {\n      \"bus\": {\n        \"capacity\": {\n          \"seats\": {\n            \"persons\": \"70\"\n          },\n          \"standingRoom\": {\n            \"persons\": \"0\"\n          }\n        },\n        \"length\": {\n          \"meter\": \"18.0\"\n        },\n        \"width\": {\n          \"meter\": \"2.5\"\n        },\n        \"accessTime\": {\n          \"secondsPerPerson\": \"0.5\"\n        },\n        \"egressTime\": {\n          \"secondsPerPerson\": \"0.5\"\n        },\n        \"doorOperation\": {\n          \"mode\": \"serial\"\n        },\n        \"passengerCarEquivalents\": {\n          \"pce\": \"2.8\"\n        }\n      }\n    },\n    \"vehicles\": {\n      \"veh_0_bus\": {\n        \"type\": \"bus\"\n      }\n    }\n  }\n}\n</pre> <p>the references to the network: <code>linkRefId</code> and <code>route</code> can be left out. That network will not work with MATSim. GeNet can snap and route PT services and fill in those blanks, though not at scale.</p> In\u00a0[3]: Copied! <pre>s = read_json_schedule(\"example_data/example_json/schedule.json\", \"epsg:27700\")\n</pre> s = read_json_schedule(\"example_data/example_json/schedule.json\", \"epsg:27700\") <pre>2022-07-14 15:31:05,075 - Reading Schedule from example_data/example_json/schedule.json\n</pre> <p>If you have both json inputs for a network you can also read both the network json and schedule json at the same time.</p> In\u00a0[4]: Copied! <pre>n = read_json(\n    network_path=\"example_data/example_json/network.json\",\n    schedule_path=\"example_data/example_json/schedule.json\",\n    epsg=\"epsg:27700\",\n)\n</pre> n = read_json(     network_path=\"example_data/example_json/network.json\",     schedule_path=\"example_data/example_json/schedule.json\",     epsg=\"epsg:27700\", ) <pre>2022-07-14 15:31:05,119 - Reading Network from example_data/example_json/network.json\n2022-07-14 15:31:05,281 - Added 4 nodes\n2022-07-14 15:31:05,354 - Added 2 links\n2022-07-14 15:31:05,360 - Reading Schedule from example_data/example_json/schedule.json\n</pre> <p>Given GeoJson, you can create a Network graph. Two files are expected, one for nodes and one for links.</p> <p>The nodes should follow this format:</p> <pre><code>geojson\n{\n\"type\": \"FeatureCollection\",\n\"crs\": { \"type\": \"name\", \"properties\": { \"name\": \"urn:ogc:def:crs:EPSG::27700\" } },\n\"features\": [\n{ \"type\": \"Feature\", \"properties\": {\"id\": \"25508485\", \"x\": 528489.467895946, \"y\": 182206.20303669578, \"lon\": -0.14930198709481451, \"lat\": 51.524162533239284, \"s2_id\": 5221390301001263407 }, \"geometry\": { \"type\": \"Point\", \"coordinates\": [ 528489.467895945999771, 182206.203036695776973 ] } }\n]\n}\n</code></pre> <p>And the links should follow this format:</p> <pre><code>geojson\n{\n\"type\": \"FeatureCollection\",\n\"crs\": { \"type\": \"name\", \"properties\": { \"name\": \"urn:ogc:def:crs:EPSG::27700\" } },\n\"features\": [\n{ \"type\": \"Feature\", \"properties\": {\"id\": \"1\", \"from\": \"25508485\", \"to\": \"21667818\", \"freespeed\": 4.166666666666667, \"capacity\": 600.0, \"permlanes\": 1.0, \"oneway\": \"1\", \"modes\": \"car\", \"s2_from\": 5221390301001263407, \"s2_to\": 5221390302696205321, \"attributes\": { \"osm:way:access\": { \"name\": \"osm:way:access\", \"class\": \"java.lang.String\", \"text\": \"permissive\" }, \"osm:way:highway\": { \"name\": \"osm:way:highway\", \"class\": \"java.lang.String\", \"text\": \"unclassified\" }, \"osm:way:id\": \"26997928\" }, \n\"osm:way:name\": { \"name\": \"osm:way:name\", \"class\": \"java.lang.String\", \"text\": \"Brunswick Place\" } }, \"length\": 52.765151087870265 }, \"geometry\": { \"type\": \"LineString\", \"coordinates\": [ [ 528489.467895945999771, 182206.203036695776973 ], [ 528504.134284314350225, 182155.743513659806922 ] ] } }\n]\n}\n</code></pre> <p>Note that additional, nested attributes can take a long form:</p> <pre><code>\"osm:way:name\": { \"name\": \"osm:way:name\", \"class\": \"java.lang.String\", \"text\": \"Brunswick Place\" }\n</code></pre> <p>or a simple form that assumed data types:</p> <pre><code>\"osm:way:name\": \"Brunswick Place\" \n</code></pre> In\u00a0[5]: Copied! <pre>from genet import read_geojson_network\n\nn = read_geojson_network(\n    \"example_data/example_geojson/network_nodes.geojson\",\n    \"example_data/example_geojson/network_links.geojson\",\n    \"epsg:27700\",\n)\n</pre> from genet import read_geojson_network  n = read_geojson_network(     \"example_data/example_geojson/network_nodes.geojson\",     \"example_data/example_geojson/network_links.geojson\",     \"epsg:27700\", ) <pre>2022-07-14 15:31:05,419 - Reading Network nodes from example_data/example_geojson/network_nodes.geojson\n2022-07-14 15:31:05,520 - Reading Network links from example_data/example_geojson/network_links.geojson\n2022-07-14 15:31:05,613 - Added 4 nodes\n2022-07-14 15:31:05,622 - Added 2 links\n</pre> <p>The GeoJSONs carry a projection for their geometry. The epsg passed in the method above is for the Network, the links will inherit the geometry stored in the geojson but project it (if not already in the correct projection) to match the Network's projection</p>"},{"location":"examples/2_5_reading_data_json_geojson/#25-reading-data-json-geojson","title":"2.5. Reading data: JSON &amp; GeoJSON\u00b6","text":"<p>Available as a jupyter notebook or wiki page.</p> <p>GeNet lets you read JSON data into a Networn graph and PT Schedule, or GeoJSON into Network Graph.</p> <p>For JSON inputs the network JSON file should follow this format:</p> <pre>{\n  \"nodes\": {\n    \"unique_node_ID\": {\n      \"id\": \"unique_node_ID\",\n      \"y\": y_spatial_coordinate,\n      \"x\": x_spatial_coordinate\n    }\n  },\n  \"links\": {\n    \"unique_link_ID\": {\n      \"id\": \"unique_link_ID\",\n      \"from\": \"unique_source_node_ID\",\n      \"to\": \"unique_target_node_ID\",\n      \"freespeed\": 4.166666666666667,\n      \"permlanes\": 1,\n      \"modes\": \"car,bus,walk\",\n      \"geometry\": \"kevj`maB_`la`}`@{ooxA`k~rH\", (encoded polyline, otherwise assumed to be straight line between source and target node)\n      \"length\": 52.765151087870265,\n      \"capacity\": 600.0\n      \"attributes\": {  # (optional MATSim link attributes)\n        \"osm:way:access\": {\n          \"name\": \"osm:way:access\",\n          \"class\": \"java.lang.String\",\n          \"text\": \"permissive\"\n        },\n        \"osm:way:id\": { # simple form that assumes the java type\n          \"OSM_ID\"\n        },\n      },\n    }\n  }\n}\n</pre>"},{"location":"examples/3_1_writing_data_matsim/","title":"3.1. Writing data: MATSim","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\npath_to_output = \"example_data/outputs/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> import os  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\" path_to_output = \"example_data/outputs/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> <p>To write the network into matsim format, use <code>write_to_matsim</code></p> In\u00a0[2]: Copied! <pre>n.write_to_matsim(path_to_output)\n</pre> n.write_to_matsim(path_to_output) <pre>2022-07-14 15:31:43,952 - Writing example_data/pt2matsim_network/genet_output/network.xml\n2022-07-14 15:31:44,529 - Writing example_data/pt2matsim_network/genet_output/schedule.xml\n2022-07-14 15:31:44,570 - Writing example_data/pt2matsim_network/genet_output/vehicles.xml\n</pre> <p>Note that saving your network to MATSim format will only include the attributes included in the MATSim network schema. All other attributes will not be saved to this format, but you may be interested in also saving your network to CSV, or (Geo/)JSON formats.</p>"},{"location":"examples/3_1_writing_data_matsim/#31-writing-data-matsim","title":"3.1. Writing data: MATSim\u00b6","text":"<p>This page goes through the MATSim files that can be generated with GeNet. Available as a jupyter notebook or wiki page.</p>"},{"location":"examples/3_1_writing_data_matsim/#supported-output-files","title":"Supported output files\u00b6","text":"<p>GeNet currently supports writing the following MATSim network files:</p> <ul> <li><p><code>network.xml</code> with the following network v2 dtd schema</p> <p>Data present on the nodes and edges of the graph will only persist to the <code>network.xml</code> file if it matches the required or optional attributes defined in the /variables.py, or is saved in a nested dictionary under <code>attributes</code> for network links in the following format: <code>'attributes': {'attribute_name' : {'name': 'attribute_name', 'class': 'java.lang.String', 'text': 'attribute_value'}}</code>.</p> </li> <li><p><code>schedule.xml</code> with the following schedule v2 dtd schema</p> <p>Similarly to the network, in the case any data is added to the <code>genet.Schedule</code> object's graph, only the allowed attributes for stops (graph nodes) defined in /variables.py will persist to the <code>schedule.xml</code> file.</p> </li> <li><p><code>vehicles.xml</code> with the following vehicles v1 dtd schema</p> <p>GeNet will generate a <code>vehicle.xml</code> file using <code>vehicles</code> and <code>vehicle_types</code> attributes of the <code>Schedule</code> object. These are based on vehicle_definitions.yml by default but can be customised at the time of creating the Schedule or by accessing/modifying those attributes of the object directly.</p> </li> <li><p><code>roadpricing-file.xml</code> with the following roadpricing v1 dtd schema</p> <p>How to generate data for this file is described in: Usage: 4. Using Network</p> </li> </ul> <p>Let's read in a sample MATSim network into GeNet's <code>Network</code> object.</p>"},{"location":"examples/3_2_writing_data_gtfs/","title":"3.2. Writing data: GTFS","text":"In\u00a0[1]: Copied! <pre>from genet import read_gtfs\n\ns = read_gtfs(\"example_data/example_gtfs\", \"20190603\")\ns\n</pre> from genet import read_gtfs  s = read_gtfs(\"example_data/example_gtfs\", \"20190603\") s <pre>2022-07-14 15:32:40,982 - Reading GTFS from example_data/example_gtfs\n2022-07-14 15:32:40,983 - Reading the calendar for GTFS\n2022-07-14 15:32:40,988 - Reading GTFS data into usable format\n2022-07-14 15:32:40,989 - Reading stop times\n2022-07-14 15:32:40,997 - Reading trips\n2022-07-14 15:32:41,003 - Reading stops\n2022-07-14 15:32:41,007 - Reading routes\n</pre> Out[1]: <pre>&lt;Schedule instance at 140268498459024: with 2 services&gt;</pre> <p>You can export <code>Schedule</code> straight to files:</p> In\u00a0[2]: Copied! <pre>s.write_to_csv(\"example_data/outputs/gtfs\", \"20190603\")\n</pre> s.write_to_csv(\"example_data/outputs/gtfs\", \"20190603\") <pre>2022-07-14 15:32:41,111 - Saving Schedule to GTFS csv in example_data/output_gtfs\n2022-07-14 15:32:41,200 - Saving example_data/output_gtfs/stops.csv\n2022-07-14 15:32:41,212 - Saving example_data/output_gtfs/routes.csv\n2022-07-14 15:32:41,218 - Saving example_data/output_gtfs/trips.csv\n2022-07-14 15:32:41,221 - Saving example_data/output_gtfs/stop_times.csv\n2022-07-14 15:32:41,227 - Saving example_data/output_gtfs/calendar.csv\n</pre> In\u00a0[3]: Copied! <pre>s.write_to_gtfs(\"example_data/outputs/gtfs\", \"20190603\")\n</pre> s.write_to_gtfs(\"example_data/outputs/gtfs\", \"20190603\") <pre>2022-07-14 15:32:41,242 - Saving Schedule to GTFS txt in example_data/output_gtfs\n2022-07-14 15:32:41,303 - Saving example_data/output_gtfs/stops.txt\n2022-07-14 15:32:41,305 - Saving example_data/output_gtfs/routes.txt\n2022-07-14 15:32:41,308 - Saving example_data/output_gtfs/trips.txt\n2022-07-14 15:32:41,311 - Saving example_data/output_gtfs/stop_times.txt\n2022-07-14 15:32:41,313 - Saving example_data/output_gtfs/calendar.txt\n</pre> <p>Or generate <code>pandas.DataFrame</code> GTFS tables:</p> In\u00a0[4]: Copied! <pre>gtfs = s.to_gtfs(\"20190603\")\n</pre> gtfs = s.to_gtfs(\"20190603\") In\u00a0[5]: Copied! <pre>gtfs.keys()\n</pre> gtfs.keys() Out[5]: <pre>dict_keys(['stops', 'routes', 'trips', 'stop_times', 'calendar'])</pre> In\u00a0[6]: Copied! <pre>gtfs[\"stops\"].head()\n</pre> gtfs[\"stops\"].head() Out[6]: stop_id stop_name stop_lat stop_lon stop_code stop_desc zone_id stop_url location_type parent_station stop_timezone wheelchair_boarding level_id platform_code BSE BSE Bus Stop snap to edge 51.522686 -0.141362 NaN NaN NaN NaN 0.0 210G433 NaN NaN NaN NaN RSE RSE Rail Stop snap to edge 51.519261 -0.142159 NaN NaN NaN NaN 0.0 210G431 NaN NaN NaN NaN RSN RSN Rail Stop snap to node 51.523134 -0.141095 NaN NaN NaN NaN 0.0 210G430 NaN NaN NaN NaN BSN BSN Bus Stop snap to node 51.521620 -0.140053 NaN NaN NaN NaN 0.0 210G432 NaN NaN NaN NaN"},{"location":"examples/3_2_writing_data_gtfs/#32-writing-data-gtfs","title":"3.2. Writing data: GTFS\u00b6","text":"<p>Available as a jupyter notebook or wiki page.</p> <p>GeNet can generate CSV or text files in GTFS-like format based on a <code>Schedule</code> object. It will return the following file</p> <ul> <li><code>calendar.txt</code></li> <li><code>stop_times.txt</code></li> <li><code>stops.txt</code></li> <li><code>trips.txt</code></li> <li><code>routes.txt</code> (or .csv depending on the method used)</li> </ul> <p>When reading a GTFS feed, GeNet expects a date in <code>YYYYMMDD</code> format. It does not retain this information. You are required to pass this GTFS day when exporting to GTFS. <code>Schedule</code> object does not contain a lot of the optional GTFS data  point (a lot more is retained if the Schedule was created through GeNet). In particular, if using MATSim files as input, your Schedule will mostly contain only the required fields. Other important remarks:</p> <ul> <li>list of network link IDs associated with the transit routes as the path and the relation of stops to network link IDs is not exported.</li> <li><code>agency.txt</code> is not generated</li> <li><code>service_id</code> is generated from Service objects. If the Schedule object is generated from GTFS through GeNet, those service IDs are based off of the <code>route_id</code> field in GTFS. This means the two fields in output GTFS are the same. The transit route split of services (based on ordered chain of stops) is lost when exporting to GTFS.</li> <li>you can pass you own <code>mode_to_route_type</code> dictionary that will map modes in the Schedule to the <code>route_type</code> codes you want. Otherwise it will default to</li> </ul> <pre><code>{\n    \"tram\": 0, \"subway\": 1, \"rail\": 2, \"bus\": 3, \"ferry\": 4, \"cablecar\": 5, \"gondola\": 6, \"funicular\": 7\n}\n</code></pre> <p>based on this. Caveat - if you have read Schedule from GTFS, the <code>route_type</code> codes are retained and will not be changed.</p> <p>Here is the reference page for the schema of GTFS data.</p>"},{"location":"examples/3_3_writing_data_csv/","title":"3.3. Writing data: CSV","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> import os  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> <p>You can export the <code>genet.Network</code> and the <code>Schedule</code> (if applicable) to CSV.</p> In\u00a0[2]: Copied! <pre>n.write_to_csv(\"example_data/outputs/csv\")\n</pre> n.write_to_csv(\"example_data/outputs/csv\") <pre>2022-07-14 15:34:30,652 - Saving Network to CSV in example_data/output_csv/network\n2022-07-14 15:34:30,746 - Saving Schedule to GTFS csv in example_data/output_csv/schedule\n2022-07-14 15:34:30,990 - Saving example_data/output_csv/schedule/stops.csv\n2022-07-14 15:34:30,994 - Saving example_data/output_csv/schedule/routes.csv\n2022-07-14 15:34:30,996 - Saving example_data/output_csv/schedule/trips.csv\n2022-07-14 15:34:31,006 - Saving example_data/output_csv/schedule/stop_times.csv\n2022-07-14 15:34:31,039 - Saving example_data/output_csv/schedule/calendar.csv\n</pre> <p>The node and link CSVs describing the network will include any and all data stored as attributes on the graph---in contrast to the MATSim output which will only include attributes included in the MATSim network schema.</p> <p>For <code>Schedule</code> the outputs are saved to GTFS CSV files.  Some data is lost when saving Schedule to GTFS, for example the relationship and paths between network and schedule. The details of this schema and what is lost can be found in Section/Notebook 3.3 Writing GTFS data.</p>"},{"location":"examples/3_3_writing_data_csv/#33-writing-data-csv","title":"3.3. Writing data: CSV\u00b6","text":"<p>Available as a jupyter notebook or wiki page.</p> <p>Let's read in a sample MATSim network into GeNet's <code>Network</code> object.</p>"},{"location":"examples/3_4_writing_data_json_geojson/","title":"3.4. Writing data: JSON &amp; GeoJSON","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> import os  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> <p>You can write the Network and it's Schedule (if applicable) to JSON:</p> In\u00a0[2]: Copied! <pre>n.write_to_json(\"example_data/outputs/json\")\n</pre> n.write_to_json(\"example_data/outputs/json\") <pre>2022-07-14 15:38:02,012 - Saving Network to JSON in example_data/output_json\n2022-07-14 15:38:03,912 - Saving Schedule to JSON in example_data/output_json\n</pre> <p>Writing the Network to JSON preserves all of the Network data - unlike writing the Network to CSV or MATSim format. For limitations of those formats head over to Sections/Notebooks:</p> <ul> <li>Writing CSV data</li> <li>Writing MATSim data</li> </ul> <p>You can also choose to write the network to GeoJSON, GeoParquet or as a shapefile. This will produce spatial representation of the Network graph and the Schedule graph.</p> <ul> <li>The main difference for the Network graph outputs is that the link geometry is a <code>LINESTRING</code>, whereas in the JSON outputs, this geometry is an encoded polyline.</li> <li>The biggest difference is for the Schedule graph. With JSON output you get the entire Schedule data saved to file. With GeoJSON you get only the spatial representation of the graph, nodes and edges, where nodes are the Stops in the Schedule and edges are the connections between Stops as defined by the Route and Service objects which use those Stops.  It does not include any information about the vehicles, their IDs or modes, vehicle definitions or network routes (the edges are straight lines between the Stops)</li> </ul> In\u00a0[3]: Copied! <pre>n.write_spatial(\"example_data/outputs/geojson\", filetype=\"geojson\")\n</pre> n.write_spatial(\"example_data/outputs/geojson\", filetype=\"geojson\") <pre>2022-07-14 15:38:05,560 - Saving Network to GeoJSON in example_data/output_geojson\n2022-07-14 15:38:06,974 - Saving Schedule to GeoJSON in example_data/output_geojson\n</pre>"},{"location":"examples/3_4_writing_data_json_geojson/#34-writing-data-json-geojson","title":"3.4. Writing data: JSON &amp; GeoJSON\u00b6","text":"<p>Available as a jupyter notebook or wiki page.</p>"},{"location":"examples/4_1_using_network_accessing_data/","title":"4.1. Using the object: Accessing data","text":"In\u00a0[1]: Copied! <pre>import os\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# # you don't need to read the vehicles file, but doing so ensures all vehicles\n# # in the schedule are of the expected type and the definition of the vehicle\n# # is preserved\n\nn.print()\n</pre> import os  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # # you don't need to read the vehicles file, but doing so ensures all vehicles # # in the schedule are of the expected type and the definition of the vehicle # # is preserved  n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> In\u00a0[2]: Copied! <pre>n.summary_report()\n</pre> n.summary_report() <pre>2022-08-25 14:51:20,883 - Creating a summary report\n</pre> Out[2]: <pre>{'network': {'network_graph_info': {'Number of network links': 1662,\n   'Number of network nodes': 3166},\n  'modes': {'Modes on network links': {'artificial', 'bus', 'car', 'pt'},\n   'Number of links by mode': {'artificial': 3,\n    'car': 3161,\n    'pt': 153,\n    'bus': 182}},\n  'osm_highway_tags': {'Number of links by tag': {'living_street': 7,\n    'tertiary_link': 2,\n    'trunk': 213,\n    'unclassified': 1027,\n    'tertiary': 326,\n    'residential': 758,\n    'secondary_link': 2,\n    'primary_link': 5,\n    'service': 2,\n    'primary': 619,\n    'secondary': 185,\n    'trunk_link': 17}}},\n 'schedule': {'schedule_info': {'Number of services': 9,\n   'Number of routes': 68,\n   'Number of stops': 118},\n  'modes': {'Modes in schedule': {'bus'},\n   'Services by mode': {'bus': 9},\n   'PT stops by mode': {'bus': 45}},\n  'accessibility_tags': {'Stops with tag bikeAccessible': 0,\n   'Unique values for bikeAccessible tag': set(),\n   'Stops with tag carAccessible': 0,\n   'Unique values for carAccessible tag': set()}}}</pre> <p>The data saved on the edges or nodes of the graph can be nested. There are a couple of convenient methods that summarise the schema of the data found on the nodes and links. If <code>data=True</code>, the output also shows up to 5 unique values stored in that location.</p> In\u00a0[3]: Copied! <pre>n.node_attribute_summary(data=True)\n</pre> n.node_attribute_summary(data=True) <pre>attribute\n\u251c\u2500\u2500 id: ['3085005043', '200047', '852019112', '107824', '14790693']\n\u251c\u2500\u2500 x: [528387.4250512555, 528391.4406755936, 528393.2742107178, 528396.6287644263, 528396.3513181042]\n\u251c\u2500\u2500 y: [181547.5850354673, 181552.72935927223, 181558.10532352765, 181559.970402835, 181562.0370527053]\n\u251c\u2500\u2500 lon: [-0.15178558709839862, -0.135349787087776, -0.122919287085967, -0.13766218709633904, -0.14629008709559344]\n\u251c\u2500\u2500 lat: [51.52643403323907, 51.51609983324067, 51.51595583324104, 51.5182034332405, 51.52410423323943]\n\u2514\u2500\u2500 s2_id: [5221390710015643649, 5221390314367946753, 5221366508477440003, 5221390682291777543, 5221390739236081673]\n</pre> In\u00a0[4]: Copied! <pre>n.link_attribute_summary(data=False)\n</pre> n.link_attribute_summary(data=False) <pre>attribute\n\u251c\u2500\u2500 id\n\u251c\u2500\u2500 from\n\u251c\u2500\u2500 to\n\u251c\u2500\u2500 freespeed\n\u251c\u2500\u2500 capacity\n\u251c\u2500\u2500 permlanes\n\u251c\u2500\u2500 oneway\n\u251c\u2500\u2500 modes\n\u251c\u2500\u2500 s2_from\n\u251c\u2500\u2500 s2_to\n\u251c\u2500\u2500 attributes\n\u2502   \u251c\u2500\u2500 osm:way:access\n\u2502   \u251c\u2500\u2500 osm:way:highway\n\u2502   \u251c\u2500\u2500 osm:way:id\n\u2502   \u251c\u2500\u2500 osm:way:name\n\u2502   \u251c\u2500\u2500 osm:relation:route\n\u2502   \u251c\u2500\u2500 osm:way:lanes\n\u2502   \u251c\u2500\u2500 osm:way:oneway\n\u2502   \u251c\u2500\u2500 osm:way:tunnel\n\u2502   \u251c\u2500\u2500 osm:way:psv\n\u2502   \u251c\u2500\u2500 osm:way:vehicle\n\u2502   \u251c\u2500\u2500 osm:way:traffic_calming\n\u2502   \u251c\u2500\u2500 osm:way:junction\n\u2502   \u2514\u2500\u2500 osm:way:service\n\u2514\u2500\u2500 length\n</pre> <p>Once you see the general schema for the data stored on nodes and links, you may decide to look at or perform analysis on all of the data stored in the netowrk under a particular key. A GeNet network has two methods which generate a <code>pandas.Series</code> object, which stores the nodes or links data present at the specified key, indexed by the same index as the nodes or links.</p> In\u00a0[5]: Copied! <pre>s2_id = n.node_attribute_data_under_key(\"s2_id\")\n</pre> s2_id = n.node_attribute_data_under_key(\"s2_id\") In\u00a0[6]: Copied! <pre>s2_id\n</pre> s2_id Out[6]: <pre>101982       5221390329378179879\n101986       5221390328605860387\n101990       5221390304444511271\n101991       5221390303978897267\n101992       5221390304897644929\n                    ...         \n983839058    5221390693831817171\n99936        5221390297975475113\n99937        5221390299484831045\n99940        5221390294354743413\n99943        5221390298004852605\nLength: 1662, dtype: int64</pre> In\u00a0[7]: Copied! <pre>n.link_attribute_data_under_key(\"freespeed\").head()\n</pre> n.link_attribute_data_under_key(\"freespeed\").head() Out[7]: <pre>1       4.166667\n10      4.166667\n100     4.166667\n1000    4.166667\n1001    4.166667\ndtype: float64</pre> <p>Or you can access nested data,</p> In\u00a0[8]: Copied! <pre>n.link_attribute_data_under_key({\"attributes\": \"osm:way:lanes\"}).head()\n</pre> n.link_attribute_data_under_key({\"attributes\": \"osm:way:lanes\"}).head() Out[8]: <pre>1007    2\n1008    2\n1037    2\n1038    2\n1039    2\ndtype: object</pre> <p>You can also build a <code>pandas.DataFrame</code> out of several keys.</p> In\u00a0[9]: Copied! <pre>n.link_attribute_data_under_keys([\"freespeed\", {\"attributes\": \"osm:way:highway\"}]).head()\n</pre> n.link_attribute_data_under_keys([\"freespeed\", {\"attributes\": \"osm:way:highway\"}]).head() Out[9]: freespeed attributes::osm:way:highway 1 4.166667 unclassified 10 4.166667 unclassified 100 4.166667 unclassified 1000 4.166667 residential 1001 4.166667 residential In\u00a0[11]: Copied! <pre>links = n.extract_links_on_edge_attributes(\n    conditions={\"attributes\": {\"osm:way:highway\": \"primary\"}}\n)\n</pre> links = n.extract_links_on_edge_attributes(     conditions={\"attributes\": {\"osm:way:highway\": \"primary\"}} ) In\u00a0[12]: Copied! <pre>links[:5]\n</pre> links[:5] Out[12]: <pre>['1007', '1008', '1023', '1024', '103']</pre> In\u00a0[13]: Copied! <pre>len(links)\n</pre> len(links) Out[13]: <pre>619</pre> <p>Note, it is possible to set data in long format, specifying the JAVA class of the data stored, i.e.</p> <pre><code>{'id': '1007',\n 'from': '4356572310',\n 'to': '5811263955',\n 'attributes': {'osm:way:highway': {'name': 'osm:way:highway',\n   'class': 'java.lang.String',\n   'text': 'primary'},\n  'osm:way:id': {'name': 'osm:way:id',\n   'class': 'java.lang.Long',\n   'text': '589660342'},\n  'osm:way:lanes': {'name': 'osm:way:highway',\n   'class': 'java.lang.String',\n   'text': 'primary'},\n  'osm:way:name': {'name': 'osm:way:name',\n   'class': 'java.lang.String',\n   'text': 'Shaftesbury Avenue'},\n  'osm:way:oneway': {'name': 'osm:way:oneway',\n   'class': 'java.lang.String',\n   'text': 'yes'}},\n 'length': 13.941905154249884}\n</code></pre> <p>This is useful if you want to force the data to be saved to MATSim XML file with that specific data type.</p> <p>In that case, to find primary highway links, you would instead set the following condition:</p> <pre>links = n.extract_links_on_edge_attributes(\n    conditions= {'attributes': {'osm:way:highway': {'text': 'primary'}}},\n)\n</pre> <p>Below we now require that the link value at <code>data['attributes']['osm:way:highway'] in ['primary', 'something else']</code>. There is nothing in the data that has such tags, so the output is the same.</p> In\u00a0[14]: Copied! <pre>links = n.extract_links_on_edge_attributes(\n    conditions={\"attributes\": {\"osm:way:highway\": [\"primary\", \"something else\"]}}\n)\n</pre> links = n.extract_links_on_edge_attributes(     conditions={\"attributes\": {\"osm:way:highway\": [\"primary\", \"something else\"]}} ) In\u00a0[15]: Copied! <pre>links[:5]\n</pre> links[:5] Out[15]: <pre>['1007', '1008', '1023', '1024', '103']</pre> In\u00a0[16]: Copied! <pre>len(links)\n</pre> len(links) Out[16]: <pre>619</pre> <p>We can also pass a list of conditions. In this case it makes sense for us to specify how multiple conditions should be handled. We can do it via</p> <ul> <li><code>how=all</code> - all conditions need to be met</li> <li><code>how=any</code> - at least one condition needs to be met</li> </ul> <p>It is set to <code>any</code> as default.</p> In\u00a0[17]: Copied! <pre>links = n.extract_links_on_edge_attributes(\n    conditions=[\n        {\"attributes\": {\"osm:way:highway\": \"primary\"}},\n        {\"attributes\": {\"osm:way:highway\": \"something else\"}},\n    ],\n    how=any,\n)\n</pre> links = n.extract_links_on_edge_attributes(     conditions=[         {\"attributes\": {\"osm:way:highway\": \"primary\"}},         {\"attributes\": {\"osm:way:highway\": \"something else\"}},     ],     how=any, ) In\u00a0[18]: Copied! <pre>links[:5]\n</pre> links[:5] Out[18]: <pre>['1007', '1008', '1023', '1024', '103']</pre> In\u00a0[19]: Copied! <pre>len(links)\n</pre> len(links) Out[19]: <pre>619</pre> In\u00a0[20]: Copied! <pre>links = n.extract_links_on_edge_attributes(\n    conditions=[\n        {\"attributes\": {\"osm:way:highway\": \"primary\"}},\n        {\"attributes\": {\"osm:way:highway\": \"something else\"}},\n    ],\n    how=all,\n)\n</pre> links = n.extract_links_on_edge_attributes(     conditions=[         {\"attributes\": {\"osm:way:highway\": \"primary\"}},         {\"attributes\": {\"osm:way:highway\": \"something else\"}},     ],     how=all, ) In\u00a0[21]: Copied! <pre>links[:5]\n</pre> links[:5] Out[21]: <pre>[]</pre> <p>As expected, no links satisfy both <code>data['attributes']['osm:way:highway'] == 'primary'</code> and <code>data['attributes']['osm:way:highway'] == 'something else'</code>.</p> <p>Below, we give an example of subsetting a numeric boundary. We find links where <code>0 &lt;= 'freespeed'  &lt;= 20</code>.</p> In\u00a0[22]: Copied! <pre>links = n.extract_links_on_edge_attributes(conditions={\"freespeed\": (0, 20)})\n</pre> links = n.extract_links_on_edge_attributes(conditions={\"freespeed\": (0, 20)}) In\u00a0[23]: Copied! <pre>links[:5]\n</pre> links[:5] Out[23]: <pre>['1', '10', '100', '1000', '1001']</pre> In\u00a0[24]: Copied! <pre>len(links)\n</pre> len(links) Out[24]: <pre>2334</pre> <p>Finally, we can define a function that will handle the condition for us. The function should take the value expected at the key in the data dictionary and return either <code>True</code> or <code>False</code>.</p> <p>For example, below we give an example equivalent to our first example of <code>data['attributes']['osm:way:highway']['text'] == 'primary'</code> but using a function we defined ourselves to handle the condition.</p> In\u00a0[25]: Copied! <pre>def highway_primary(value):\n    return value == \"primary\"\n\n\nlinks = n.extract_links_on_edge_attributes(\n    conditions={\"attributes\": {\"osm:way:highway\": highway_primary}}\n)\n</pre> def highway_primary(value):     return value == \"primary\"   links = n.extract_links_on_edge_attributes(     conditions={\"attributes\": {\"osm:way:highway\": highway_primary}} ) In\u00a0[26]: Copied! <pre>links[:5]\n</pre> links[:5] Out[26]: <pre>['1007', '1008', '1023', '1024', '103']</pre> In\u00a0[27]: Copied! <pre>len(links)\n</pre> len(links) Out[27]: <pre>619</pre> <p>This allows for really flexible subsetting of the network based on data stored on the edges. Another example, similar to the numeric boundary, but this time we only care about the upper bound and we make it a strict inequality.</p> In\u00a0[28]: Copied! <pre>def below_20(value):\n    return value &lt; 20\n\n\nlinks = n.extract_links_on_edge_attributes(conditions={\"freespeed\": below_20})\n</pre> def below_20(value):     return value &lt; 20   links = n.extract_links_on_edge_attributes(conditions={\"freespeed\": below_20}) In\u00a0[29]: Copied! <pre>links[:5]\n</pre> links[:5] Out[29]: <pre>['1', '10', '100', '1000', '1001']</pre> In\u00a0[30]: Copied! <pre>len(links)\n</pre> len(links) Out[30]: <pre>2334</pre> In\u00a0[31]: Copied! <pre>n.links_on_modal_condition(\"bus\")[:5]\n</pre> n.links_on_modal_condition(\"bus\")[:5] Out[31]: <pre>['1021', '1023', '1024', '1079', '1105']</pre> <p><code>nodes_on_modal_condition</code> will return nodes connected to the links satisfying the modal condition.</p> In\u00a0[32]: Copied! <pre>n.nodes_on_modal_condition([\"car\", \"bus\"])[:5]\n</pre> n.nodes_on_modal_condition([\"car\", \"bus\"])[:5] Out[32]: <pre>['852019112', '107824', '14790693', '21651810', '1166234800']</pre> In\u00a0[33]: Copied! <pre>_ = n.to_geodataframe()\ngdf_nodes, gdf_links = _[\"nodes\"], _[\"links\"]\n</pre> _ = n.to_geodataframe() gdf_nodes, gdf_links = _[\"nodes\"], _[\"links\"] In\u00a0[34]: Copied! <pre>region = \"48761ad71,48761ad723,48761ad724c,48761ad73c,48761ad744,48761ad75d3,48761ad75d5,48761ad765,48761ad767,48761ad76c,48761ad774,48761ad779,48761ad77b,48761ad783,48761ad784c,48761ad7854,48761ad794,48761ad79c,48761ad7a4,48761ad7ac,48761ad7b1,48761ad7bc\"\n_nodes = n.nodes_on_spatial_condition(region)[:5]\nlen(_nodes)\n</pre> region = \"48761ad71,48761ad723,48761ad724c,48761ad73c,48761ad744,48761ad75d3,48761ad75d5,48761ad765,48761ad767,48761ad76c,48761ad774,48761ad779,48761ad77b,48761ad783,48761ad784c,48761ad7854,48761ad794,48761ad79c,48761ad7a4,48761ad7ac,48761ad7b1,48761ad7bc\" _nodes = n.nodes_on_spatial_condition(region)[:5] len(_nodes) Out[34]: <pre>5</pre> In\u00a0[35]: Copied! <pre>gdf_nodes.plot(), gdf_nodes[gdf_nodes[\"id\"].isin(_nodes)].plot()\n</pre> gdf_nodes.plot(), gdf_nodes[gdf_nodes[\"id\"].isin(_nodes)].plot() Out[35]: <pre>(&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd8786c1050&gt;,\n &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd87879d550&gt;)</pre> In\u00a0[36]: Copied! <pre>geojson = \"example_data/Fitzrovia_polygon.geojson\"\n\n# here the area is too small for any routes to be within it\n_links = n.links_on_spatial_condition(geojson, how=\"intersect\")\nlen(_links)\n</pre> geojson = \"example_data/Fitzrovia_polygon.geojson\"  # here the area is too small for any routes to be within it _links = n.links_on_spatial_condition(geojson, how=\"intersect\") len(_links) Out[36]: <pre>270</pre> In\u00a0[37]: Copied! <pre>gdf_links.plot(), gdf_links[gdf_links[\"id\"].isin(_links)].plot()\n</pre> gdf_links.plot(), gdf_links[gdf_links[\"id\"].isin(_links)].plot() Out[37]: <pre>(&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd8781b8490&gt;,\n &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd8790d0cd0&gt;)</pre> In\u00a0[38]: Copied! <pre>from shapely.geometry import Polygon\n\nregion = Polygon(\n    [\n        (-0.1487016677856445, 51.52556684350165),\n        (-0.14063358306884766, 51.5255134425896),\n        (-0.13865947723388672, 51.5228700191647),\n        (-0.14093399047851562, 51.52006622056997),\n        (-0.1492595672607422, 51.51974577545329),\n        (-0.1508045196533203, 51.52276321095246),\n        (-0.1487016677856445, 51.52556684350165),\n    ]\n)\n\n_links = n.links_on_spatial_condition(region, how=\"within\")\nlen(_links)\n</pre> from shapely.geometry import Polygon  region = Polygon(     [         (-0.1487016677856445, 51.52556684350165),         (-0.14063358306884766, 51.5255134425896),         (-0.13865947723388672, 51.5228700191647),         (-0.14093399047851562, 51.52006622056997),         (-0.1492595672607422, 51.51974577545329),         (-0.1508045196533203, 51.52276321095246),         (-0.1487016677856445, 51.52556684350165),     ] )  _links = n.links_on_spatial_condition(region, how=\"within\") len(_links) Out[38]: <pre>227</pre> In\u00a0[39]: Copied! <pre>gdf_links.plot(), gdf_links[gdf_links[\"id\"].isin(_links)].plot()\n</pre> gdf_links.plot(), gdf_links[gdf_links[\"id\"].isin(_links)].plot() Out[39]: <pre>(&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd878005510&gt;,\n &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd8780d5650&gt;)</pre> In\u00a0[40]: Copied! <pre>n.schedule.print()\n</pre> n.schedule.print() <pre>Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> <p>Or we can plot the <code>Schedule</code> object. A <code>Schedule</code> on its' own does not have information about the <code>Network</code>, even if it has refrences to it via network routes in the <code>Route</code> objects. Thus calling a <code>plot</code> method on a Schedule will result in a plot of connections between stops for all <code>Route</code>s within all <code>Service</code>s. To plot the network routes of the <code>Schedule</code> we use the <code>plot</code> method for the <code>Network</code> object which holds that <code>Schedule</code>.</p> In\u00a0[41]: Copied! <pre># n.schedule.plot()\n</pre> # n.schedule.plot() In\u00a0[42]: Copied! <pre>n.schedule.stop_attribute_summary(data=False)\n</pre> n.schedule.stop_attribute_summary(data=False) <pre>attribute\n\u251c\u2500\u2500 services\n\u251c\u2500\u2500 routes\n\u251c\u2500\u2500 id\n\u251c\u2500\u2500 x\n\u251c\u2500\u2500 y\n\u251c\u2500\u2500 epsg\n\u251c\u2500\u2500 name\n\u251c\u2500\u2500 lon\n\u251c\u2500\u2500 lat\n\u251c\u2500\u2500 s2_id\n\u251c\u2500\u2500 linkRefId\n\u251c\u2500\u2500 isBlocking\n\u2514\u2500\u2500 stopAreaId\n</pre> In\u00a0[43]: Copied! <pre>n.schedule.route_attribute_summary(data=True)\n</pre> n.schedule.route_attribute_summary(data=True) <pre>attribute\n\u251c\u2500\u2500 route_short_name: ['N55', 'N5', '113', 'N20', '134']\n\u251c\u2500\u2500 mode: ['bus']\n\u251c\u2500\u2500 arrival_offsets: ['00:01:52', '00:02:18', '00:01:34', '00:03:48', '00:01:10']\n\u251c\u2500\u2500 departure_offsets: ['00:01:52', '00:02:18', '00:01:34', '00:03:48', '00:01:10']\n\u251c\u2500\u2500 route_long_name: ['']\n\u251c\u2500\u2500 id: ['VJea6046f64f85febf1854290fb8f76e921e3ac96b', 'VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc', 'VJ5b511605b1e07428c2e0a7d676d301c6c40dcca6', 'VJ85c23573d670bab5485618b0c5fddff3314efc89', 'VJ28a8a6a4ab02807a4fdfd199e5c2ca0622d34d0c']\n\u251c\u2500\u2500 trips\n\u2502   \u251c\u2500\u2500 trip_id: ['VJcc2e00b98a2837e18c555477c6e44ca2efe332e7_10:49:00', 'VJ0d5c884e960469ac2ced50a704e57d965da26018_17:20:56', 'VJc239057734e457e3ba45979b2d87a019b62742da_20:51:13', 'VJ5c2b1116530ef2e405c69e0bb12dfeaca4c08b24_16:54:00', 'VJe165350c77c2d832b595c5c02cf61a9291d87f88_19:13:00']\n\u2502   \u251c\u2500\u2500 trip_departure_time: ['01:24:00', '22:53:08', '13:59:00', '18:35:00', '16:56:56']\n\u2502   \u2514\u2500\u2500 vehicle_id: ['veh_1757_bus', 'veh_885_bus', 'veh_1919_bus', 'veh_935_bus', 'veh_1935_bus']\n\u251c\u2500\u2500 route: ['87', '485', '1180', '2867', '3155']\n\u251c\u2500\u2500 await_departure: [True]\n\u2514\u2500\u2500 ordered_stops: ['490000252KA.link:1437', '490000235P.link:15', '490002124ZZ.link:1172', '490000091G.link:1242', '490000173RG.link:2614']\n</pre> In\u00a0[44]: Copied! <pre>n.schedule.service_attribute_summary(data=True)\n</pre> n.schedule.service_attribute_summary(data=True) <pre>attribute\n\u251c\u2500\u2500 id: ['20274', '15234', '18915', '12430', '18853']\n\u2514\u2500\u2500 name: ['N55', 'N5', '113', 'N20', '134']\n</pre> <p>Again, similarly to <code>Network</code> objects, we can generate <code>pandas.DataFrame</code>s for chosen attributes of Stops, Routes and Services. These dataframes are indexed by the index of the object you query, i.e. Stop ID, Route ID or Service ID. During intantiation of a Schedule object, Route and Service indices are checked and forced to be unique, reindexing them as neccessary.</p> In\u00a0[45]: Copied! <pre>n.schedule.stop_attribute_data(keys=[\"lat\", \"lon\", \"name\"]).head()\n</pre> n.schedule.stop_attribute_data(keys=[\"lat\", \"lon\", \"name\"]).head() Out[45]: lat lon name 490000235X.link:834 51.516685 -0.128096 Tottenham Court Road Station (Stop X) 490000235YB.link:574 51.516098 -0.134044 Oxford Street  Soho Street (Stop YB) 490014214HE.link:3154 51.515923 -0.135392 Wardour Street (Stop OM) 490010689KB.link:981 51.515472 -0.139893 Great Titchfield Street  Oxford Circus Station... 490000235V.link:3140 51.516380 -0.131929 Tottenham Court Road Station (Stop V) In\u00a0[46]: Copied! <pre>n.schedule.route_attribute_data(keys=[\"route_short_name\", \"mode\"]).head()\n</pre> n.schedule.route_attribute_data(keys=[\"route_short_name\", \"mode\"]).head() Out[46]: route_short_name mode VJ375a660d47a2aa570aa20a8568012da8497ffecf N55 bus VJ812fad65e7fa418645b57b446f00cba573f2cdaf N55 bus VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e N55 bus VJea6046f64f85febf1854290fb8f76e921e3ac96b 94 bus VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc 94 bus In\u00a0[47]: Copied! <pre>n.schedule.service_attribute_data(keys=\"name\", index_name=\"service_id\").head()\n</pre> n.schedule.service_attribute_data(keys=\"name\", index_name=\"service_id\").head() Out[47]: name service_id 20274 N55 12430 205 15234 134 18915 N5 18853 N8 <p>Each trip in the schedule has a vehicle assigned to it. By default, each trip will have a unique vehicle, but this can be changed by the user (have a look in modification notebook). Each vehicle is linked to a type. Each schedule begins with types based off of a config <code>genet/configs/vehicles/vehicle_definitions.yml</code>, the user may like to point to their own config file or set those values through the Schedule object.</p> In\u00a0[48]: Copied! <pre>n.schedule.vehicles[\"veh_2331_bus\"]\n</pre> n.schedule.vehicles[\"veh_2331_bus\"] Out[48]: <pre>{'type': 'Bus'}</pre> In\u00a0[49]: Copied! <pre>n.schedule.vehicle_types[\"Bus\"][\"capacity\"][\"standingRoom\"][\"persons\"] = 5\nn.schedule.vehicle_types[\"Bus\"]\n</pre> n.schedule.vehicle_types[\"Bus\"][\"capacity\"][\"standingRoom\"][\"persons\"] = 5 n.schedule.vehicle_types[\"Bus\"] Out[49]: <pre>{'capacity': {'seats': {'persons': '70'}, 'standingRoom': {'persons': 5}},\n 'length': {'meter': '18.0'},\n 'width': {'meter': '2.5'},\n 'accessTime': {'secondsPerPerson': '0.5'},\n 'egressTime': {'secondsPerPerson': '0.5'},\n 'doorOperation': {'mode': 'serial'},\n 'passengerCarEquivalents': {'pce': '2.8'}}</pre> <p>There exists a method to check that all vehicles are linked to a vehicle type which exists in the schedule.</p> In\u00a0[50]: Copied! <pre>n.schedule.validate_vehicle_definitions()\n</pre> n.schedule.validate_vehicle_definitions() Out[50]: <pre>True</pre> <p><code>trips_to_dataframe</code> is a useful method to extract all of the trips, their departures and vehicle IDs associated with the trips in the schedule. Trip ids need not be unique, route IDs provide a secondary index. Associated service IDs are also given for convenience. There is another method <code>set_trips_dataframe</code> which takes this dataframe and applies changes to all route trips based on the data in the dataframe. This means you can generate this DataFrame as shown below, manipulate trips (delete them, add new ones), change their departure times or change their vehicle ids to be shared for differnt trips, perhaps on some temporal logic and as long as the dataframe has the same schema, you can use it to set new trips in the schedule. This will appear in the changelog as a route level modify event. More info on this can be found in the Modifying Network notebook or wiki page.</p> In\u00a0[51]: Copied! <pre>n.schedule.trips_to_dataframe(gtfs_day=\"20210101\").head()\n</pre> n.schedule.trips_to_dataframe(gtfs_day=\"20210101\").head() Out[51]: route_id mode service_id trip_id trip_departure_time vehicle_id 0 VJ375a660d47a2aa570aa20a8568012da8497ffecf bus 20274 VJ2cdccea96e0e3e6a53a968bcb132941415d6d7c9_04:... 2021-01-01 04:53:00 veh_2331_bus 1 VJ375a660d47a2aa570aa20a8568012da8497ffecf bus 20274 VJ375a660d47a2aa570aa20a8568012da8497ffecf_03:... 2021-01-01 03:53:00 veh_2332_bus 2 VJ375a660d47a2aa570aa20a8568012da8497ffecf bus 20274 VJ3b9d77d2ef200b21c8048fea5eedc2d2788a1b94_01:... 2021-01-01 01:54:00 veh_2333_bus 3 VJ375a660d47a2aa570aa20a8568012da8497ffecf bus 20274 VJ79974c386a39426e06783650a759828438432aa4_05:... 2021-01-01 05:23:00 veh_2334_bus 4 VJ375a660d47a2aa570aa20a8568012da8497ffecf bus 20274 VJa09c394b71031216571d813a6266c83f2d30bf0a_04:... 2021-01-01 04:23:00 veh_2335_bus In\u00a0[52]: Copied! <pre>n.schedule.trips_headways().head()\n</pre> n.schedule.trips_headways().head() Out[52]: route_id mode service_id trip_id trip_departure_time vehicle_id headway headway_mins 0 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 bus 12430 VJ70cdcef7ccba9c599c70f89bdf8b10852e33bb04_11:... 1970-01-01 11:15:42 veh_409_bus 0 days 00:00:00 0.0 1 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 bus 12430 VJ126aa65811277b9774ae127ff819495441bc4e75_11:... 1970-01-01 11:24:42 veh_392_bus 0 days 00:09:00 9.0 2 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 bus 12430 VJ0d3b026c4060cd0325803e488a965a5ab91fd4c0_11:... 1970-01-01 11:32:42 veh_390_bus 0 days 00:08:00 8.0 3 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 bus 12430 VJ4155b3d5d916db07a50061ae1c15b24ecfc2f96f_11:... 1970-01-01 11:41:42 veh_401_bus 0 days 00:09:00 9.0 4 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 bus 12430 VJc9a308474ed72f769664413e686f3447613c5b3a_11:... 1970-01-01 11:49:42 veh_425_bus 0 days 00:08:00 8.0 <p>You can also generate a dataframe with summary information about headways for each route in the schedule</p> In\u00a0[53]: Copied! <pre>n.schedule.headway_stats().head()\n</pre> n.schedule.headway_stats().head() Out[53]: service_id route_id mode mean_headway_mins std_headway_mins max_headway_mins min_headway_mins trip_count 0 12430 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 bus 8.688889 1.378771 10.0 0.0 45.0 1 12430 VJ06cd41dcd58d947097df4a8f33234ef423210154 bus 115.333333 266.361909 659.0 0.0 6.0 2 12430 VJ0f3c08222de16c2e278be0a1bf0f9ea47370774e bus 9.851064 8.032485 63.0 0.0 47.0 3 12430 VJ15419796737689e742962a625abcf3fd5b3d58b1 bus 22.928571 75.682049 409.0 0.0 28.0 4 12430 VJ235c8fca539cf931b3c673f9b056606384aff950 bus 24.433333 86.248512 481.0 0.0 30.0 <p>In another notebook on modification, you can find information about generating new trips to replace the old using headway information. This is useful when creating scenario networks.</p> In\u00a0[54]: Copied! <pre>n.schedule.extract_service_ids_on_attributes(conditions={\"name\": \"N55\"})\n</pre> n.schedule.extract_service_ids_on_attributes(conditions={\"name\": \"N55\"}) Out[54]: <pre>['20274']</pre> In\u00a0[55]: Copied! <pre>n.schedule.extract_route_ids_on_attributes(\n    conditions=[{\"mode\": \"bus\"}, {\"route_short_name\": \"N55\"}], how=all\n)[:5]\n</pre> n.schedule.extract_route_ids_on_attributes(     conditions=[{\"mode\": \"bus\"}, {\"route_short_name\": \"N55\"}], how=all )[:5] Out[55]: <pre>['VJ375a660d47a2aa570aa20a8568012da8497ffecf',\n 'VJ812fad65e7fa418645b57b446f00cba573f2cdaf',\n 'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e']</pre> In\u00a0[56]: Copied! <pre>def oxford_street_in_name(attribs):\n    if \"Oxford Street\" in attribs:\n        return True\n    else:\n        return False\n\n\nn.schedule.extract_stop_ids_on_attributes(conditions={\"name\": oxford_street_in_name})[:5]\n</pre> def oxford_street_in_name(attribs):     if \"Oxford Street\" in attribs:         return True     else:         return False   n.schedule.extract_stop_ids_on_attributes(conditions={\"name\": oxford_street_in_name})[:5] Out[56]: <pre>['490000235YB.link:574',\n '490000235P.link:15',\n '490000173W.link:1868',\n '490000235Z.link:15',\n '490000235Z']</pre> <p>There are several common extraction logics we might need. They relate to modes and spatial and temporal logic. Below we go through some convenience methods for those.</p> In\u00a0[57]: Copied! <pre>n.schedule.services_on_modal_condition(modes=\"bus\")[:5]\n</pre> n.schedule.services_on_modal_condition(modes=\"bus\")[:5] Out[57]: <pre>['20274', '15234', '12430', '18853', '18915']</pre> In\u00a0[58]: Copied! <pre>n.schedule.routes_on_modal_condition(modes=[\"bus\", \"rail\"])[:5]\n</pre> n.schedule.routes_on_modal_condition(modes=[\"bus\", \"rail\"])[:5] Out[58]: <pre>['VJ375a660d47a2aa570aa20a8568012da8497ffecf',\n 'VJ812fad65e7fa418645b57b446f00cba573f2cdaf',\n 'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e',\n 'VJea6046f64f85febf1854290fb8f76e921e3ac96b',\n 'VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc']</pre> In\u00a0[59]: Copied! <pre>n.schedule.stops_on_modal_condition(modes=\"bus\")[:5]\n</pre> n.schedule.stops_on_modal_condition(modes=\"bus\")[:5] Out[59]: <pre>['490000235X.link:834',\n '490000235YB.link:574',\n '490014214HE.link:3154',\n '490010689KB.link:981',\n '490000235V.link:3140']</pre> In\u00a0[60]: Copied! <pre>from shapely.geometry import Polygon\n\nregion = Polygon(\n    [\n        (-0.1487016677856445, 51.52556684350165),\n        (-0.14063358306884766, 51.5255134425896),\n        (-0.13865947723388672, 51.5228700191647),\n        (-0.14093399047851562, 51.52006622056997),\n        (-0.1492595672607422, 51.51974577545329),\n        (-0.1508045196533203, 51.52276321095246),\n        (-0.1487016677856445, 51.52556684350165),\n    ]\n)\n\nn.schedule.services_on_spatial_condition(region)\n</pre> from shapely.geometry import Polygon  region = Polygon(     [         (-0.1487016677856445, 51.52556684350165),         (-0.14063358306884766, 51.5255134425896),         (-0.13865947723388672, 51.5228700191647),         (-0.14093399047851562, 51.52006622056997),         (-0.1492595672607422, 51.51974577545329),         (-0.1508045196533203, 51.52276321095246),         (-0.1487016677856445, 51.52556684350165),     ] )  n.schedule.services_on_spatial_condition(region) Out[60]: <pre>['12430']</pre> <p>There are two options for <code>Service</code> and <code>Route</code> objects. They can either <code>intersect</code> the area, meaning at least one of their <code>Stop</code>s lie in the specified area, or be <code>within</code> this area.</p> In\u00a0[61]: Copied! <pre>geojson = \"example_data/Fitzrovia_polygon.geojson\"\n\n# here the area is too small for any routes to be within it\nn.schedule.routes_on_spatial_condition(geojson, how=\"within\")\n</pre> geojson = \"example_data/Fitzrovia_polygon.geojson\"  # here the area is too small for any routes to be within it n.schedule.routes_on_spatial_condition(geojson, how=\"within\") Out[61]: <pre>[]</pre> In\u00a0[62]: Copied! <pre># a lot of routes intersect it however\nn.schedule.routes_on_spatial_condition(geojson, how=\"intersect\")[:5]\n</pre> # a lot of routes intersect it however n.schedule.routes_on_spatial_condition(geojson, how=\"intersect\")[:5] Out[62]: <pre>['VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3',\n 'VJeae6e634f8479e0b6712780d5728f0afca964e64',\n 'VJ15419796737689e742962a625abcf3fd5b3d58b1',\n 'VJf8e38a73359b6cf743d8e35ee64ef1f7b7914daa',\n 'VJ06cd41dcd58d947097df4a8f33234ef423210154']</pre> In\u00a0[63]: Copied! <pre>hex_region = \"48761ad71,48761ad723,48761ad724c,48761ad73c,48761ad744,48761ad75d3,48761ad75d5,48761ad765,48761ad767,48761ad76c,48761ad774,48761ad779,48761ad77b,48761ad783,48761ad784c,48761ad7854,48761ad794,48761ad79c,48761ad7a4,48761ad7ac,48761ad7b1,48761ad7bc\"\nn.schedule.stops_on_spatial_condition(hex_region)\n</pre> hex_region = \"48761ad71,48761ad723,48761ad724c,48761ad73c,48761ad744,48761ad75d3,48761ad75d5,48761ad765,48761ad767,48761ad76c,48761ad774,48761ad779,48761ad77b,48761ad783,48761ad784c,48761ad7854,48761ad794,48761ad79c,48761ad7a4,48761ad7ac,48761ad7b1,48761ad7bc\" n.schedule.stops_on_spatial_condition(hex_region) Out[63]: <pre>['490000091G.link:1242',\n '490000091H.link:1912',\n '490000091F',\n '490000091E',\n '490000091G',\n '490000091H',\n '9400ZZLUGPS2',\n '490013600C']</pre> In\u00a0[64]: Copied! <pre>n.schedule.trips_with_stops_to_dataframe(gtfs_day=\"20200101\").head()\n</pre> n.schedule.trips_with_stops_to_dataframe(gtfs_day=\"20200101\").head() Out[64]: service_name service_id arrival_time from_stop_name to_stop route_id from_stop departure_time mode to_stop_name route_name trip_id vehicle_id 0 205 12430 2020-01-01 16:35:25 Euston Square (Stop P) 4900020147W.link:2634 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 490000078P.link:1383 2020-01-01 16:33:42 bus University College Hosp Warren Street Stn (Sto... 205 VJ03f4f8905d6dc7868242f3fd29828ee9b366a906_16:... veh_388_bus 1 205 12430 2020-01-01 16:37:08 University College Hosp Warren Street Stn (Sto... 490000252V.link:1182 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 4900020147W.link:2634 2020-01-01 16:35:25 bus Warren Street Station (Stop V) 205 VJ03f4f8905d6dc7868242f3fd29828ee9b366a906_16:... veh_388_bus 2 205 12430 2020-01-01 16:38:51 Warren Street Station (Stop V) 490000091G.link:1242 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 490000252V.link:1182 2020-01-01 16:37:08 bus Great Portland Street (Stop G) 205 VJ03f4f8905d6dc7868242f3fd29828ee9b366a906_16:... veh_388_bus 3 205 12430 2020-01-01 16:40:34 Great Portland Street (Stop G) 490000191B.link:305 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 490000091G.link:1242 2020-01-01 16:38:51 bus Regent's Park (Stop B) 205 VJ03f4f8905d6dc7868242f3fd29828ee9b366a906_16:... veh_388_bus 4 205 12430 2020-01-01 16:42:17 Regent's Park (Stop B) 490007807W.link:2922 VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3 490000191B.link:305 2020-01-01 16:40:34 bus Harley Street (Stop L) 205 VJ03f4f8905d6dc7868242f3fd29828ee9b366a906_16:... veh_388_bus <p>Once you extract IDs of interest, you can access these objects. You can also modify them, check out the Modify Network notebook for usage examples.</p> <p>Each <code>Service</code> is indexed and can be accessed by its' ID. It also has a plot method.</p> In\u00a0[65]: Copied! <pre>n.schedule.service_ids()[:5]\n</pre> n.schedule.service_ids()[:5] Out[65]: <pre>['20274', '12430', '15234', '18915', '18853']</pre> In\u00a0[66]: Copied! <pre>service = n.schedule[\"12430\"]\nservice.print()\n</pre> service = n.schedule[\"12430\"] service.print() <pre>Service ID: 12430\nName: 205\nNumber of routes: 12\nNumber of stops: 11\n</pre> In\u00a0[67]: Copied! <pre># service.plot()\n</pre> # service.plot() <p>Similarly, each <code>Route</code> is indexed and can be accessed by its' id. It also has a plot method.</p> In\u00a0[68]: Copied! <pre>n.schedule.route_ids()[:5]\n</pre> n.schedule.route_ids()[:5] Out[68]: <pre>['VJ375a660d47a2aa570aa20a8568012da8497ffecf',\n 'VJ812fad65e7fa418645b57b446f00cba573f2cdaf',\n 'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e',\n 'VJea6046f64f85febf1854290fb8f76e921e3ac96b',\n 'VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc']</pre> In\u00a0[69]: Copied! <pre>route = n.schedule.route(\"VJ948e8caa0f08b9c6bf6330927893942c474b5100\")\nroute.print()\n</pre> route = n.schedule.route(\"VJ948e8caa0f08b9c6bf6330927893942c474b5100\") route.print() <pre>Route ID: VJ948e8caa0f08b9c6bf6330927893942c474b5100\nName: 205\nNumber of stops: 5\nNumber of trips: 10\n</pre> In\u00a0[70]: Copied! <pre># route.plot()\n</pre> # route.plot() <p>Finally, each <code>Stop</code> is indexed too, and can be accessed by its' id.</p> In\u00a0[71]: Copied! <pre>stop = n.schedule.stop(\"490007807E.link:1154\")\nstop.print()\n</pre> stop = n.schedule.stop(\"490007807E.link:1154\") stop.print() <pre>Stop ID: 490007807E.link:1154\nProjection: epsg:27700\nLat, Lon: 51.52336503, -0.14951799\nlinkRefId: 1154\n</pre>"},{"location":"examples/4_1_using_network_accessing_data/#41-using-the-network-object-accessing-data","title":"4.1. Using the <code>Network</code> object: Accessing data\u00b6","text":"<p>Available as a jupyter notebook or wiki page.</p> <p>Let's read in a sample MATSim network into GeNet's <code>Network</code> object.</p>"},{"location":"examples/4_1_using_network_accessing_data/#summary","title":"Summary\u00b6","text":"<p>The network summary report can be accessed using the <code>summary_report</code> method</p>"},{"location":"examples/4_1_using_network_accessing_data/#extracting-links-of-interest","title":"Extracting links of interest\u00b6","text":"<p>The function below gathers link ids which satisfy conditions to arbitrary level of nested-ness. It also allows quite flexible conditions---below we require that the link value at <code>data['attributes']['osm:way:highway'] == 'primary'</code>, where data is the data dictionary stored on that link.</p>"},{"location":"examples/4_1_using_network_accessing_data/#modal-convenience-methods","title":"Modal convenience methods\u00b6","text":""},{"location":"examples/4_1_using_network_accessing_data/#spatial-convenience-methods","title":"Spatial convenience methods\u00b6","text":"<p>For spatial extraction conditions you have a choice of:</p> <ul> <li><code>shapely.geometry.Polygon</code> or <code>shapely.geometry.GeometryCollection</code> of Polygons (in epsg:4326)</li> <li>geojson file, can be generated with http://geojson.io/</li> <li>S2 Geometry hex string which can be generated and copied from http://s2.sidewalklabs.com/regioncoverer</li> </ul>"},{"location":"examples/4_1_using_network_accessing_data/#using-the-schedule-object","title":"Using the <code>Schedule</code> object\u00b6","text":"<p><code>Schedule</code> is a representation of public transit and is a part of any <code>genet.Network</code>, it is initiated as empty. A Network can exist and still be valid with an empty <code>Schedule</code>. Earlier we read a MATSim transit schedule.</p> <p>A <code>Schedule</code> is comprised of a number of nested objects. Each <code>Schedule</code> has a number of <code>Service</code>s. Each <code>Service</code> is made up a number of <code>Route</code>s. A <code>Route</code> is defined by an ordered list of <code>Stop</code> objects. Every <code>Service</code> should, logically, have at least two <code>Route</code>s, one going in one direction and another going back. Each <code>Route</code> also hold information about the trips, their timing and offsets arriving and departing at the <code>Stop</code>s.</p> <p>We can look at quick stats:</p>"},{"location":"examples/4_1_using_network_accessing_data/#summary","title":"Summary\u00b6","text":"<p>Schedules can get large and complicated. GeNet includes methods similar to ones presented for <code>Network</code> objects. This time, instead of inspecting data stored on links and edges of a graph, we summarise data held for Stops, Routes and Services in the Schedule.</p>"},{"location":"examples/4_1_using_network_accessing_data/#headways","title":"Headways\u00b6","text":"<p>You can generate a dataframe with headway information for all trips and services</p>"},{"location":"examples/4_1_using_network_accessing_data/#extracting-stops-routes-services-of-interest","title":"Extracting Stops, Routes, Services of interest\u00b6","text":"<p>There are times when we need to extract Service, Route or Stop IDs depending on some logic. Building conditions works exactly the same as for links and nodes of <code>genet.Network</code> which was presented exhaustively above. Here we present some examples. There are separate methods for <code>Service</code>, <code>Route</code> or <code>Stop</code> objects that return the IDs of these objects if they satisfy the conditions given by the user. Note, <code>attribute_summary</code> methods presented above help in building these conditions.</p>"},{"location":"examples/4_1_using_network_accessing_data/#in-general","title":"In general\u00b6","text":""},{"location":"examples/4_1_using_network_accessing_data/#modal","title":"Modal\u00b6","text":"<p>Below are convenience methods for extracting object IDs based on the modes they are related to. Note that only <code>Route</code> objects actually hold information about their mode of transport. When we extract <code>Service</code> of mode <code>x</code>, we pick services whose at least one route is of that mode. Similarly with <code>Stop</code>s, we extract those used by routes of that mode.</p>"},{"location":"examples/4_1_using_network_accessing_data/#spatial","title":"Spatial\u00b6","text":"<p>For spatial extraction conditions, similarly to the <code>Network</code> object, you have a choice of:</p> <ul> <li><code>shapely.geometry.Polygon</code> or <code>shapely.geometry.GeometryCollection</code> of Polygons (in epsg:4326)</li> <li>geojson file, can be generated with http://geojson.io/</li> <li>S2 Geometry hex string which can be generated and copied from http://s2.sidewalklabs.com/regioncoverer</li> </ul> <p>Again, methods exist for <code>Service</code>, <code>Route</code> or <code>Stop</code> objects seperately.</p>"},{"location":"examples/4_1_using_network_accessing_data/#temporal","title":"Temporal\u00b6","text":"<p>These methods are under construction. A useful one in the meantime is presented below. It generates a <code>pandas.DataFrame</code> of departure and arrival times between all stops for all trips.</p>"},{"location":"examples/4_1_using_network_accessing_data/#accessing-stop-route-service-objects","title":"Accessing <code>Stop</code>, <code>Route</code>, <code>Service</code> objects\u00b6","text":""},{"location":"examples/4_2_using_network_road_pricing/","title":"4.2. Using the object: Road Pricing","text":"In\u00a0[1]: Copied! <pre>import os\nfrom pathlib import Path\n\nimport pandas as pd\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\noutput_path = Path(\"example_data/outputs/road_pricing\")\nos.makedirs(output_path, exist_ok=True)\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.link_attribute_summary()\n</pre> import os from pathlib import Path  import pandas as pd  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\" output_path = Path(\"example_data/outputs/road_pricing\") os.makedirs(output_path, exist_ok=True)  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.link_attribute_summary() <pre>attribute\n\u251c\u2500\u2500 id\n\u251c\u2500\u2500 from\n\u251c\u2500\u2500 to\n\u251c\u2500\u2500 freespeed\n\u251c\u2500\u2500 capacity\n\u251c\u2500\u2500 permlanes\n\u251c\u2500\u2500 oneway\n\u251c\u2500\u2500 modes\n\u251c\u2500\u2500 s2_from\n\u251c\u2500\u2500 s2_to\n\u251c\u2500\u2500 attributes\n\u2502   \u251c\u2500\u2500 osm:way:access\n\u2502   \u251c\u2500\u2500 osm:way:highway\n\u2502   \u251c\u2500\u2500 osm:way:id\n\u2502   \u251c\u2500\u2500 osm:way:name\n\u2502   \u251c\u2500\u2500 osm:relation:route\n\u2502   \u251c\u2500\u2500 osm:way:lanes\n\u2502   \u251c\u2500\u2500 osm:way:oneway\n\u2502   \u251c\u2500\u2500 osm:way:tunnel\n\u2502   \u251c\u2500\u2500 osm:way:psv\n\u2502   \u251c\u2500\u2500 osm:way:vehicle\n\u2502   \u251c\u2500\u2500 osm:way:traffic_calming\n\u2502   \u251c\u2500\u2500 osm:way:junction\n\u2502   \u2514\u2500\u2500 osm:way:service\n\u2514\u2500\u2500 length\n</pre> <p>Our current workflow relies on OSM way ids being saved to the network in the nested 'attributes' dictionary. We query OSM to extract those OSM ids and find them in the network.</p> <pre><code>attribute\n\u251c\u2500\u2500 id\n\u251c\u2500\u2500 from\n\u251c\u2500\u2500 to\n...\n\u251c\u2500\u2500 attributes\n...\n\u2502   \u251c\u2500\u2500 osm:way:id\n...\n</code></pre> <p>Of course this can be streamlined by just reading and saving the <code>toll</code> tag when creating a network from OSM. For more info see Usage: 2.2. Reading Data: OSM. This would manifest itself in the following way in the links data:</p> <pre><code>attribute\n\u251c\u2500\u2500 id\n\u251c\u2500\u2500 from\n\u251c\u2500\u2500 to\n...\n\u251c\u2500\u2500 attributes\n...\n\u2502   \u251c\u2500\u2500 osm:way:toll\n...\n</code></pre> <p>where you would look for <code>'osm:way:toll':'yes'</code></p> <p>To do this via OSM ids, you can head over to https://overpass-turbo.eu/, use the quiery Wizard to find <code>toll=yes</code> zooming into the right place on the map. You can then grab the relevant OSM data by clicking <code>Export</code>. Under <code>Data</code> tab, you can click on <code>download/copy as raw OSM data</code>. This will copy the data into clipboard. Below I paste a small example:</p> In\u00a0[2]: Copied! <pre>osm_data = {\n    \"version\": 0.6,\n    \"generator\": \"Overpass API 0.7.56.8 7d656e78\",\n    \"osm3s\": {\n        \"timestamp_osm_base\": \"2020-12-16T15:46:02Z\",\n        \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\",\n    },\n    \"elements\": [\n        {\n            \"type\": \"way\",\n            \"id\": 26997928,\n            \"nodes\": [107790, 1102995756, 5479634639, 5364578862, 21665585, 5479634644, 107791],\n            \"tags\": {\n                \"highway\": \"primary\",\n                \"lit\": \"yes\",\n                \"maxspeed\": \"20 mph\",\n                \"maxspeed:type\": \"GB:zone20\",\n                \"name\": \"Charing Cross Road\",\n                \"ref\": \"A400\",\n                \"sidewalk\": \"both\",\n                \"surface\": \"asphalt\",\n                \"toll\": \"yes\",\n                \"wikidata\": \"Q1063230\",\n            },\n        },\n        {\n            \"type\": \"way\",\n            \"id\": 546461337,\n            \"nodes\": [1556097185, 1951372935, 1951372927],\n            \"tags\": {\n                \"foot\": \"no\",\n                \"highway\": \"primary\",\n                \"lit\": \"yes\",\n                \"maxspeed\": \"20 mph\",\n                \"name\": \"Byward Street\",\n                \"oneway\": \"yes\",\n                \"operator\": \"Transport for London\",\n                \"postal_code\": \"EC3\",\n                \"ref\": \"A3211\",\n                \"sidewalk\": \"none\",\n                \"surface\": \"asphalt\",\n                \"toll\": \"yes\",\n            },\n        },\n        {\"type\": \"node\", \"id\": 107790, \"lat\": 51.511322, \"lon\": -0.1283895},\n        {\"type\": \"node\", \"id\": 107791, \"lat\": 51.5118562, \"lon\": -0.1283797},\n        {\"type\": \"node\", \"id\": 21665585, \"lat\": 51.5116901, \"lon\": -0.1283715},\n        {\"type\": \"node\", \"id\": 1102995756, \"lat\": 51.511415, \"lon\": -0.1283857},\n        {\"type\": \"node\", \"id\": 5364578862, \"lat\": 51.511599, \"lon\": -0.1283762},\n        {\"type\": \"node\", \"id\": 5479634639, \"lat\": 51.5114884, \"lon\": -0.1283819},\n        {\"type\": \"node\", \"id\": 5479634644, \"lat\": 51.5117331, \"lon\": -0.1283705},\n    ],\n}\n</pre> osm_data = {     \"version\": 0.6,     \"generator\": \"Overpass API 0.7.56.8 7d656e78\",     \"osm3s\": {         \"timestamp_osm_base\": \"2020-12-16T15:46:02Z\",         \"copyright\": \"The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.\",     },     \"elements\": [         {             \"type\": \"way\",             \"id\": 26997928,             \"nodes\": [107790, 1102995756, 5479634639, 5364578862, 21665585, 5479634644, 107791],             \"tags\": {                 \"highway\": \"primary\",                 \"lit\": \"yes\",                 \"maxspeed\": \"20 mph\",                 \"maxspeed:type\": \"GB:zone20\",                 \"name\": \"Charing Cross Road\",                 \"ref\": \"A400\",                 \"sidewalk\": \"both\",                 \"surface\": \"asphalt\",                 \"toll\": \"yes\",                 \"wikidata\": \"Q1063230\",             },         },         {             \"type\": \"way\",             \"id\": 546461337,             \"nodes\": [1556097185, 1951372935, 1951372927],             \"tags\": {                 \"foot\": \"no\",                 \"highway\": \"primary\",                 \"lit\": \"yes\",                 \"maxspeed\": \"20 mph\",                 \"name\": \"Byward Street\",                 \"oneway\": \"yes\",                 \"operator\": \"Transport for London\",                 \"postal_code\": \"EC3\",                 \"ref\": \"A3211\",                 \"sidewalk\": \"none\",                 \"surface\": \"asphalt\",                 \"toll\": \"yes\",             },         },         {\"type\": \"node\", \"id\": 107790, \"lat\": 51.511322, \"lon\": -0.1283895},         {\"type\": \"node\", \"id\": 107791, \"lat\": 51.5118562, \"lon\": -0.1283797},         {\"type\": \"node\", \"id\": 21665585, \"lat\": 51.5116901, \"lon\": -0.1283715},         {\"type\": \"node\", \"id\": 1102995756, \"lat\": 51.511415, \"lon\": -0.1283857},         {\"type\": \"node\", \"id\": 5364578862, \"lat\": 51.511599, \"lon\": -0.1283762},         {\"type\": \"node\", \"id\": 5479634639, \"lat\": 51.5114884, \"lon\": -0.1283819},         {\"type\": \"node\", \"id\": 5479634644, \"lat\": 51.5117331, \"lon\": -0.1283705},     ], } <p>All that is left is extracting the OSM way IDs of interest. In the case above it's just a couple.</p> <p>It is also useful to record the <code>ref</code> and <code>name</code> or any other data that may relate to a dataset you have for tolls to make it human readable or to be able to join the two datasets. This will make it easier to decide on how much the toll should be.</p> In\u00a0[3]: Copied! <pre>def extract_data(d, key):\n    try:\n        return d[key]\n    except KeyError:\n        return float(\"nan\")\n\n\nosm_id = []\nosm_ref = []\nosm_name = []\n\nfor element in osm_data[\"elements\"]:\n    if element[\"type\"] == \"way\":\n        # what you get from overpass should all just be tolls but let's\n        # put an extra condition here anyway\n        if (\"toll\" in element[\"tags\"]) and (element[\"tags\"][\"toll\"] == \"yes\"):\n            osm_id.append(element[\"id\"])\n            osm_ref.append(extract_data(element[\"tags\"], \"ref\"))\n            osm_name.append(extract_data(element[\"tags\"], \"name\"))\n\ndf_tolls = pd.DataFrame({\"osm_id\": osm_id, \"osm_ref\": osm_ref, \"osm_name\": osm_name})\n# the osm IDs in our network are of float type. Make sure you search for data with matching data types\ndf_tolls[\"osm_id\"] = df_tolls[\"osm_id\"].astype(float)\ndf_tolls.head()\n</pre> def extract_data(d, key):     try:         return d[key]     except KeyError:         return float(\"nan\")   osm_id = [] osm_ref = [] osm_name = []  for element in osm_data[\"elements\"]:     if element[\"type\"] == \"way\":         # what you get from overpass should all just be tolls but let's         # put an extra condition here anyway         if (\"toll\" in element[\"tags\"]) and (element[\"tags\"][\"toll\"] == \"yes\"):             osm_id.append(element[\"id\"])             osm_ref.append(extract_data(element[\"tags\"], \"ref\"))             osm_name.append(extract_data(element[\"tags\"], \"name\"))  df_tolls = pd.DataFrame({\"osm_id\": osm_id, \"osm_ref\": osm_ref, \"osm_name\": osm_name}) # the osm IDs in our network are of float type. Make sure you search for data with matching data types df_tolls[\"osm_id\"] = df_tolls[\"osm_id\"].astype(float) df_tolls.head() Out[3]: osm_id osm_ref osm_name 0 26997928.0 A400 Charing Cross Road 1 546461337.0 A3211 Byward Street <p>We now write this to a csv file.</p> In\u00a0[4]: Copied! <pre>df_tolls.to_csv(output_path / \"osm_toll_id_ref.csv\", index=False)\n</pre> df_tolls.to_csv(output_path / \"osm_toll_id_ref.csv\", index=False) <p>We can now use GeNet's road pricing methods to map the OSM ids in <code>df_tolls</code> to network links.</p> In\u00a0[5]: Copied! <pre>from genet.use import road_pricing\n\nroad_pricing.extract_network_id_from_osm_csv(\n    network=n,\n    attribute_name=\"osm:way:id\",\n    osm_csv_path=output_path / \"osm_toll_id_ref.csv\",\n    outpath=output_path,\n    osm_dtype=float,  # the osm IDs in our network are of float type. Make sure you search for data with matching data types\n)\n</pre> from genet.use import road_pricing  road_pricing.extract_network_id_from_osm_csv(     network=n,     attribute_name=\"osm:way:id\",     osm_csv_path=output_path / \"osm_toll_id_ref.csv\",     outpath=output_path,     osm_dtype=float,  # the osm IDs in our network are of float type. Make sure you search for data with matching data types ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 37.33it/s]\n</pre> Out[5]: <pre>(        osm_id osm_ref            osm_name  network_id\n 0   26997928.0    A400  Charing Cross Road        True\n 1  546461337.0   A3211       Byward Street        True,\n {26997928.0: ['1', '2', '3', '4'], 546461337.0: ['998', '999']})</pre> <p>This step can take a long time because the relationship between OSM ways and MATSim network links is rarely 1-to-1. For a given OSM way, there can be multiple network links (i.e. multiple links sharing the same <code>osm:way:id</code>) or no network links at all (i.e. during network creation/manipulation some OSM links were deleted or merged). Therefore, the matching OSM ways to network links has to be done on a case-by-case basis.</p> <p>Upon completion, there will be two new files in the output folder <code>example_data/pt2matsim_network/road_pricing</code> specified above:</p> <ul> <li><code>osm_tolls_with_network_ids.csv</code>: this file will be a copy of the input <code>osm_toll_id_ref.csv</code> but augmented with a <code>True</code>/<code>False</code> value indicating whether each OSM way id was successfully matched with one of more network link ids.</li> <li><code>osm_to_network_ids.json</code>: this file contains a mapping of each OSM way id in <code>osm_toll_id_ref.csv</code> with one or more network link ids.</li> </ul> <p>The next step is to decide on the <code>vehicle_type</code>, <code>toll_amount</code>, <code>start_time</code> and <code>end_time</code> for the toll. You may have other data that you can join onto <code>osm_tolls_with_network_ids.csv</code>. In the example below, we make it up.</p> In\u00a0[6]: Copied! <pre>df_tolls = pd.read_csv(\"example_data/pt2matsim_network/road_pricing/osm_tolls_with_network_ids.csv\")\n\ndf_tolls.head()\n</pre> df_tolls = pd.read_csv(\"example_data/pt2matsim_network/road_pricing/osm_tolls_with_network_ids.csv\")  df_tolls.head() Out[6]: osm_id osm_ref osm_name network_id 0 26997928.0 A400 Charing Cross Road True 1 546461337.0 A3211 Byward Street True In\u00a0[7]: Copied! <pre>df_tolls[\"vehicle_type\"] = \"type2\"\ndf_tolls[\"toll_amount\"] = \"2.9\"\ndf_tolls[\"start_time\"] = \"00:00\"\ndf_tolls[\"end_time\"] = \"23:59\"\ndf_tolls.head()\n</pre> df_tolls[\"vehicle_type\"] = \"type2\" df_tolls[\"toll_amount\"] = \"2.9\" df_tolls[\"start_time\"] = \"00:00\" df_tolls[\"end_time\"] = \"23:59\" df_tolls.head() Out[7]: osm_id osm_ref osm_name network_id vehicle_type toll_amount start_time end_time 0 26997928.0 A400 Charing Cross Road True type2 2.9 00:00 23:59 1 546461337.0 A3211 Byward Street True type2 2.9 00:00 23:59 In\u00a0[8]: Copied! <pre>df_tolls.to_csv(output_path / \"osm_tolls_with_network_ids.csv\")\n</pre> df_tolls.to_csv(output_path / \"osm_tolls_with_network_ids.csv\") <p>Next we can generate the road pricing file.</p> In\u00a0[9]: Copied! <pre>xml_tree = road_pricing.build_tree_from_csv_json(\n    output_path / \"osm_tolls_with_network_ids.csv\", output_path / \"osm_to_network_ids.json\"\n)\n\nroad_pricing.write_xml(xml_tree, output_path)\n</pre> xml_tree = road_pricing.build_tree_from_csv_json(     output_path / \"osm_tolls_with_network_ids.csv\", output_path / \"osm_to_network_ids.json\" )  road_pricing.write_xml(xml_tree, output_path) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/4_2_using_network_road_pricing/#42-using-the-network-object-road-pricing","title":"4.2. Using the <code>Network</code> object: Road Pricing\u00b6","text":"<p>This page goes through the process of generating a road pricing MATSim file. Available as a jupyter notebook or wiki page.</p>"},{"location":"examples/4_2_using_network_road_pricing/#road-pricing","title":"Road Pricing\u00b6","text":"<p>Let's read an example MATSim network to work with.</p>"},{"location":"examples/4_3_using_network_routing/","title":"4.3. Using the object: Routing","text":"In\u00a0[1]: Copied! <pre>import os\nimport shutil\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> import os import shutil  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: MultiDiGraph with 1662 nodes and 3166 edges \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> In\u00a0[2]: Copied! <pre>from_node = \"101982\"\nto_node = \"101991\"\n</pre> from_node = \"101982\" to_node = \"101991\" <p>The following will use the whole graph disregarding modes.</p> In\u00a0[3]: Copied! <pre>n.find_shortest_path(from_node, to_node)\n</pre> n.find_shortest_path(from_node, to_node) Out[3]: <pre>['2030', '2453', '296', '3147', '3287']</pre> <p>The following will compute a modal subgraph and use it for routing. You can also pass a list e.g. <code>['bike', 'walk']</code>.</p> In\u00a0[4]: Copied! <pre>n.find_shortest_path(from_node, to_node, modes=\"car\")\n</pre> n.find_shortest_path(from_node, to_node, modes=\"car\") Out[4]: <pre>['2030', '2453', '296', '3147', '3287']</pre> <p>If you have many node pairs to process, it may be beneficial to compute the modal subgraph of interest first and pass that to the method.</p> In\u00a0[5]: Copied! <pre>car_g = n.modal_subgraph(\"car\")\nn.find_shortest_path(from_node, to_node, subgraph=car_g)\n</pre> car_g = n.modal_subgraph(\"car\") n.find_shortest_path(from_node, to_node, subgraph=car_g) Out[5]: <pre>['2030', '2453', '296', '3147', '3287']</pre> <p>Specifying <code>'modes'</code> on top of giving the <code>subgraph</code> will also use given modes for preferential treatment if there is ambiguity in which link should be chosen for the route (remember, there can be several links between the same two nodes). For example, if using mode <code>'bus'</code> and there are two links to choose from, one with modes: <code>['car', 'bus']</code> and the other with just <code>['bus']</code>, preference will be given to the link dedicated to that mode. Otherwise, preference will be given to links with higher <code>freespeed</code>.</p> In\u00a0[6]: Copied! <pre>n.find_shortest_path(from_node, to_node, subgraph=car_g, modes=[\"bus\"])\n</pre> n.find_shortest_path(from_node, to_node, subgraph=car_g, modes=[\"bus\"]) Out[6]: <pre>['2030', '2453', '296', '3147', '3287']</pre> <p>The anser is the same because this network does not have multiple bus only links.</p> <p>You can also choose to return the chain of nodes instead:</p> In\u00a0[7]: Copied! <pre>n.find_shortest_path(from_node, to_node, return_nodes=True)\n</pre> n.find_shortest_path(from_node, to_node, return_nodes=True) Out[7]: <pre>['101982', '1611082208', '2489433555', '25495406', '1514726033', '101991']</pre> <p>If you are looking to route a PT service in the <code>Network</code>'s <code>Schedule</code> you have a few methods to choose from.</p> <p>If the <code>Network</code> graph or the data on your graph has changed and you want to reroute a service that was previously snapped to the netowrk and routed you can use the <code>reroute</code> method. You can pass either a service or route ID, they should be unique and will be handled appropriately. You can specify <code>additional_modes</code>, e.g. <code>car</code> mode that will allow buses to use the links that allow the car mode as well as the route's own mode <code>bus</code>. Following this, the mode on the used links will be updated with the mode <code>bus</code>.</p> In\u00a0[8]: Copied! <pre>n.reroute(\"VJ375a660d47a2aa570aa20a8568012da8497ffecf\", additional_modes={\"car\"})\n</pre> n.reroute(\"VJ375a660d47a2aa570aa20a8568012da8497ffecf\", additional_modes={\"car\"}) <pre>2023-12-08 13:44:17,450 - Checking `linkRefId`s of the Route: `VJ375a660d47a2aa570aa20a8568012da8497ffecf` are present in the graph\n2023-12-08 13:44:17,451 - Rerouting Route `VJ375a660d47a2aa570aa20a8568012da8497ffecf`\n2023-12-08 13:44:17,492 - Changed Route attributes for 1 routes\n</pre> <p>It could happen that the snapping of a route or service is no longer valid after the changes, or you want to add something completely new. In this case you can use the <code>route_service</code> method which will find new links to snap and route the service on the network. You will need to have a solver set up, e.g. CBC. Again, you can specify <code>additional_modes</code> as in the method above. There are other parameters you can make use of, more details can be found in 5.2 which talks about modifying Schedules.</p> In\u00a0[9]: Copied! <pre>if shutil.which(\"cbc\"):\n    n.route_service(\"20274\", additional_modes={\"car\"})\nelse:\n    print(\"Cannot route service without a solver installed\")\n</pre> if shutil.which(\"cbc\"):     n.route_service(\"20274\", additional_modes={\"car\"}) else:     print(\"Cannot route service without a solver installed\") <pre>2023-12-08 13:44:18,258 - Routing Service 20274 with modes = {'bus'}\n2023-12-08 13:44:18,274 - Building Maximum Stable Set for PT graph with 8 stops and 6 edges\n2023-12-08 13:44:18,338 - Passing problem to solver\n2023-12-08 13:44:18,339 - Initializing ordered Set vertices with a fundamentally unordered data source (type: set).  This WILL potentially lead to nondeterministic behavior in Pyomo\n2023-12-08 13:44:18,343 - Passing problem to solver\n2023-12-08 13:44:18,838 - Stop ID changes detected for Routes: {'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e', 'VJ812fad65e7fa418645b57b446f00cba573f2cdaf', 'VJ375a660d47a2aa570aa20a8568012da8497ffecf'}\n2023-12-08 13:44:18,841 - Changed Route attributes for 3 routes\n2023-12-08 13:44:18,845 - Changed Link attributes for 41 links\n</pre> <p>If you are creating a <code>Network</code> and want to snap and route the entire <code>Schedule</code>, or a larger number of services, the method <code>route_schedule</code> is advised. Bear in mind though that it will struggle with large networks and big and complicated schedules. Similar parameters apply to this method as the one above, and a solver is needed to undertake the routing.</p> In\u00a0[10]: Copied! <pre>if shutil.which(\"cbc\"):\n    unsnapped_service_ids = n.route_schedule(services=[\"20274\", \"15660\"])\nelse:\n    print(\"Cannot route schedule without a solver installed\")\n</pre> if shutil.which(\"cbc\"):     unsnapped_service_ids = n.route_schedule(services=[\"20274\", \"15660\"]) else:     print(\"Cannot route schedule without a solver installed\") <pre>2023-12-08 13:44:18,854 - Building Spatial Tree\n2023-12-08 13:44:19,530 - Extracting Modal SubTree for modes: {'bus'}\n2023-12-08 13:44:19,544 - Routing Service 20274 with modes = {'bus'}\n2023-12-08 13:44:19,545 - Building Maximum Stable Set for PT graph with 8 stops and 6 edges\n2023-12-08 13:44:19,589 - Passing problem to solver\n2023-12-08 13:44:19,590 - Initializing ordered Set vertices with a fundamentally unordered data source (type: set).  This WILL potentially lead to nondeterministic behavior in Pyomo\n2023-12-08 13:44:19,592 - Passing problem to solver\n2023-12-08 13:44:19,696 - Routing Service 15660 with modes = {'bus'}\n2023-12-08 13:44:19,698 - Building Maximum Stable Set for PT graph with 5 stops and 3 edges\n2023-12-08 13:44:19,753 - This Maximum Stable Set Problem is partially viable.\n2023-12-08 13:44:19,754 - Maximum Stable Set problem to snap the PT graph to the network is partially viable, meaning not all stops have found a link to snap to within the distance_threshold.Partial snapping is ON, this problem will proceed to the solver.\n2023-12-08 13:44:19,754 - Passing problem to solver\n2023-12-08 13:44:19,755 - Initializing ordered Set vertices with a fundamentally unordered data source (type: set).  This WILL potentially lead to nondeterministic behavior in Pyomo\n2023-12-08 13:44:19,756 - Passing problem to solver\n2023-12-08 13:44:19,821 - Successfully snapped 4 stops to network links.\n2023-12-08 13:44:19,830 - Stop ID changes detected for Routes: {'VJf2e0de4f5dad68cb03064e6064e372dde52cc678', 'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e', 'VJ812fad65e7fa418645b57b446f00cba573f2cdaf', 'VJ375a660d47a2aa570aa20a8568012da8497ffecf', 'VJ3716910ec59c370d9f5c69137df7276b68cf0a08', 'VJ1cf651142378958b52229bfe1fa552e49136e60e'}\n2023-12-08 13:44:19,834 - Changed Route attributes for 6 routes\n2023-12-08 13:44:19,838 - Added 1 nodes\n2023-12-08 13:44:19,900 - Generated 0 link ids.\n2023-12-08 13:44:19,903 - Added 2 links\n2023-12-08 13:44:19,907 - Changed Link attributes for 53 links\n</pre> <p>Some services may fail to snap. Method above returns IDs of the services which failed. It is worth re-running these, with the same or different parameters. Failing that, a service can also be teleported using the following method. If the stops are already snapped (i.e. have a <code>linkRefId</code>), those links will still be used as references, unless the link is no longer in the network.</p> In\u00a0[11]: Copied! <pre>n.teleport_service(service_ids=\"17732\")\n</pre> n.teleport_service(service_ids=\"17732\") <pre>2023-12-08 13:44:19,925 - Added 0 nodes\n2023-12-08 13:44:19,969 - Generated 0 link ids.\n2023-12-08 13:44:19,973 - Added 8 links\n2023-12-08 13:44:19,975 - Changed Stop attributes for 10 stops\n2023-12-08 13:44:19,977 - Changed Route attributes for 2 routes\n</pre> In\u00a0[12]: Copied! <pre>n.schedule.stop(\"490004695A.link:3017\").print()\n</pre> n.schedule.stop(\"490004695A.link:3017\").print() <pre>Stop ID: 490004695A.link:3017\nProjection: epsg:27700\nLat, Lon: 51.51433903, -0.12977799\nlinkRefId: 3017\n</pre> In\u00a0[13]: Copied! <pre>list(n.schedule[\"17732\"].routes())[0].ordered_stops\n</pre> list(n.schedule[\"17732\"].routes())[0].ordered_stops Out[13]: <pre>['490004695A.link:3017',\n '490000235C.link:3068',\n '490000089A.link:823',\n '490000252X.link:86',\n '490000078Q.link:1239']</pre> In\u00a0[14]: Copied! <pre>list(n.schedule[\"17732\"].routes())[0].network_links\n</pre> list(n.schedule[\"17732\"].routes())[0].network_links Out[14]: <pre>['3017',\n 'artificial_link===from:21665081===to:5434424322',\n '3068',\n 'artificial_link===from:3519133221===to:108045',\n '823',\n 'artificial_link===from:3079462268===to:4543005956',\n '86',\n 'artificial_link===from:25714232===to:4543005959',\n '1239']</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/4_3_using_network_routing/#43-using-the-network-object-routing","title":"4.3. Using the <code>Network</code> object: Routing\u00b6","text":"<p>This page goes through GeNet's capability in routing on the Network graph. Available as a jupyter notebook or wiki page.</p> <p>You can find shortest path between two nodes in the graph, using a modal subgraph or otherwise.</p>"},{"location":"examples/4_4_using_network_auxiliary_files_referencing_network_ids/","title":"4.4. Using the object: Auxiliary files","text":"In\u00a0[1]: Copied! <pre>import json\nimport os\n\nimport pandas as pd\n\n\ndef read_json_file(path):\n    with open(path) as json_file:\n        return json.load(json_file)\n\n\ndef read_csv_file(path):\n    return pd.read_csv(path)\n</pre> import json import os  import pandas as pd   def read_json_file(path):     with open(path) as json_file:         return json.load(json_file)   def read_csv_file(path):     return pd.read_csv(path) <p>Let's show a couple of examples.</p> In\u00a0[2]: Copied! <pre>example_json = os.path.join(\"..\", \"tests\", \"test_data\", \"auxiliary_files\", \"links_benchmark.json\")\nexample_csv = os.path.join(\"..\", \"tests\", \"test_data\", \"auxiliary_files\", \"links_benchmark.csv\")\n</pre> example_json = os.path.join(\"..\", \"tests\", \"test_data\", \"auxiliary_files\", \"links_benchmark.json\") example_csv = os.path.join(\"..\", \"tests\", \"test_data\", \"auxiliary_files\", \"links_benchmark.csv\") In\u00a0[3]: Copied! <pre>read_json_file(example_json)\n</pre> read_json_file(example_json) Out[3]: <pre>{'car': {'1': {'in': {'links': ['0'],\n    'counts': {'0': 78.0,\n     '1': 46.0,\n     '2': 39.0,\n     '3': 45.0,\n     '4': 72.0,\n     '5': 188.0,\n     '6': 475.0,\n     '7': 734.0,\n     '8': 651.0,\n     '9': 605.0,\n     '10': 605.0,\n     '11': 625.0,\n     '12': 569.0,\n     '13': 632.0,\n     '14': 586.0,\n     '15': 585.0,\n     '16': 825.0,\n     '17': 756.0,\n     '18': 711.0,\n     '19': 597.0,\n     '20': 405.0,\n     '21': 285.0,\n     '22': 218.0,\n     '23': 136.0}},\n   'out': {'links': ['1'],\n    'counts': {'0': 76.0,\n     '1': 45.0,\n     '2': 40.0,\n     '3': 38.0,\n     '4': 63.0,\n     '5': 165.0,\n     '6': 608.0,\n     '7': 858.0,\n     '8': 725.0,\n     '9': 514.0,\n     '10': 415.0,\n     '11': 485.0,\n     '12': 554.0,\n     '13': 463.0,\n     '14': 589.0,\n     '15': 616.0,\n     '16': 835.0,\n     '17': 901.0,\n     '18': 704.0,\n     '19': 476.0,\n     '20': 355.0,\n     '21': 283.0,\n     '22': 219.0,\n     '23': 134.0}}},\n  '2': {'in': {'links': ['2'],\n    'counts': {'0': 92.0,\n     '1': 57.0,\n     '2': 53.0,\n     '3': 55.0,\n     '4': 88.0,\n     '5': 222.0,\n     '6': 637.0,\n     '7': 1146.0,\n     '8': 1017.0,\n     '9': 691.0,\n     '10': 578.0,\n     '11': 519.0,\n     '12': 540.0,\n     '13': 615.0,\n     '14': 619.0,\n     '15': 630.0,\n     '16': 828.0,\n     '17': 913.0,\n     '18': 890.0,\n     '19': 629.0,\n     '20': 326.0,\n     '21': 315.0,\n     '22': 252.0,\n     '23': 159.0}},\n   'out': {'links': ['3', '4'],\n    'counts': {'0': 81.0,\n     '1': 53.0,\n     '2': 47.0,\n     '3': 45.0,\n     '4': 77.0,\n     '5': 182.0,\n     '6': 385.0,\n     '7': 721.0,\n     '8': 592.0,\n     '9': 487.0,\n     '10': 488.0,\n     '11': 514.0,\n     '12': 498.0,\n     '13': 659.0,\n     '14': 749.0,\n     '15': 786.0,\n     '16': 1009.0,\n     '17': 908.0,\n     '18': 845.0,\n     '19': 578.0,\n     '20': 370.0,\n     '21': 273.0,\n     '22': 230.0,\n     '23': 137.0}}}},\n 'bus': {'1': {'in': {'links': ['0'],\n    'counts': {'0': 78.0,\n     '1': 46.0,\n     '2': 39.0,\n     '3': 45.0,\n     '4': 72.0,\n     '5': 188.0,\n     '6': 475.0,\n     '7': 734.0,\n     '8': 651.0,\n     '9': 605.0,\n     '10': 605.0,\n     '11': 625.0,\n     '12': 569.0,\n     '13': 632.0,\n     '14': 586.0,\n     '15': 585.0,\n     '16': 825.0,\n     '17': 756.0,\n     '18': 711.0,\n     '19': 597.0,\n     '20': 405.0,\n     '21': 285.0,\n     '22': 218.0,\n     '23': 136.0}},\n   'out': {'links': ['1'],\n    'counts': {'0': 76.0,\n     '1': 45.0,\n     '2': 40.0,\n     '3': 38.0,\n     '4': 63.0,\n     '5': 165.0,\n     '6': 608.0,\n     '7': 858.0,\n     '8': 725.0,\n     '9': 514.0,\n     '10': 415.0,\n     '11': 485.0,\n     '12': 554.0,\n     '13': 463.0,\n     '14': 589.0,\n     '15': 616.0,\n     '16': 835.0,\n     '17': 901.0,\n     '18': 704.0,\n     '19': 476.0,\n     '20': 355.0,\n     '21': 283.0,\n     '22': 219.0,\n     '23': 134.0}}},\n  '2': {'in': {'links': ['2'],\n    'counts': {'0': 92.0,\n     '1': 57.0,\n     '2': 53.0,\n     '3': 55.0,\n     '4': 88.0,\n     '5': 222.0,\n     '6': 637.0,\n     '7': 1146.0,\n     '8': 1017.0,\n     '9': 691.0,\n     '10': 578.0,\n     '11': 519.0,\n     '12': 540.0,\n     '13': 615.0,\n     '14': 619.0,\n     '15': 630.0,\n     '16': 828.0,\n     '17': 913.0,\n     '18': 890.0,\n     '19': 629.0,\n     '20': 326.0,\n     '21': 315.0,\n     '22': 252.0,\n     '23': 159.0}},\n   'out': {'links': ['3', '4'],\n    'counts': {'0': 81.0,\n     '1': 53.0,\n     '2': 47.0,\n     '3': 45.0,\n     '4': 77.0,\n     '5': 182.0,\n     '6': 385.0,\n     '7': 721.0,\n     '8': 592.0,\n     '9': 487.0,\n     '10': 488.0,\n     '11': 514.0,\n     '12': 498.0,\n     '13': 659.0,\n     '14': 749.0,\n     '15': 786.0,\n     '16': 1009.0,\n     '17': 908.0,\n     '18': 845.0,\n     '19': 578.0,\n     '20': 370.0,\n     '21': 273.0,\n     '22': 230.0,\n     '23': 137.0}}}}}</pre> In\u00a0[4]: Copied! <pre>read_csv_file(example_csv)\n</pre> read_csv_file(example_csv) Out[4]: id direction latitude longitude osm_id links other_links 0 L001 north 51.445503 -0.234686 19074660 ['1'] '5' 1 L001 south 51.445503 -0.234686 19074660 ['2'] '6' 2 L002 east 51.444698 -0.233398 142592756 ['3'] '7' 3 L002 west 51.444698 -0.233398 132778373 ['4'] '8' <p>We can attach them to a <code>Network</code> object using dedicated methods. Each file needs to pertain only to one set of IDs, either node or link IDs and the relevant method should be used to read the file.</p> In\u00a0[5]: Copied! <pre>from genet import Network\n\nn = Network(\"epsg:27700\")\nn.add_nodes(\n    {\n        \"1\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},\n        \"2\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},\n        \"3\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},\n        \"4\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},\n    }\n)\nn.add_links(\n    {\n        \"1\": {\n            \"from\": \"1\",\n            \"to\": \"2\",\n            \"freespeed\": 1,\n            \"capacity\": 1,\n            \"permlanes\": 1,\n            \"length\": 1,\n            \"modes\": {\"car\"},\n        },\n        \"2\": {\n            \"from\": \"1\",\n            \"to\": \"3\",\n            \"freespeed\": 1,\n            \"capacity\": 1,\n            \"permlanes\": 1,\n            \"length\": 1,\n            \"modes\": {\"car\"},\n        },\n        \"3\": {\n            \"from\": \"2\",\n            \"to\": \"4\",\n            \"freespeed\": 1,\n            \"capacity\": 1,\n            \"permlanes\": 1,\n            \"length\": 1,\n            \"modes\": {\"car\"},\n        },\n        \"4\": {\n            \"from\": \"3\",\n            \"to\": \"4\",\n            \"freespeed\": 1,\n            \"capacity\": 1,\n            \"permlanes\": 1,\n            \"length\": 1,\n            \"modes\": {\"car\"},\n        },\n    }\n)\nn.read_auxiliary_link_file(example_json)\nn.read_auxiliary_node_file(example_csv)\n</pre> from genet import Network  n = Network(\"epsg:27700\") n.add_nodes(     {         \"1\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},         \"2\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},         \"3\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},         \"4\": {\"x\": 1, \"y\": 2, \"s2_id\": 0},     } ) n.add_links(     {         \"1\": {             \"from\": \"1\",             \"to\": \"2\",             \"freespeed\": 1,             \"capacity\": 1,             \"permlanes\": 1,             \"length\": 1,             \"modes\": {\"car\"},         },         \"2\": {             \"from\": \"1\",             \"to\": \"3\",             \"freespeed\": 1,             \"capacity\": 1,             \"permlanes\": 1,             \"length\": 1,             \"modes\": {\"car\"},         },         \"3\": {             \"from\": \"2\",             \"to\": \"4\",             \"freespeed\": 1,             \"capacity\": 1,             \"permlanes\": 1,             \"length\": 1,             \"modes\": {\"car\"},         },         \"4\": {             \"from\": \"3\",             \"to\": \"4\",             \"freespeed\": 1,             \"capacity\": 1,             \"permlanes\": 1,             \"length\": 1,             \"modes\": {\"car\"},         },     } ) n.read_auxiliary_link_file(example_json) n.read_auxiliary_node_file(example_csv) <pre>2022-07-14 15:41:18,911 - Added 4 nodes\n2022-07-14 15:41:18,921 - Added 4 links\n</pre> <p>Auxiliary files will record where within the file the node or link ID data is stored and use it later for updating.</p> In\u00a0[6]: Copied! <pre>n.auxiliary_files[\"node\"][\"links_benchmark.csv\"].attachments\n</pre> n.auxiliary_files[\"node\"][\"links_benchmark.csv\"].attachments Out[6]: <pre>['links']</pre> In\u00a0[7]: Copied! <pre>n.auxiliary_files[\"link\"][\"links_benchmark.json\"].attachments\n</pre> n.auxiliary_files[\"link\"][\"links_benchmark.json\"].attachments Out[7]: <pre>[{'car': {'1': {'out': 'links'}}},\n {'car': {'2': {'in': 'links'}}},\n {'car': {'2': {'out': 'links'}}},\n {'bus': {'1': {'out': 'links'}}},\n {'bus': {'2': {'in': 'links'}}},\n {'bus': {'2': {'out': 'links'}}}]</pre> <p>Now we can use methods to change the Network. The changes will be recorded and applied to the files when we save the network.</p> In\u00a0[8]: Copied! <pre>n.simplify()\n</pre> n.simplify() <pre>2022-07-14 15:41:18,960 - Begin simplifying the graph\n2022-07-14 15:41:18,962 - Generating paths to be simplified\n2022-07-14 15:41:18,963 - Identified 2 edge endpoints\n2022-07-14 15:41:18,964 - Identified 2 possible paths\n2022-07-14 15:41:18,965 - Processing 2 paths\n2022-07-14 15:41:18,966 - Found 2 paths to simplify.\n2022-07-14 15:41:18,967 - Generated 2 link ids.\n2022-07-14 15:41:18,967 - Processing links for all paths to be simplified\n2022-07-14 15:41:18,969 - Adding new simplified links\n2022-07-14 15:41:18,983 - Added 2 links\n2022-07-14 15:41:18,986 - Simplified graph: 4 to 2 nodes, 4 to 2 edges\n</pre> In\u00a0[9]: Copied! <pre>n.attributes\n</pre> n.attributes Out[9]: <pre>{'crs': 'epsg:27700', 'simplified': True}</pre> In\u00a0[10]: Copied! <pre>n.write_to_matsim(os.path.join(\"example_data\", \"outputs\"))\n</pre> n.write_to_matsim(os.path.join(\"example_data\", \"outputs\")) <pre>2022-07-14 15:41:19,006 - Writing ../genet_output/network.xml\n2022-07-14 15:41:19,015 - Saving auxiliary file links_benchmark.json in ../genet_output/auxiliary_files\n2022-07-14 15:41:19,019 - Saving auxiliary file links_benchmark.csv in ../genet_output/auxiliary_files\n</pre> In\u00a0[11]: Copied! <pre>read_json_file(os.path.join(\"example_data\", \"outputs\", \"auxiliary_files\", \"links_benchmark.json\"))\n</pre> read_json_file(os.path.join(\"example_data\", \"outputs\", \"auxiliary_files\", \"links_benchmark.json\")) Out[11]: <pre>{'car': {'1': {'in': {'links': ['0'],\n    'counts': {'0': 78.0,\n     '1': 46.0,\n     '2': 39.0,\n     '3': 45.0,\n     '4': 72.0,\n     '5': 188.0,\n     '6': 475.0,\n     '7': 734.0,\n     '8': 651.0,\n     '9': 605.0,\n     '10': 605.0,\n     '11': 625.0,\n     '12': 569.0,\n     '13': 632.0,\n     '14': 586.0,\n     '15': 585.0,\n     '16': 825.0,\n     '17': 756.0,\n     '18': 711.0,\n     '19': 597.0,\n     '20': 405.0,\n     '21': 285.0,\n     '22': 218.0,\n     '23': 136.0}},\n   'out': {'links': ['5'],\n    'counts': {'0': 76.0,\n     '1': 45.0,\n     '2': 40.0,\n     '3': 38.0,\n     '4': 63.0,\n     '5': 165.0,\n     '6': 608.0,\n     '7': 858.0,\n     '8': 725.0,\n     '9': 514.0,\n     '10': 415.0,\n     '11': 485.0,\n     '12': 554.0,\n     '13': 463.0,\n     '14': 589.0,\n     '15': 616.0,\n     '16': 835.0,\n     '17': 901.0,\n     '18': 704.0,\n     '19': 476.0,\n     '20': 355.0,\n     '21': 283.0,\n     '22': 219.0,\n     '23': 134.0}}},\n  '2': {'in': {'links': ['0'],\n    'counts': {'0': 92.0,\n     '1': 57.0,\n     '2': 53.0,\n     '3': 55.0,\n     '4': 88.0,\n     '5': 222.0,\n     '6': 637.0,\n     '7': 1146.0,\n     '8': 1017.0,\n     '9': 691.0,\n     '10': 578.0,\n     '11': 519.0,\n     '12': 540.0,\n     '13': 615.0,\n     '14': 619.0,\n     '15': 630.0,\n     '16': 828.0,\n     '17': 913.0,\n     '18': 890.0,\n     '19': 629.0,\n     '20': 326.0,\n     '21': 315.0,\n     '22': 252.0,\n     '23': 159.0}},\n   'out': {'links': ['5', '0'],\n    'counts': {'0': 81.0,\n     '1': 53.0,\n     '2': 47.0,\n     '3': 45.0,\n     '4': 77.0,\n     '5': 182.0,\n     '6': 385.0,\n     '7': 721.0,\n     '8': 592.0,\n     '9': 487.0,\n     '10': 488.0,\n     '11': 514.0,\n     '12': 498.0,\n     '13': 659.0,\n     '14': 749.0,\n     '15': 786.0,\n     '16': 1009.0,\n     '17': 908.0,\n     '18': 845.0,\n     '19': 578.0,\n     '20': 370.0,\n     '21': 273.0,\n     '22': 230.0,\n     '23': 137.0}}}},\n 'bus': {'1': {'in': {'links': ['0'],\n    'counts': {'0': 78.0,\n     '1': 46.0,\n     '2': 39.0,\n     '3': 45.0,\n     '4': 72.0,\n     '5': 188.0,\n     '6': 475.0,\n     '7': 734.0,\n     '8': 651.0,\n     '9': 605.0,\n     '10': 605.0,\n     '11': 625.0,\n     '12': 569.0,\n     '13': 632.0,\n     '14': 586.0,\n     '15': 585.0,\n     '16': 825.0,\n     '17': 756.0,\n     '18': 711.0,\n     '19': 597.0,\n     '20': 405.0,\n     '21': 285.0,\n     '22': 218.0,\n     '23': 136.0}},\n   'out': {'links': ['5'],\n    'counts': {'0': 76.0,\n     '1': 45.0,\n     '2': 40.0,\n     '3': 38.0,\n     '4': 63.0,\n     '5': 165.0,\n     '6': 608.0,\n     '7': 858.0,\n     '8': 725.0,\n     '9': 514.0,\n     '10': 415.0,\n     '11': 485.0,\n     '12': 554.0,\n     '13': 463.0,\n     '14': 589.0,\n     '15': 616.0,\n     '16': 835.0,\n     '17': 901.0,\n     '18': 704.0,\n     '19': 476.0,\n     '20': 355.0,\n     '21': 283.0,\n     '22': 219.0,\n     '23': 134.0}}},\n  '2': {'in': {'links': ['0'],\n    'counts': {'0': 92.0,\n     '1': 57.0,\n     '2': 53.0,\n     '3': 55.0,\n     '4': 88.0,\n     '5': 222.0,\n     '6': 637.0,\n     '7': 1146.0,\n     '8': 1017.0,\n     '9': 691.0,\n     '10': 578.0,\n     '11': 519.0,\n     '12': 540.0,\n     '13': 615.0,\n     '14': 619.0,\n     '15': 630.0,\n     '16': 828.0,\n     '17': 913.0,\n     '18': 890.0,\n     '19': 629.0,\n     '20': 326.0,\n     '21': 315.0,\n     '22': 252.0,\n     '23': 159.0}},\n   'out': {'links': ['5', '0'],\n    'counts': {'0': 81.0,\n     '1': 53.0,\n     '2': 47.0,\n     '3': 45.0,\n     '4': 77.0,\n     '5': 182.0,\n     '6': 385.0,\n     '7': 721.0,\n     '8': 592.0,\n     '9': 487.0,\n     '10': 488.0,\n     '11': 514.0,\n     '12': 498.0,\n     '13': 659.0,\n     '14': 749.0,\n     '15': 786.0,\n     '16': 1009.0,\n     '17': 908.0,\n     '18': 845.0,\n     '19': 578.0,\n     '20': 370.0,\n     '21': 273.0,\n     '22': 230.0,\n     '23': 137.0}}}}}</pre> In\u00a0[12]: Copied! <pre>read_csv_file(os.path.join(\"example_data\", \"outputs\", \"auxiliary_files\", \"links_benchmark.csv\"))\n</pre> read_csv_file(os.path.join(\"example_data\", \"outputs\", \"auxiliary_files\", \"links_benchmark.csv\")) Out[12]: Unnamed: 0 id direction latitude longitude osm_id links other_links 0 0 L001 north 51.445503 -0.234686 19074660 ['1'] 5 1 1 L001 south 51.445503 -0.234686 19074660 [None] 6 2 2 L002 east 51.444698 -0.233398 142592756 [None] 7 3 3 L002 west 51.444698 -0.233398 132778373 ['4'] 8"},{"location":"examples/4_4_using_network_auxiliary_files_referencing_network_ids/#44-using-the-network-object-auxiliary-files","title":"4.4. Using the <code>Network</code> object: Auxiliary files\u00b6","text":"<p>GeNet supports reading in files in JSON and CSV formats which reference <code>Network</code> link or node IDs. Each file needs to reference only links or nodes, not both, in case there is overlap in IDs between nodes and links.</p> <p>An <code>AuxiliaryFile</code> attaches itself to the Network IDs, finding where the overlap in IDs is with the set of IDs stored in the network. A map is kept within the <code>AuxiliaryFile</code> object during a GeNet session, if using GeNet's own modification methods. The updates are applied right before saving the Network to file or when <code>update</code> method on the <code>AuxiliaryFile</code> is called.</p> <p>Some processes which will result in ID changes are:</p> <ul> <li>node or link reindexing</li> <li>network simplification</li> </ul> <p>And those which will result in data loss:</p> <ul> <li>node or link removal</li> </ul> <p>Some examples of auxiliary files:</p> <ul> <li>benchmarks snaped to the network</li> <li>road pricing csv snapped to the network</li> </ul> <p>Right now, GeNet supports two types of auxiliary files:</p> <ul> <li>CSV: table with single level indexing. The IDs can be nested in lists</li> <li>JSON: any level of nestedness is allowed, the IDs can live singularly or within lists</li> </ul>"},{"location":"examples/5_1_modifying_network_graph/","title":"5.1. Modifying the object: Graph","text":"In\u00a0[1]: Copied! <pre># read example network\nimport os\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> # read example network import os  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> In\u00a0[2]: Copied! <pre>n.add_link(link_id=\"proposed_index\", u=\"4356572310\", v=\"5811263955\")\n</pre> n.add_link(link_id=\"proposed_index\", u=\"4356572310\", v=\"5811263955\") <pre>2022-11-03 18:53:15,024 - Added Link with index proposed_index, from node:4356572310 to node:5811263955, under multi-index:1, and data={'from': '4356572310', 'to': '5811263955', 'id': 'proposed_index'}\n</pre> Out[2]: <pre>'proposed_index'</pre> In\u00a0[3]: Copied! <pre>n.add_node(node=\"proposed_index\", attribs={\"x\": 1, \"y\": 1, \"data\": \"some_data\"})\n</pre> n.add_node(node=\"proposed_index\", attribs={\"x\": 1, \"y\": 1, \"data\": \"some_data\"}) <pre>2022-11-03 18:53:15,177 - Added 1 nodes\n</pre> Out[3]: <pre>{}</pre> <p>The index passed is only a proposition. If a node or link under this link exists, a new, unique index will be generated.</p> In\u00a0[4]: Copied! <pre>actual_link_id_added = n.add_link(link_id=\"proposed_index\", u=\"4356572310\", v=\"5811263955\")\n</pre> actual_link_id_added = n.add_link(link_id=\"proposed_index\", u=\"4356572310\", v=\"5811263955\") <pre>2022-11-03 18:53:15,391 - Generated 1 link ids.\n2022-11-03 18:53:15,396 - Generated link id 0.\n2022-11-03 18:53:15,403 - `proposed_index` already exists. Generated a new unique_index: `0`\n2022-11-03 18:53:15,418 - Added Link with index 0, from node:4356572310 to node:5811263955, under multi-index:2, and data={'from': '4356572310', 'to': '5811263955', 'id': '0'}\n</pre> In\u00a0[5]: Copied! <pre>n.reindex_node(\"proposed_index\", \"another_index\")\n</pre> n.reindex_node(\"proposed_index\", \"another_index\") <pre>2022-11-03 18:53:15,514 - Changed Link attributes for 0 links\n2022-11-03 18:53:15,617 - Changed Link attributes for 0 links\n2022-11-03 18:53:15,630 - Changed Node attributes under index: proposed_index\n2022-11-03 18:53:16,151 - Changed Node index from proposed_index to another_index\n</pre> In\u00a0[6]: Copied! <pre>n.reindex_link(\"proposed_index\", \"another_index\")\n</pre> n.reindex_link(\"proposed_index\", \"another_index\") <pre>2022-11-03 18:53:16,234 - Changed Link attributes under index: proposed_index\n2022-11-03 18:53:16,262 - Changed Link index from proposed_index to another_index\n</pre> In\u00a0[7]: Copied! <pre>n.remove_links([\"another_index\", actual_link_id_added])\n</pre> n.remove_links([\"another_index\", actual_link_id_added]) <pre>2022-11-03 18:53:16,306 - Removed 2 links\n</pre> In\u00a0[8]: Copied! <pre>n.remove_node(\"another_index\")\n</pre> n.remove_node(\"another_index\") <pre>2022-11-03 18:53:16,346 - Removed Node under index: another_index\n</pre> In\u00a0[9]: Copied! <pre>links = n.extract_links_on_edge_attributes(\n    conditions={\"attributes\": {\"osm:way:highway\": \"primary\"}}\n)\n\nlinks[:5]\n</pre> links = n.extract_links_on_edge_attributes(     conditions={\"attributes\": {\"osm:way:highway\": \"primary\"}} )  links[:5] Out[9]: <pre>['1007', '1008', '1023', '1024', '103']</pre> In\u00a0[10]: Copied! <pre>n.link(links[0])\n</pre> n.link(links[0]) Out[10]: <pre>{'id': '1007',\n 'from': '4356572310',\n 'to': '5811263955',\n 'freespeed': 22.22222222222222,\n 'capacity': 3000.0,\n 'permlanes': 2.0,\n 'oneway': '1',\n 'modes': {'car'},\n 's2_from': 5221390723045407809,\n 's2_to': 5221390723040504387,\n 'attributes': {'osm:way:highway': 'primary',\n  'osm:way:id': 589660342.0,\n  'osm:way:lanes': '2',\n  'osm:way:name': 'Shaftesbury Avenue',\n  'osm:way:oneway': 'yes'},\n 'length': 13.941905154249884}</pre> <p>We create a dictionary which maps same changes to all links in the list using:</p> <pre>    {link_id: {'attributes': {'osm:way:highway': 'SOMETHING'}} for link_id in links}\n</pre> In\u00a0[11]: Copied! <pre>n.apply_attributes_to_links(\n    {link_id: {\"attributes\": {\"osm:way:highway\": \"SOMETHING\"}} for link_id in links}\n)\n</pre> n.apply_attributes_to_links(     {link_id: {\"attributes\": {\"osm:way:highway\": \"SOMETHING\"}} for link_id in links} ) <pre>2022-11-03 18:53:17,103 - Changed Link attributes for 619 links\n</pre> In\u00a0[12]: Copied! <pre>n.link(links[0])\n</pre> n.link(links[0]) Out[12]: <pre>{'id': '1007',\n 'from': '4356572310',\n 'to': '5811263955',\n 'freespeed': 22.22222222222222,\n 'capacity': 3000.0,\n 'permlanes': 2.0,\n 'oneway': '1',\n 'modes': {'car'},\n 's2_from': 5221390723045407809,\n 's2_to': 5221390723040504387,\n 'attributes': {'osm:way:highway': 'SOMETHING',\n  'osm:way:id': 589660342.0,\n  'osm:way:lanes': '2',\n  'osm:way:name': 'Shaftesbury Avenue',\n  'osm:way:oneway': 'yes'},\n 'length': 13.941905154249884}</pre> In\u00a0[13]: Copied! <pre>n.change_log.head()\n</pre> n.change_log.head() Out[13]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 0 2022-11-03 18:53:15 add link None proposed_index None {'from': '4356572310', 'to': '5811263955', 'id... [(add, , [('from', '4356572310'), ('to', '5811... 1 2022-11-03 18:53:15 add node None proposed_index None {'x': 1, 'y': 1, 'lon': -7.557147012910978, 'l... [(add, , [('x', 1), ('y', 1), ('lon', -7.55714... 2 2022-11-03 18:53:15 add link None 0 None {'from': '4356572310', 'to': '5811263955', 'id... [(add, , [('from', '4356572310'), ('to', '5811... 3 2022-11-03 18:53:15 modify node proposed_index another_index {'x': 1, 'y': 1, 'lon': -7.557147012910978, 'l... {'x': 1, 'y': 1, 'lon': -7.557147012910978, 'l... [(change, id, (proposed_index, another_index))... 4 2022-11-03 18:53:15 modify node proposed_index proposed_index {'x': 1, 'y': 1, 'lon': -7.557147012910978, 'l... {'x': 1, 'y': 1, 'lon': -7.557147012910978, 'l... [(change, id, (proposed_index, another_index))] In\u00a0[14]: Copied! <pre>n.change_log.loc[618, :][\"old_attributes\"]\n</pre> n.change_log.loc[618, :][\"old_attributes\"] Out[14]: <pre>\"{'id': '959', 'from': '300501141', 'to': '294158420', 'freespeed': 22.22222222222222, 'capacity': 1500.0, 'permlanes': 1.0, 'oneway': '1', 'modes': {'car'}, 's2_from': 5221390337863745429, 's2_to': 5221390337351379383, 'attributes': {'osm:relation:route': 'bus', 'osm:way:highway': 'primary', 'osm:way:id': 26785612.0, 'osm:way:name': 'Albany Street'}, 'length': 90.65828423645875}\"</pre> In\u00a0[15]: Copied! <pre>n.change_log.loc[618, :][\"new_attributes\"]\n</pre> n.change_log.loc[618, :][\"new_attributes\"] Out[15]: <pre>\"{'id': '959', 'from': '300501141', 'to': '294158420', 'freespeed': 22.22222222222222, 'capacity': 1500.0, 'permlanes': 1.0, 'oneway': '1', 'modes': {'car'}, 's2_from': 5221390337863745429, 's2_to': 5221390337351379383, 'attributes': {'osm:relation:route': 'bus', 'osm:way:highway': 'SOMETHING', 'osm:way:id': 26785612.0, 'osm:way:name': 'Albany Street'}, 'length': 90.65828423645875}\"</pre> In\u00a0[16]: Copied! <pre>n.change_log.loc[618, :][\"diff\"]\n</pre> n.change_log.loc[618, :][\"diff\"] Out[16]: <pre>[('change', 'attributes.osm:way:highway', ('primary', 'SOMETHING'))]</pre> <p>Another useful method is the <code>apply_function_to_links</code>/<code>nodes</code>. This function takes a user-defined function with the variable that is the data dictionary stored on the links or nodes respectively. This function does not support <code>conditions</code>, but this is something that can be encoded in you function, for example:</p> In\u00a0[17]: Copied! <pre>def divide_capacity(link_attributes):\n    if \"car\" in link_attributes[\"modes\"]:\n        return link_attributes[\"capacity\"] / link_attributes[\"permlanes\"]\n\n\nn.apply_function_to_links(divide_capacity, \"base_capacity\")\n</pre> def divide_capacity(link_attributes):     if \"car\" in link_attributes[\"modes\"]:         return link_attributes[\"capacity\"] / link_attributes[\"permlanes\"]   n.apply_function_to_links(divide_capacity, \"base_capacity\") <pre>2022-11-03 18:53:18,497 - Changed Link attributes for 3166 links\n</pre> <p>This method will apply results of this function to links for which a value can be computed. For use here, that means that for any link which has a <code>'car'</code> value in <code>'modes'</code> a value of capacity divided by the number of lanes will be computed. We specify that the results will be stored under <code>base_capacity</code> in the links attribute dictionary.</p> In\u00a0[18]: Copied! <pre>n.link(links[0])\n</pre> n.link(links[0]) Out[18]: <pre>{'id': '1007',\n 'from': '4356572310',\n 'to': '5811263955',\n 'freespeed': 22.22222222222222,\n 'capacity': 3000.0,\n 'permlanes': 2.0,\n 'oneway': '1',\n 'modes': {'car'},\n 's2_from': 5221390723045407809,\n 's2_to': 5221390723040504387,\n 'attributes': {'osm:way:highway': 'SOMETHING',\n  'osm:way:id': 589660342.0,\n  'osm:way:lanes': '2',\n  'osm:way:name': 'Shaftesbury Avenue',\n  'osm:way:oneway': 'yes'},\n 'length': 13.941905154249884,\n 'base_capacity': 1500.0}</pre> In\u00a0[19]: Copied! <pre>n.link(\"3283\")\n</pre> n.link(\"3283\") Out[19]: <pre>{'id': '3283',\n 'from': '5183504114',\n 'to': '2100667093',\n 'freespeed': 4.166666666666667,\n 'capacity': 600.0,\n 'permlanes': 1.0,\n 'oneway': '1',\n 'modes': {'car'},\n 's2_from': 5221390345346257215,\n 's2_to': 5221390252517831471,\n 'attributes': {'osm:way:access': 'permissive',\n  'osm:way:highway': 'unclassified',\n  'osm:way:id': 5228769.0,\n  'osm:way:name': 'Inner Circle',\n  'osm:way:psv': 'destination'},\n 'length': 690.3981958395409,\n 'base_capacity': 600.0}</pre> In\u00a0[20]: Copied! <pre>data = n.split_link_at_point(\"3283\", x=528241.91, y=182530.95)\n</pre> data = n.split_link_at_point(\"3283\", x=528241.91, y=182530.95) <pre>2022-11-03 18:53:18,760 - Generated node id 6985267189.\n2022-11-03 18:53:18,796 - Added 1 nodes\n2022-11-03 18:53:18,798 - Generated 2 link ids.\n2022-11-03 18:53:18,832 - Given point is very close, but not cannot be placed on the line. We move it slightly and the resulting split may not be exact.\n2022-11-03 18:53:19,323 - Generated 0 link ids.\n2022-11-03 18:53:19,334 - Added 2 links\n2022-11-03 18:53:19,338 - Removed link under index: 3283\n2022-11-03 18:53:19,344 - Updating network routes in the PT schedule.\n2022-11-03 18:53:19,349 - No PT routes were affected by this change\n</pre> In\u00a0[21]: Copied! <pre>data\n</pre> data Out[21]: <pre>{'node_attributes': {'x': 528245.7985264073,\n  'y': 182527.45267297997,\n  'lon': -0.15269551425404423,\n  'lat': 51.527104855135136,\n  'id': '6985267189',\n  's2_id': 5221390345020494669},\n 'links': {'5': {'id': '5',\n   'from': '5183504114',\n   'to': '6985267189',\n   'freespeed': 4.166666666666667,\n   'capacity': 600.0,\n   'permlanes': 1.0,\n   'oneway': '1',\n   'modes': {'car'},\n   's2_from': 5221390345346257215,\n   's2_to': 5221390345020494669,\n   'attributes': {'osm:way:access': 'permissive',\n    'osm:way:highway': 'unclassified',\n    'osm:way:id': 5228769.0,\n    'osm:way:name': 'Inner Circle',\n    'osm:way:psv': 'destination'},\n   'length': 349.009032054085,\n   'base_capacity': 600.0,\n   'geometry': &lt;shapely.geometry.linestring.LineString at 0x7fd35b152b90&gt;},\n  '0': {'id': '0',\n   'from': '6985267189',\n   'to': '2100667093',\n   'freespeed': 4.166666666666667,\n   'capacity': 600.0,\n   'permlanes': 1.0,\n   'oneway': '1',\n   'modes': {'car'},\n   's2_from': 5221390345020494669,\n   's2_to': 5221390252517831471,\n   'attributes': {'osm:way:access': 'permissive',\n    'osm:way:highway': 'unclassified',\n    'osm:way:id': 5228769.0,\n    'osm:way:name': 'Inner Circle',\n    'osm:way:psv': 'destination'},\n   'length': 341.38916378545576,\n   'base_capacity': 600.0,\n   'geometry': &lt;shapely.geometry.linestring.LineString at 0x7fd35b152810&gt;}}}</pre> <p>We can find a link going in the opposite direction and use the node from previous method to split this link at that node too.</p> In\u00a0[22]: Copied! <pre>n.extract_links_on_edge_attributes([{\"from\": \"2100667093\"}, {\"to\": \"5183504114\"}], how=all)\n</pre> n.extract_links_on_edge_attributes([{\"from\": \"2100667093\"}, {\"to\": \"5183504114\"}], how=all) Out[22]: <pre>['2997', '3282']</pre> In\u00a0[23]: Copied! <pre>data = n.split_link_at_node(\"2997\", data[\"node_attributes\"][\"id\"])\n</pre> data = n.split_link_at_node(\"2997\", data[\"node_attributes\"][\"id\"]) <pre>2022-11-03 18:53:19,500 - Generated 2 link ids.\n2022-11-03 18:53:19,512 - Given point is very close, but not cannot be placed on the line. We move it slightly and the resulting split may not be exact.\n2022-11-03 18:53:20,698 - Generated 0 link ids.\n2022-11-03 18:53:20,769 - Added 2 links\n2022-11-03 18:53:20,792 - Removed link under index: 2997\n2022-11-03 18:53:20,795 - Updating network routes in the PT schedule.\n2022-11-03 18:53:20,855 - No PT routes were affected by this change\n</pre> In\u00a0[24]: Copied! <pre>data\n</pre> data Out[24]: <pre>{'node_attributes': {'x': 528245.7985264073,\n  'y': 182527.45267297997,\n  'lon': -0.15269551425404423,\n  'lat': 51.527104855135136,\n  'id': '6985267189',\n  's2_id': 5221390345020494669},\n 'links': {'7': {'id': '7',\n   'from': '2100667093',\n   'to': '6985267189',\n   'freespeed': 4.166666666666667,\n   'capacity': 600.0,\n   'permlanes': 1.0,\n   'oneway': '1',\n   'modes': {'car'},\n   's2_from': 5221390252517831471,\n   's2_to': 5221390345020494669,\n   'attributes': {'osm:way:access': 'permissive',\n    'osm:way:highway': 'unclassified',\n    'osm:way:id': 568575658.0,\n    'osm:way:name': 'Inner Circle',\n    'osm:way:psv': 'destination'},\n   'length': 165.75966408574467,\n   'base_capacity': 600.0,\n   'geometry': &lt;shapely.geometry.linestring.LineString at 0x7fd35af3ff50&gt;},\n  '21': {'id': '21',\n   'from': '6985267189',\n   'to': '5183504114',\n   'freespeed': 4.166666666666667,\n   'capacity': 600.0,\n   'permlanes': 1.0,\n   'oneway': '1',\n   'modes': {'car'},\n   's2_from': 5221390345020494669,\n   's2_to': 5221390345346257215,\n   'attributes': {'osm:way:access': 'permissive',\n    'osm:way:highway': 'unclassified',\n    'osm:way:id': 568575658.0,\n    'osm:way:name': 'Inner Circle',\n    'osm:way:psv': 'destination'},\n   'length': 169.4594499564508,\n   'base_capacity': 600.0,\n   'geometry': &lt;shapely.geometry.linestring.LineString at 0x7fd35af3f810&gt;}}}</pre> <p>But note that the geometries of the two splits may be slightly off (at the point of cut) with curvy links.</p> In\u00a0[25]: Copied! <pre>n = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n\nlinks = n.extract_links_on_edge_attributes(\n    conditions={\"attributes\": {\"osm:way:highway\": [\"primary\", \"primary_link\"]}}\n)\n</pre> n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles )  links = n.extract_links_on_edge_attributes(     conditions={\"attributes\": {\"osm:way:highway\": [\"primary\", \"primary_link\"]}} ) In\u00a0[26]: Copied! <pre>sub_n = n.subnetwork(links=links)\n</pre> sub_n = n.subnetwork(links=links) <pre>2022-11-03 18:53:30,415 - Subsetting a Network will likely result in a disconnected network graph. A cleaner will be ran that will remove links to make the resulting Network strongly connected for modes: car, walk, bike.\n2022-11-03 18:53:31,298 - Param: strongly_connected_modes is defaulting to `{'car', 'walk', 'bike'}` You can change this behaviour by passing the parameter.\n2022-11-03 18:53:31,328 - The graph for modes: bike does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2022-11-03 18:53:31,425 - The graph for modes: walk does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2022-11-03 18:53:31,604 - The graph for mode car is not strongly connected. The largest 1 connected components will be extracted.\n2022-11-03 18:53:31,777 - Extracting largest connected components resulted in mode: car being deleted from 180 edges\n/Users/kasia.kozlowska/PycharmProjects/ABM/genet/genet/core.py:596: UserWarning: Boolean Series key will be reindexed to match DataFrame index.\n  df = df.loc[links &amp; set(df.index)][df['modes'].apply(lambda x: bool(mode &amp; x))]\n2022-11-03 18:53:31,992 - Changed Link attributes for 180 links\n2022-11-03 18:53:32,070 - Removed 152 links\n2022-11-03 18:53:32,093 - Subsetted Network is ready - do not forget to validate and visualise your subset!\n</pre> In\u00a0[27]: Copied! <pre>sub_n\n</pre> sub_n Out[27]: <pre>&lt;Network instance at 140545726361424: with \ngraph: Name: \nType: MultiDiGraph\nNumber of nodes: 426\nNumber of edges: 472\nAverage in degree:   1.1080\nAverage out degree:   1.1080 and \nschedule Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0</pre> In\u00a0[28]: Copied! <pre>n\n</pre> n Out[28]: <pre>&lt;Network instance at 140545741931600: with \ngraph: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 and \nschedule Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118</pre> In\u00a0[29]: Copied! <pre># pop it in https://s2.sidewalklabs.com/ to see it\nregion = \"48761ad0b14,48761ad0b3,48761ad0b5,48761ad0b7,48761ad0b84,48761ad0d,48761ad0e04,48761ad11f4,48761ad11fc,48761ad13,48761ad145fc,48761ad147,48761ad14c,48761ad153,48761ad41df,48761ad41e4,48761ad41fc,48761ad421,48761ad427,48761ad429,48761ad42b,48761ad5d5,48761ad5d7,48761ad5d9,48761ad5df,48761ad5e1,48761ad5e3,48761ad64,48761ad6c,48761ad71,48761ad73,48761ad744,48761ad74c,48761ad751,48761ad753,48761ad757554,48761ad75c,48761ad77,48761ad79,48761ad7b,48761ad7d,48761ad7e4,48761ad7ec,48761ad7f4,48761ad7f9,48761ad7fb,48761ad7fd,48761ad827,48761ad829,48761ad82b,48761ad9d5,48761ad9d7,48761ad9d84,48761b2802c,48761b2817,48761b281c,48761b283,48761b2847fc,48761b2849,48761b284b,48761b29b5,48761b29b7,48761b29b9,48761b29d,48761b29e4,48761b29e9,48761b29ea4,48761b29ef,48761b29fb4,48761b29fd\"\n</pre> # pop it in https://s2.sidewalklabs.com/ to see it region = \"48761ad0b14,48761ad0b3,48761ad0b5,48761ad0b7,48761ad0b84,48761ad0d,48761ad0e04,48761ad11f4,48761ad11fc,48761ad13,48761ad145fc,48761ad147,48761ad14c,48761ad153,48761ad41df,48761ad41e4,48761ad41fc,48761ad421,48761ad427,48761ad429,48761ad42b,48761ad5d5,48761ad5d7,48761ad5d9,48761ad5df,48761ad5e1,48761ad5e3,48761ad64,48761ad6c,48761ad71,48761ad73,48761ad744,48761ad74c,48761ad751,48761ad753,48761ad757554,48761ad75c,48761ad77,48761ad79,48761ad7b,48761ad7d,48761ad7e4,48761ad7ec,48761ad7f4,48761ad7f9,48761ad7fb,48761ad7fd,48761ad827,48761ad829,48761ad82b,48761ad9d5,48761ad9d7,48761ad9d84,48761b2802c,48761b2817,48761b281c,48761b283,48761b2847fc,48761b2849,48761b284b,48761b29b5,48761b29b7,48761b29b9,48761b29d,48761b29e4,48761b29e9,48761b29ea4,48761b29ef,48761b29fb4,48761b29fd\" In\u00a0[30]: Copied! <pre>n.subnetwork_on_spatial_condition(region, how=\"within\")\n</pre> n.subnetwork_on_spatial_condition(region, how=\"within\") <pre>2022-11-03 18:53:35,884 - Subsetting a Network will likely result in a disconnected network graph. A cleaner will be ran that will remove links to make the resulting Network strongly connected for modes: car, walk, bike.\n2022-11-03 18:53:36,606 - Param: strongly_connected_modes is defaulting to `{'car', 'walk', 'bike'}` You can change this behaviour by passing the parameter.\n2022-11-03 18:53:36,609 - The graph for modes: bike does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2022-11-03 18:53:36,612 - The graph for modes: walk does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2022-11-03 18:53:36,635 - The graph for mode car is not strongly connected. The largest 1 connected components will be extracted.\n2022-11-03 18:53:36,660 - Extracting largest connected components resulted in mode: car being deleted from 72 edges\n/Users/kasia.kozlowska/PycharmProjects/ABM/genet/genet/core.py:596: UserWarning: Boolean Series key will be reindexed to match DataFrame index.\n  df = df.loc[links &amp; set(df.index)][df['modes'].apply(lambda x: bool(mode &amp; x))]\n2022-11-03 18:53:36,720 - Changed Link attributes for 72 links\n2022-11-03 18:53:36,742 - Removed 61 links\n2022-11-03 18:53:36,744 - Subsetted Network is ready - do not forget to validate and visualise your subset!\n</pre> Out[30]: <pre>&lt;Network instance at 140545741000144: with \ngraph: Name: \nType: MultiDiGraph\nNumber of nodes: 110\nNumber of edges: 134\nAverage in degree:   1.2182\nAverage out degree:   1.2182 and \nschedule Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0</pre> In\u00a0[31]: Copied! <pre>n.subnetwork_on_spatial_condition(region, how=\"intersect\")\n</pre> n.subnetwork_on_spatial_condition(region, how=\"intersect\") <pre>2022-11-03 18:53:44,117 - Subsetting a Network will likely result in a disconnected network graph. A cleaner will be ran that will remove links to make the resulting Network strongly connected for modes: car, walk, bike.\n2022-11-03 18:53:44,283 - Schedule will be subsetted using given services: ['12430']. Links pertaining to their network routes will also be retained.\n2022-11-03 18:53:45,735 - Removed Services with IDs `20274`, and Routes: {'VJ812fad65e7fa418645b57b446f00cba573f2cdaf', 'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e', 'VJ375a660d47a2aa570aa20a8568012da8497ffecf'}\n2022-11-03 18:53:46,245 - Removed Services with IDs `18853`, and Routes: {'VJf3e316e5e605bb512147dee2a989be5a82ef1b5f', 'VJ8cacca9a6722c497c413005568182ecf4d50b160', 'VJfc4917783c2ca3227789fa7c532c9adf47702095'}\n2022-11-03 18:53:48,526 - Removed Services with IDs `17732`, and Routes: {'VJ85c23573d670bab5485618b0c5fddff3314efc89', 'VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a'}\n2022-11-03 18:53:49,561 - Removed Services with IDs `15234`, and Routes: {'VJ652c769bc42361cc0308dff59a1fdcf0949bdade', 'VJ9b58a59e3d74941586a5bca7726a8aa624da67fc', 'VJd4cbfb092a104ac6a3164a86e9765f68734fdfcf', 'VJ28a8a6a4ab02807a4fdfd199e5c2ca0622d34d0c', 'VJ3d50b96792ae8495dbe5a5e372849a60c48b2279', 'VJbf9d4fdb976223e6a026c0c669ed290418abefee', 'VJ1a8cc306354fdc322d739ae644eb73444341d08d', 'VJ5b511605b1e07428c2e0a7d676d301c6c40dcca6', 'VJ8ccf92aa0f351b2e31f1a078b968dff4c2505c02'}\n2022-11-03 18:53:50,016 - Removed Services with IDs `15660`, and Routes: {'VJf2e0de4f5dad68cb03064e6064e372dde52cc678', 'VJ3716910ec59c370d9f5c69137df7276b68cf0a08', 'VJ1cf651142378958b52229bfe1fa552e49136e60e'}\n2022-11-03 18:53:50,293 - Removed Services with IDs `14073`, and Routes: {'VJe8cffad09738ff7b9698b333e3247918d5c45358', 'VJ24fe211d801738b556a39f815256d7f6bc544ec5', 'VJc8cdbd902dadeebeeb4dbd7332b564ee2e4b00ce', 'VJd132b905afc6c0e8e8a994142e301ca5c0f70e22', 'VJaa5ee0daec7529d7668c81fe7fac0c4ff545daea', 'VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc', 'VJe6ba07ef9f19ae40517261ad626bf34dd656491a', 'VJe18efadf172576fea7989ec1f233f26854c0f66a', 'VJea6046f64f85febf1854290fb8f76e921e3ac96b', 'VJb4309b7a9598539ab9942ea1bcadc60a91b978ba', 'VJd9dbeefeca6d74ef2594a17514ebc08ee2d503b2', 'VJ93d8207ae8540b4ff59d47c9ee1ec5689084522d', 'VJdbc280077e505b4f8d66586ca51751a125cb4ef0', 'VJfc35884fc4f11dc408a209c19f56f3b60f634daf', 'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13'}\n2022-11-03 18:53:50,563 - Removed Services with IDs `18915`, and Routes: {'VJ0d304b95d39f4bce48e6ff26ddd73a9c06f17f4f', 'VJ520ec0c0ca58a849349fa614b5cf9270ac5c93da', 'VJ887921c00645929c5402ac46592e57c368ea63a1', 'VJ8a4b1ca7dfd0a130abd1de9f55f3b756617dd4ca', 'VJb08f8a2de01a4ef99d3b7fefd9022117ac307531'}\n2022-11-03 18:53:50,728 - Removed Services with IDs `14134`, and Routes: {'VJb93a17a405fe502c5b3a2d6544105b0311da9fe2', 'VJ4e311a625836374adf4cfaa841224840dbeb7619', 'VJdf3936da1a51eb33db594ef99738802c14b19995', 'VJ26095b8f9f9db92ca2e53d4c086a7dcd82a13be9', 'VJ4c6fa387b0d4be94a6c3679b94790b183e2558ca', 'VJ2aba67e3ed98f2ed5f5966c1ac394cbf6d1943d7', 'VJ323d02e117552af1565f2ff1273a612655c829c4', 'VJ4e2b897edf0e7b8a8e3b5516ab43ce56f72c5cff', 'VJ12ba6089dfb2733e29c415a1a0015fef30fd5305', 'VJ5909ba51575a9459eb0013fbd31c8205455ca2fd', 'VJdb0c128567fcbcc063d554ae1c95851cee41b909', 'VJa7f37392e276aeac26c7e73bbc05e6a71af38dba', 'VJ256e98df611ff48afe737ddc81cbcde82e4e81c8', 'VJ2c87b2a59184888f3175b55bde7b02d024ea8607', 'VJd78967364a302cf232c5139d40622dcb6c238c9e', 'VJf9a22035ae6f25bb420df833474943ad76065c89'}\n2022-11-03 18:53:50,733 - Removed Stops with indices `['490000173JB.link:1663', '9400ZZLUOXC4', '490010198W', '9400ZZLUOXC6', '9400ZZLUOXC3', '9400ZZLUGPS2', '9400ZZLUESQ1', '9400ZZLUTCR1', '9400ZZLUOXC1', '9400ZZLUGDG1', '490000235N', '490000091E', '9400ZZLUOXC2', '490015196R', '490000173RD', '9400ZZLUESQ2', '490000252S', '9400ZZLUWRR1', '9400ZZLUOXC5', '9400ZZLUTCR3', '490019675D', '490015196N', '490000356NE', '490000235W1', '9400ZZLUTCR4', '9400ZZLURGP1', '490000252R', '9400ZZLURGP2', '9400ZZLUWRR4', '490000091F', '490011126K', '9400ZZLUWRR2', '490000173RF', '9400ZZLUWRR3', '490013600C']`.Routes affected: set(). Services affected: set().\n2022-11-03 18:53:50,805 - Param: strongly_connected_modes is defaulting to `{'car', 'walk', 'bike'}` You can change this behaviour by passing the parameter.\n2022-11-03 18:53:50,815 - The graph for modes: bike does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2022-11-03 18:53:50,818 - The graph for modes: walk does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2022-11-03 18:53:50,856 - The graph for mode car is not strongly connected. The largest 1 connected components will be extracted.\n2022-11-03 18:53:50,876 - Extracting largest connected components resulted in mode: car being deleted from 82 edges\n/Users/kasia.kozlowska/PycharmProjects/ABM/genet/genet/core.py:596: UserWarning: Boolean Series key will be reindexed to match DataFrame index.\n  df = df.loc[links &amp; set(df.index)][df['modes'].apply(lambda x: bool(mode &amp; x))]\n2022-11-03 18:53:50,910 - Changed Link attributes for 82 links\n2022-11-03 18:53:50,919 - Removed 56 links\n2022-11-03 18:53:50,921 - Subsetted Network is ready - do not forget to validate and visualise your subset!\n</pre> Out[31]: <pre>&lt;Network instance at 140545741701520: with \ngraph: Name: \nType: MultiDiGraph\nNumber of nodes: 156\nNumber of edges: 203\nAverage in degree:   1.3013\nAverage out degree:   1.3013 and \nschedule Schedule:\nNumber of services: 1\nNumber of routes: 12\nNumber of stops: 83</pre>"},{"location":"examples/5_1_modifying_network_graph/#51-modifying-the-network-object-graph","title":"5.1. Modifying the <code>Network</code> object: Graph\u00b6","text":"<p>This page goes through making basic changes to the Network. Available as a jupyter notebook or wiki page.</p> <p><code>GeNet</code> supports some simple modifications like adding, reindexing and removing nodes and links and some involved modifications like changing the data stored under nodes or links. All of these changes get recorded in <code>n.change_log</code>.</p>"},{"location":"examples/5_1_modifying_network_graph/#adding-nodeslinks","title":"Adding nodes/links\u00b6","text":""},{"location":"examples/5_1_modifying_network_graph/#reindexing","title":"Reindexing\u00b6","text":"<p>To reindex a node or link:</p>"},{"location":"examples/5_1_modifying_network_graph/#removing-nodeslinks","title":"Removing nodes/links\u00b6","text":"<p>To remove a link or node:</p>"},{"location":"examples/5_1_modifying_network_graph/#modifying-data-stored-on-nodes-or-edges","title":"Modifying data stored on nodes or edges:\u00b6","text":"<p>Let's say you have extracted <code>genet.Network</code> link ids of interest (See Section on Using Network - Accessing Data) and now you want to make changes to the network. Let's make changes to the nested OSM data stored on the links. We will replace the highway tags from <code>'primary'</code> to <code>'SOMETHING'</code>.</p>"},{"location":"examples/5_1_modifying_network_graph/#divinding-links-at-a-point","title":"Divinding Links at a point\u00b6","text":"<p>This is useful when adding new junctions when creating network scenarios.</p>"},{"location":"examples/5_1_modifying_network_graph/#subsetting","title":"Subsetting\u00b6","text":"<p>You can subset the Network object using link IDs.</p>"},{"location":"examples/5_1_modifying_network_graph/#spatial-subsetting","title":"Spatial Subsetting\u00b6","text":"<p>There is a convenience method to extract a subset network using spatial conditions - refer to Using Network notebook or docs to learn more about what spatial inputs are supported.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/","title":"5.2. Modifying the object: Public transport schedules","text":"In\u00a0[1]: Copied! <pre># read example network\nimport os\nimport shutil\n\nfrom genet import Route, Service, Stop, read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> # read example network import os import shutil  from genet import Route, Service, Stop, read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: MultiDiGraph with 1662 nodes and 3166 edges \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> In\u00a0[2]: Copied! <pre>route = Route(\n    route_short_name=\"N55\",\n    mode=\"bus\",\n    headway_spec={(\"07:00:00\", \"08:00:00\"): 15},\n    arrival_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],\n    departure_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],\n    id=\"new_route\",\n    #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],\n    await_departure=[True, True, True, True],\n    stops=[\n        n.schedule.stop(\"490000235X\"),\n        Stop(id=\"new_stop\", x=529500, y=181300, name=\"New Stop\", epsg=\"epsg:27700\"),\n        Stop(id=\"other_new_stop\", x=529502, y=181302, name=\"Other New Stop\", epsg=\"epsg:27700\"),\n        n.schedule.stop(\"490010689KB\"),\n    ],\n)\n</pre> route = Route(     route_short_name=\"N55\",     mode=\"bus\",     headway_spec={(\"07:00:00\", \"08:00:00\"): 15},     arrival_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],     departure_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],     id=\"new_route\",     #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],     await_departure=[True, True, True, True],     stops=[         n.schedule.stop(\"490000235X\"),         Stop(id=\"new_stop\", x=529500, y=181300, name=\"New Stop\", epsg=\"epsg:27700\"),         Stop(id=\"other_new_stop\", x=529502, y=181302, name=\"Other New Stop\", epsg=\"epsg:27700\"),         n.schedule.stop(\"490010689KB\"),     ], ) In\u00a0[3]: Copied! <pre>route.trips\n</pre> route.trips Out[3]: <pre>{'trip_id': ['new_route_07:00:00',\n  'new_route_07:15:00',\n  'new_route_07:30:00',\n  'new_route_07:45:00',\n  'new_route_08:00:00'],\n 'trip_departure_time': ['07:00:00',\n  '07:15:00',\n  '07:30:00',\n  '07:45:00',\n  '08:00:00'],\n 'vehicle_id': ['veh_bus_new_route_07:00:00',\n  'veh_bus_new_route_07:15:00',\n  'veh_bus_new_route_07:30:00',\n  'veh_bus_new_route_07:45:00',\n  'veh_bus_new_route_08:00:00']}</pre> <p>Or you can use provide the exact trips and vehicles on this route:</p> In\u00a0[4]: Copied! <pre>route = Route(\n    route_short_name=\"N55\",\n    mode=\"bus\",\n    trips={\n        \"trip_id\": [\"fun_trip_1\", \"fun_trip_2\"],\n        \"trip_departure_time\": [\"03:53:00\", \"16:23:00\"],\n        \"vehicle_id\": [\"fun_bus_1\", \"fun_bus_2\"],\n    },\n    arrival_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],\n    departure_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],\n    id=\"new_route\",\n    #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],\n    await_departure=[True, True, True, True],\n    stops=[\n        n.schedule.stop(\"490000235X\"),\n        Stop(id=\"new_stop\", x=529500, y=181300, name=\"New Stop\", epsg=\"epsg:27700\"),\n        Stop(id=\"other_new_stop\", x=529502, y=181302, name=\"Other New Stop\", epsg=\"epsg:27700\"),\n        n.schedule.stop(\"490010689KB\"),\n    ],\n)\n</pre> route = Route(     route_short_name=\"N55\",     mode=\"bus\",     trips={         \"trip_id\": [\"fun_trip_1\", \"fun_trip_2\"],         \"trip_departure_time\": [\"03:53:00\", \"16:23:00\"],         \"vehicle_id\": [\"fun_bus_1\", \"fun_bus_2\"],     },     arrival_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],     departure_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],     id=\"new_route\",     #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],     await_departure=[True, True, True, True],     stops=[         n.schedule.stop(\"490000235X\"),         Stop(id=\"new_stop\", x=529500, y=181300, name=\"New Stop\", epsg=\"epsg:27700\"),         Stop(id=\"other_new_stop\", x=529502, y=181302, name=\"Other New Stop\", epsg=\"epsg:27700\"),         n.schedule.stop(\"490010689KB\"),     ], ) <p>You can create and add a new <code>Service</code>, or add the route to an existing Service</p> In\u00a0[5]: Copied! <pre>new_service = Service(id=\"new_service\", routes=[route])\nnew_service.print()\n</pre> new_service = Service(id=\"new_service\", routes=[route]) new_service.print() <pre>Service ID: new_service\nName: N55\nNumber of routes: 1\nNumber of stops: 4\n</pre> In\u00a0[6]: Copied! <pre>n.schedule.add_service(Service(id=\"new_service\", routes=[route]))\n</pre> n.schedule.add_service(Service(id=\"new_service\", routes=[route])) <pre>2023-12-08 13:44:17,452 - Added Services with IDs `['new_service']` and Routes: [['new_route']]\n</pre> In\u00a0[7]: Copied! <pre>n.schedule.add_route(\"20274\", route)\n</pre> n.schedule.add_route(\"20274\", route) <pre>2023-12-08 13:44:17,570 - Route with ID `new_route` for Service 20274 within already exists in the Schedule. This Route will be reindexed to `20274_4`\n2023-12-08 13:44:17,573 - Reindexed Route from new_route to 20274_4\n2023-12-08 13:44:17,575 - Added Routes with IDs ['20274_4'], to Services `['20274']` within the Schedule\n/Users/bryn.pickering/Repos/arup-group/genet/genet/schedule_elements.py:1803: UserWarning: DataFrame columns are not unique, some columns will be omitted.\n  self.vehicles = {**df.T.to_dict(), **self.vehicles}\n</pre> In\u00a0[8]: Copied! <pre>n.schedule[\"new_service\"].print()\n</pre> n.schedule[\"new_service\"].print() <pre>Service ID: new_service\nName: N55\nNumber of routes: 1\nNumber of stops: 4\n</pre> In\u00a0[9]: Copied! <pre>n.schedule.route(\"20274_4\").ordered_stops\n</pre> n.schedule.route(\"20274_4\").ordered_stops Out[9]: <pre>['490000235X', 'new_stop', 'other_new_stop', '490010689KB']</pre> <p>You can also refer to existing stops in the <code>Schedule</code> when creating a<code>Route</code> to be added. You can either just pass Stop IDs as strings or use a stop method on the schedule to take and use that stop object. Note that in the case of the former (passing ID strings), the route will not have the spatial information for those stops until it is added to the Schedule.</p> In\u00a0[10]: Copied! <pre>r = Route(\n    route_short_name=\"N55\",\n    mode=\"bus\",\n    trips={\n        \"trip_id\": [\"some_trip_1\"],\n        \"trip_departure_time\": [\"16:23:00\"],\n        \"vehicle_id\": [\"some_bus_2\"],\n    },\n    arrival_offsets=[\"00:00:00\", \"00:06:00\"],\n    departure_offsets=[\"00:00:00\", \"00:06:00\"],\n    id=\"another_new_route\",\n    #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],\n    await_departure=[True, True],\n    stops=[\"490000235X.link:834\", \"490010689KB.link:981\"],\n)\n</pre> r = Route(     route_short_name=\"N55\",     mode=\"bus\",     trips={         \"trip_id\": [\"some_trip_1\"],         \"trip_departure_time\": [\"16:23:00\"],         \"vehicle_id\": [\"some_bus_2\"],     },     arrival_offsets=[\"00:00:00\", \"00:06:00\"],     departure_offsets=[\"00:00:00\", \"00:06:00\"],     id=\"another_new_route\",     #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],     await_departure=[True, True],     stops=[\"490000235X.link:834\", \"490010689KB.link:981\"], ) In\u00a0[11]: Copied! <pre>r.graph().nodes[\"490000235X.link:834\"]\n</pre> r.graph().nodes[\"490000235X.link:834\"] Out[11]: <pre>{'routes': {'another_new_route'}}</pre> In\u00a0[12]: Copied! <pre>n.schedule.add_route(\"20274\", r)\n</pre> n.schedule.add_route(\"20274\", r) <pre>2023-12-08 13:44:17,731 - Added Routes with IDs ['another_new_route'], to Services `['20274']` within the Schedule\n/Users/bryn.pickering/Repos/arup-group/genet/genet/schedule_elements.py:1803: UserWarning: DataFrame columns are not unique, some columns will be omitted.\n  self.vehicles = {**df.T.to_dict(), **self.vehicles}\n</pre> In\u00a0[13]: Copied! <pre>r.graph().nodes[\"490000235X.link:834\"]\n</pre> r.graph().nodes[\"490000235X.link:834\"] Out[13]: <pre>{'services': {'14134', '18853', '20274'},\n 'routes': {'VJ12ba6089dfb2733e29c415a1a0015fef30fd5305',\n  'VJ256e98df611ff48afe737ddc81cbcde82e4e81c8',\n  'VJ2aba67e3ed98f2ed5f5966c1ac394cbf6d1943d7',\n  'VJ375a660d47a2aa570aa20a8568012da8497ffecf',\n  'VJ4e2b897edf0e7b8a8e3b5516ab43ce56f72c5cff',\n  'VJa7f37392e276aeac26c7e73bbc05e6a71af38dba',\n  'VJd78967364a302cf232c5139d40622dcb6c238c9e',\n  'VJdf3936da1a51eb33db594ef99738802c14b19995',\n  'VJf3e316e5e605bb512147dee2a989be5a82ef1b5f',\n  'VJf9a22035ae6f25bb420df833474943ad76065c89',\n  'another_new_route'},\n 'id': '490000235X.link:834',\n 'x': 529981.7958802709,\n 'y': 181412.0975758662,\n 'epsg': 'epsg:27700',\n 'name': 'Tottenham Court Road Station (Stop X)',\n 'lon': -0.12809598708996447,\n 'lat': 51.51668503324075,\n 's2_id': 5221390722025467597,\n 'linkRefId': '834',\n 'isBlocking': 'false'}</pre> In\u00a0[14]: Copied! <pre>r = Route(\n    route_short_name=\"N55\",\n    mode=\"bus\",\n    trips={\n        \"trip_id\": [\"some_trip_1\"],\n        \"trip_departure_time\": [\"16:23:00\"],\n        \"vehicle_id\": [\"some_bus_2\"],\n    },\n    arrival_offsets=[\"00:00:00\", \"00:06:00\"],\n    departure_offsets=[\"00:00:00\", \"00:06:00\"],\n    id=\"another_new_route_2\",\n    #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],\n    await_departure=[True, True],\n    stops=[n.schedule.stop(\"490000235X.link:834\"), n.schedule.stop(\"490010689KB.link:981\")],\n)\nn.schedule.add_route(\"20274\", r)\n</pre> r = Route(     route_short_name=\"N55\",     mode=\"bus\",     trips={         \"trip_id\": [\"some_trip_1\"],         \"trip_departure_time\": [\"16:23:00\"],         \"vehicle_id\": [\"some_bus_2\"],     },     arrival_offsets=[\"00:00:00\", \"00:06:00\"],     departure_offsets=[\"00:00:00\", \"00:06:00\"],     id=\"another_new_route_2\",     #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],     await_departure=[True, True],     stops=[n.schedule.stop(\"490000235X.link:834\"), n.schedule.stop(\"490010689KB.link:981\")], ) n.schedule.add_route(\"20274\", r) <pre>2023-12-08 13:44:17,959 - Added Routes with IDs ['another_new_route_2'], to Services `['20274']` within the Schedule\n/Users/bryn.pickering/Repos/arup-group/genet/genet/schedule_elements.py:1803: UserWarning: DataFrame columns are not unique, some columns will be omitted.\n  self.vehicles = {**df.T.to_dict(), **self.vehicles}\n</pre> <p>Note that for a Schedule to be a valid MATSim network, each stop referred to by a route needs a <code>linkRefId</code> attribute which links the stop to the <code>Network</code>.</p> <p>Trying to add Stops with IDs already in the Schedule will result in an error, unless the <code>force=True</code> is set. The added route/service will inherit the data stored under those stops. The idea is that you can either specify the Stops in the route/service to be added correctly, or if they are to be changed, you use a dedicated method - check section 'Modifying data' below.</p> In\u00a0[15]: Copied! <pre>route = Route(\n    route_short_name=\"N55\",\n    mode=\"bus\",\n    trips={\n        \"trip_id\": [\"fun_trip_1\", \"fun_trip_2\"],\n        \"trip_departure_time\": [\"03:53:00\", \"16:23:00\"],\n        \"vehicle_id\": [\"fun_bus_1\", \"fun_bus_2\"],\n    },\n    arrival_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],\n    departure_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],\n    id=\"another_new_route_3\",\n    #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],\n    await_departure=[True, True, True, True],\n    stops=[\n        Stop(id=\"490000235X.link:834\", x=529981, y=181412, epsg=\"epsg:27700\"),\n        Stop(id=\"new_stop\", x=529500, y=181300, epsg=\"epsg:27700\", name=\"New Stop\"),\n        Stop(id=\"other_new_stop\", x=529502, y=181302, epsg=\"epsg:27700\", name=\"Other New Stop\"),\n        Stop(id=\"490010689KB.link:981\", x=529166, y=181256, epsg=\"epsg:27700\"),\n    ],\n)\n\nn.schedule.add_route(\"20274\", route, force=True)\n</pre> route = Route(     route_short_name=\"N55\",     mode=\"bus\",     trips={         \"trip_id\": [\"fun_trip_1\", \"fun_trip_2\"],         \"trip_departure_time\": [\"03:53:00\", \"16:23:00\"],         \"vehicle_id\": [\"fun_bus_1\", \"fun_bus_2\"],     },     arrival_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],     departure_offsets=[\"00:00:00\", \"00:02:00\", \"00:04:00\", \"00:06:00\"],     id=\"another_new_route_3\",     #    route= ['834', '1573', '3139', '3141', '574', '3154', '979', '980', '981'],     await_departure=[True, True, True, True],     stops=[         Stop(id=\"490000235X.link:834\", x=529981, y=181412, epsg=\"epsg:27700\"),         Stop(id=\"new_stop\", x=529500, y=181300, epsg=\"epsg:27700\", name=\"New Stop\"),         Stop(id=\"other_new_stop\", x=529502, y=181302, epsg=\"epsg:27700\", name=\"Other New Stop\"),         Stop(id=\"490010689KB.link:981\", x=529166, y=181256, epsg=\"epsg:27700\"),     ], )  n.schedule.add_route(\"20274\", route, force=True) <pre>2023-12-08 13:44:18,133 - The following stops will inherit the data currently stored under those Stop IDs in the Schedule: ['490000235X.link:834', '490010689KB.link:981'].\n2023-12-08 13:44:18,135 - Added Routes with IDs ['another_new_route_3'], to Services `['20274']` within the Schedule\n/Users/bryn.pickering/Repos/arup-group/genet/genet/schedule_elements.py:1803: UserWarning: DataFrame columns are not unique, some columns will be omitted.\n  self.vehicles = {**df.T.to_dict(), **self.vehicles}\n</pre> <p>Note the message above: <code>The following stops will inherit the data currently stored under those Stop IDs in the Schedule: ['490000235X.link:834', '490010689KB.link:981'].</code></p> <p>NOTE: adding routes and services results in new vehicles (unless you reuse the ones already in the Schedule---beware that the same vehicle cannot service multiple trips at the same time, genet does not currently have checks for this, the user needs to be mindful of the physics of shared vehicles). New vehicles need definitions, you can add them yourself to <code>schedule.vehicles['vehicle_id'] = {'type': 'bus'}</code> ensuring this vehicle type is defined in <code>schedule.vehicle_types['bus']</code>, or you can use a genet method to generate those vehicles, the type will be derived from the mode of the route. Then you can check if all of the types that vehicles are referring to have definitions.</p> In\u00a0[16]: Copied! <pre>len(n.schedule.vehicles)\n</pre> len(n.schedule.vehicles) Out[16]: <pre>1566</pre> In\u00a0[17]: Copied! <pre>n.schedule.generate_vehicles()\n</pre> n.schedule.generate_vehicles() <pre>/Users/bryn.pickering/Repos/arup-group/genet/genet/schedule_elements.py:1803: UserWarning: DataFrame columns are not unique, some columns will be omitted.\n  self.vehicles = {**df.T.to_dict(), **self.vehicles}\n</pre> In\u00a0[18]: Copied! <pre>n.schedule.validate_vehicle_definitions()\n</pre> n.schedule.validate_vehicle_definitions() <pre>2023-12-08 13:44:18,335 - The following vehicle types are missing from the `vehicle_types`  attribute: {'bus'}\n2023-12-08 13:44:18,337 - Vehicles affected by missing vehicle types: {'fun_bus_1': {'type': 'bus'}, 'fun_bus_2': {'type': 'bus'}, 'some_bus_2': {'type': 'bus'}}\n</pre> Out[18]: <pre>False</pre> In\u00a0[19]: Copied! <pre>len(n.schedule.vehicles)\n</pre> len(n.schedule.vehicles) Out[19]: <pre>1566</pre> In\u00a0[20]: Copied! <pre>n.schedule.change_log().tail()\n</pre> n.schedule.change_log().tail() Out[20]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 0 2023-12-08 13:44:17 add service None new_service None {'id': 'new_service', 'name': 'N55'} [(add, , [('id', 'new_service'), ('name', 'N55... 1 2023-12-08 13:44:17 add route None 20274_4 None {'route_short_name': 'N55', 'mode': 'bus', 'ar... [(add, , [('route_short_name', 'N55'), ('mode'... 2 2023-12-08 13:44:17 add route None another_new_route None {'route_short_name': 'N55', 'mode': 'bus', 'ar... [(add, , [('route_short_name', 'N55'), ('mode'... 3 2023-12-08 13:44:17 add route None another_new_route_2 None {'route_short_name': 'N55', 'mode': 'bus', 'ar... [(add, , [('route_short_name', 'N55'), ('mode'... 4 2023-12-08 13:44:18 add route None another_new_route_3 None {'route_short_name': 'N55', 'mode': 'bus', 'ar... [(add, , [('route_short_name', 'N55'), ('mode'... <p>There are no methods to add <code>Stop</code> objects on their own. They are added to the Schedule with <code>Route</code> and <code>Service</code> objects.</p> In\u00a0[21]: Copied! <pre>n.schedule[\"new_service\"].route(\"new_route\").network_links\n</pre> n.schedule[\"new_service\"].route(\"new_route\").network_links Out[21]: <pre>[]</pre> In\u00a0[22]: Copied! <pre>n.schedule[\"new_service\"].route(\"new_route\").ordered_stops\n</pre> n.schedule[\"new_service\"].route(\"new_route\").ordered_stops Out[22]: <pre>['490000235X', 'new_stop', 'other_new_stop', '490010689KB']</pre> In\u00a0[23]: Copied! <pre>if shutil.which(\"cbc\"):\n    n.route_service(\"new_service\")\nelse:\n    print(\"Cannot route service without a solver installed\")\n</pre> if shutil.which(\"cbc\"):     n.route_service(\"new_service\") else:     print(\"Cannot route service without a solver installed\") <pre>2023-12-08 13:44:19,064 - Routing Service new_service with modes = {'bus'}\n2023-12-08 13:44:19,077 - Building Maximum Stable Set for PT graph with 4 stops and 3 edges\n2023-12-08 13:44:19,121 - This Maximum Stable Set Problem is partially viable.\n2023-12-08 13:44:19,124 - Maximum Stable Set problem to snap the PT graph to the network is partially viable, meaning not all stops have found a link to snap to within the distance_threshold.Partial snapping is ON, this problem will proceed to the solver.\n2023-12-08 13:44:19,125 - Passing problem to solver\n2023-12-08 13:44:19,128 - Initializing ordered Set vertices with a fundamentally unordered data source (type: set).  This WILL potentially lead to nondeterministic behavior in Pyomo\n2023-12-08 13:44:19,132 - Passing problem to solver\n2023-12-08 13:44:19,208 - Successfully snapped 3 stops to network links.\n2023-12-08 13:44:19,217 - Stop ID changes detected for Routes: {'new_route'}\n2023-12-08 13:44:19,218 - Changed Route attributes for 1 routes\n2023-12-08 13:44:19,222 - Added 1 nodes\n2023-12-08 13:44:19,266 - Generated 0 link ids.\n2023-12-08 13:44:19,269 - Added 2 links\n2023-12-08 13:44:19,270 - Changed Link attributes for 4 links\n</pre> In\u00a0[24]: Copied! <pre>n.schedule[\"new_service\"].route(\"new_route\").network_links\n</pre> n.schedule[\"new_service\"].route(\"new_route\").network_links Out[24]: <pre>['artificial_link===from:490000235X===to:490000235X',\n 'artificial_link===from:490000235X===to:9521035',\n '3154',\n '979',\n '980',\n '981']</pre> In\u00a0[25]: Copied! <pre>n.schedule[\"new_service\"].route(\"new_route\").ordered_stops\n</pre> n.schedule[\"new_service\"].route(\"new_route\").ordered_stops Out[25]: <pre>['490000235X.link:artificial_link===from:490000235X===to:490000235X',\n 'new_stop.link:3154',\n 'other_new_stop.link:3154',\n '490010689KB.link:981']</pre> In\u00a0[26]: Copied! <pre>n.schedule[\"new_service\"].reindex(new_id=\"more_appropriate_id\")\n</pre> n.schedule[\"new_service\"].reindex(new_id=\"more_appropriate_id\") <pre>2023-12-08 13:44:19,290 - Reindexed Service from new_service to more_appropriate_id\n</pre> In\u00a0[27]: Copied! <pre>n.schedule.route(\"new_route\").reindex(new_id=\"more_appropriate_route_id\")\n</pre> n.schedule.route(\"new_route\").reindex(new_id=\"more_appropriate_route_id\") <pre>2023-12-08 13:44:19,297 - Reindexed Route from new_route to more_appropriate_route_id\n</pre> In\u00a0[28]: Copied! <pre>n.schedule.change_log().tail()\n</pre> n.schedule.change_log().tail() Out[28]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 3 2023-12-08 13:44:17 add route None another_new_route_2 None {'route_short_name': 'N55', 'mode': 'bus', 'ar... [(add, , [('route_short_name', 'N55'), ('mode'... 4 2023-12-08 13:44:18 add route None another_new_route_3 None {'route_short_name': 'N55', 'mode': 'bus', 'ar... [(add, , [('route_short_name', 'N55'), ('mode'... 5 2023-12-08 13:44:19 modify route new_route new_route {'route_short_name': 'N55', 'mode': 'bus', 'ar... {'route_short_name': 'N55', 'mode': 'bus', 'ar... [(add, route, [(0, 'artificial_link===from:490... 6 2023-12-08 13:44:19 modify service new_service more_appropriate_id {'id': 'new_service'} {'id': 'more_appropriate_id'} [(change, id, (new_service, more_appropriate_i... 7 2023-12-08 13:44:19 modify route new_route more_appropriate_route_id {'id': 'new_route'} {'id': 'more_appropriate_route_id'} [(change, id, (new_route, more_appropriate_rou... In\u00a0[29]: Copied! <pre>n.schedule.remove_service(\"more_appropriate_id\")\n</pre> n.schedule.remove_service(\"more_appropriate_id\") <pre>/Users/bryn.pickering/Repos/arup-group/genet/genet/schedule_elements.py:1803: UserWarning: DataFrame columns are not unique, some columns will be omitted.\n  self.vehicles = {**df.T.to_dict(), **self.vehicles}\n2023-12-08 13:44:19,404 - Removed Services with IDs `more_appropriate_id`, and Routes: {'more_appropriate_route_id'}\n</pre> In\u00a0[30]: Copied! <pre>for route_id in {\"another_new_route\", \"another_new_route_2\", \"another_new_route_3\"}:\n    n.schedule.remove_route(route_id)\n</pre> for route_id in {\"another_new_route\", \"another_new_route_2\", \"another_new_route_3\"}:     n.schedule.remove_route(route_id) <pre>/Users/bryn.pickering/Repos/arup-group/genet/genet/schedule_elements.py:1803: UserWarning: DataFrame columns are not unique, some columns will be omitted.\n  self.vehicles = {**df.T.to_dict(), **self.vehicles}\n2023-12-08 13:44:19,507 - Removed Routes with IDs ['another_new_route_2'], to Services `20274`.\n2023-12-08 13:44:19,603 - Removed Routes with IDs ['another_new_route_3'], to Services `20274`.\n</pre> <pre>2023-12-08 13:44:19,700 - Removed Routes with IDs ['another_new_route'], to Services `20274`.\n</pre> In\u00a0[31]: Copied! <pre>n.schedule.change_log().tail()\n</pre> n.schedule.change_log().tail() Out[31]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 7 2023-12-08 13:44:19 modify route new_route more_appropriate_route_id {'id': 'new_route'} {'id': 'more_appropriate_route_id'} [(change, id, (new_route, more_appropriate_rou... 8 2023-12-08 13:44:19 remove service more_appropriate_id None {'id': 'more_appropriate_id', 'name': 'N55'} None [(remove, , [('id', 'more_appropriate_id'), ('... 9 2023-12-08 13:44:19 remove route another_new_route_2 None {'route_short_name': 'N55', 'mode': 'bus', 'ar... None [(remove, , [('route_short_name', 'N55'), ('mo... 10 2023-12-08 13:44:19 remove route another_new_route_3 None {'route_short_name': 'N55', 'mode': 'bus', 'ar... None [(remove, , [('route_short_name', 'N55'), ('mo... 11 2023-12-08 13:44:19 remove route another_new_route None {'route_short_name': 'N55', 'mode': 'bus', 'ar... None [(remove, , [('route_short_name', 'N55'), ('mo... <p>You can also remove <code>Stop</code>s. This will disconnect <code>Route</code>s and <code>Service</code>s using that <code>Stop</code>s and likely render them invalid. The method will warn you which <code>Route</code>s and <code>Servce</code>s are affected.</p> In\u00a0[32]: Copied! <pre>n.schedule.remove_stop(\"new_stop\")\n</pre> n.schedule.remove_stop(\"new_stop\") <pre>2023-12-08 13:44:19,715 - Removed Stops with indices `['new_stop']`.Routes affected: {'20274_4'}. Services affected: {'20274'}.\n</pre> <p>You can also remove <code>Stop</code>s. This will disconnect <code>Route</code>s and <code>Service</code>s using that <code>Stop</code>s and likely render them invalid. The method will warn you which <code>Route</code>s and <code>Servce</code>s are affected.</p> In\u00a0[33]: Copied! <pre>n.schedule.remove_unused_stops()\n</pre> n.schedule.remove_unused_stops() <pre>2023-12-08 13:44:19,721 - Removed Stops with indices `['490000252R', '9400ZZLUTCR3', 'new_stop.link:3154', '490015196N', '9400ZZLUOXC6', '9400ZZLUGDG1', '9400ZZLUOXC1', '490000235W1', '490000235X.link:artificial_link===from:490000235X===to:490000235X', '490010198W', '490000252S', '9400ZZLUESQ2', '490000091F', '9400ZZLURGP1', '9400ZZLUWRR3', '9400ZZLUWRR1', '490000173RF', '9400ZZLUTCR4', '490000235N', '490015196R', '9400ZZLUOXC3', '9400ZZLURGP2', '9400ZZLUWRR2', '490000356NE', '9400ZZLUOXC5', '490011126K', '9400ZZLUTCR1', 'other_new_stop.link:3154', '9400ZZLUOXC4', '490000173RD', '9400ZZLUGPS2', '490013600C', '9400ZZLUWRR4', '490019675D', '490000091E', '9400ZZLUESQ1', '9400ZZLUOXC2']`.Routes affected: set(). Services affected: set().\n</pre> In\u00a0[34]: Copied! <pre>df = n.schedule.service_attribute_data(keys=\"name\")\ndf.head()\n</pre> df = n.schedule.service_attribute_data(keys=\"name\") df.head() Out[34]: name 20274 N55 18915 N5 14134 98 15660 113 18853 N8 <p>DataFrames are easy to work with. Youcould for exmaple manipulate the names or use other data to change these. For demonstration here, let's just set the names to something easy.</p> In\u00a0[35]: Copied! <pre>df[\"name\"] = df[\"name\"].apply(lambda x: f\"Service_{x}\")\ndf.head()\n</pre> df[\"name\"] = df[\"name\"].apply(lambda x: f\"Service_{x}\") df.head() Out[35]: name 20274 Service_N55 18915 Service_N5 14134 Service_98 15660 Service_113 18853 Service_N8 <p>You can then convert this to a dictionary and pass it to the <code>apply_attributes_to_services</code> method.</p> In\u00a0[36]: Copied! <pre>n.schedule.apply_attributes_to_services(df.T.to_dict())\n</pre> n.schedule.apply_attributes_to_services(df.T.to_dict()) <pre>2023-12-08 13:44:19,740 - Changed Service attributes for 9 services\n</pre> In\u00a0[37]: Copied! <pre>n.schedule.change_log().tail()\n</pre> n.schedule.change_log().tail() Out[37]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 54 2023-12-08 13:44:19 modify service 18853 18853 {'id': '18853', 'name': 'N8'} {'id': '18853', 'name': 'Service_N8'} [(change, name, (N8, Service_N8))] 55 2023-12-08 13:44:19 modify service 12430 12430 {'id': '12430', 'name': '205'} {'id': '12430', 'name': 'Service_205'} [(change, name, (205, Service_205))] 56 2023-12-08 13:44:19 modify service 15234 15234 {'id': '15234', 'name': '134'} {'id': '15234', 'name': 'Service_134'} [(change, name, (134, Service_134))] 57 2023-12-08 13:44:19 modify service 17732 17732 {'id': '17732', 'name': 'N20'} {'id': '17732', 'name': 'Service_N20'} [(change, name, (N20, Service_N20))] 58 2023-12-08 13:44:19 modify service 14073 14073 {'id': '14073', 'name': '94'} {'id': '14073', 'name': 'Service_94'} [(change, name, (94, Service_94))] <p>You can do the same for <code>Routes</code> and <code>Stops</code>. Your dictionaries cannot however hold changes to indices. You will encounter an error and should use <code>reindex</code> methods for such operations.</p> In\u00a0[38]: Copied! <pre>n.schedule.apply_attributes_to_routes(\n    {\n        \"VJ375a660d47a2aa570aa20a8568012da8497ffecf\": {\n            \"name\": \"my_favourite_route\",\n            \"mode\": \"piggyback\",\n        }\n    }\n)\n</pre> n.schedule.apply_attributes_to_routes(     {         \"VJ375a660d47a2aa570aa20a8568012da8497ffecf\": {             \"name\": \"my_favourite_route\",             \"mode\": \"piggyback\",         }     } ) <pre>2023-12-08 13:44:19,754 - Changed Route attributes for 1 routes\n</pre> In\u00a0[39]: Copied! <pre>n.schedule.apply_attributes_to_stops({\"490000235YB.link:574\": {\"new_attribute\": \"hello!\"}})\n</pre> n.schedule.apply_attributes_to_stops({\"490000235YB.link:574\": {\"new_attribute\": \"hello!\"}}) <pre>2023-12-08 13:44:19,759 - Changed Stop attributes for 1 stops\n</pre> In\u00a0[40]: Copied! <pre>n.schedule.change_log().tail()\n</pre> n.schedule.change_log().tail() Out[40]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 56 2023-12-08 13:44:19 modify service 15234 15234 {'id': '15234', 'name': '134'} {'id': '15234', 'name': 'Service_134'} [(change, name, (134, Service_134))] 57 2023-12-08 13:44:19 modify service 17732 17732 {'id': '17732', 'name': 'N20'} {'id': '17732', 'name': 'Service_N20'} [(change, name, (N20, Service_N20))] 58 2023-12-08 13:44:19 modify service 14073 14073 {'id': '14073', 'name': '94'} {'id': '14073', 'name': 'Service_94'} [(change, name, (94, Service_94))] 59 2023-12-08 13:44:19 modify route VJ375a660d47a2aa570aa20a8568012da8497ffecf VJ375a660d47a2aa570aa20a8568012da8497ffecf {'route_short_name': 'N55', 'mode': 'bus', 'ar... {'route_short_name': 'N55', 'mode': 'piggyback... [(change, mode, (bus, piggyback)), (add, , [('... 60 2023-12-08 13:44:19 modify stop 490000235YB.link:574 490000235YB.link:574 {'services': {'18853', '14134', '20274'}, 'rou... {'services': {'18853', '14134', '20274'}, 'rou... [(add, , [('new_attribute', 'hello!')])] In\u00a0[41]: Copied! <pre>trips = n.schedule.trips_to_dataframe(gtfs_day=\"20210101\")\n</pre> trips = n.schedule.trips_to_dataframe(gtfs_day=\"20210101\") In\u00a0[42]: Copied! <pre>trips.head()\n</pre> trips.head() Out[42]: mode route_id service_id trip_id trip_departure_time vehicle_id 0 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 VJ0b0180c7b6bcef5834ec857e9b5a94254803694f_03:... 2021-01-01 03:48:00 veh_2160_bus 1 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a_03:... 2021-01-01 03:18:00 veh_2161_bus 2 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 VJ5e32459fcb7ab3481a1bab1b2c106f592a67d8ff_04:... 2021-01-01 04:43:00 veh_2162_bus 3 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 VJ691d8b8a2b60e4f943babbea813c047824d60e6e_02:... 2021-01-01 02:28:00 veh_2163_bus 4 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 VJ9b62613eaaadfb63206602708def459f48c9d7e5_01:... 2021-01-01 01:58:00 veh_2164_bus <p>Let's change all of the trip ids to something shorter</p> In\u00a0[43]: Copied! <pre>trips[\"trip_id\"] = \"trip_\" + trips.index.to_series().astype(str)\ntrips.head()\n</pre> trips[\"trip_id\"] = \"trip_\" + trips.index.to_series().astype(str) trips.head() Out[43]: mode route_id service_id trip_id trip_departure_time vehicle_id 0 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 trip_0 2021-01-01 03:48:00 veh_2160_bus 1 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 trip_1 2021-01-01 03:18:00 veh_2161_bus 2 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 trip_2 2021-01-01 04:43:00 veh_2162_bus 3 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 trip_3 2021-01-01 02:28:00 veh_2163_bus 4 bus VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a 17732 trip_4 2021-01-01 01:58:00 veh_2164_bus <p>You can <code>set_trips_dataframe</code> which takes this dataframe and applies changes to all route trips based on the data in the dataframe. This means you can generate this DataFrame as shown below, manipulate trips (delete them, add new ones), change their departure times or change their vehicle ids to be shared for differnt trips, perhaps on some temporal logic and as long as the dataframe has the same schema, you can use it to set new trips in the schedule. This will appear in the changelog as a route level modify event.</p> <p>Nb removing all trips of the same route from the dataframe will have no effect when being applied. If there is data in the dataframe for a route, all of its trips will be replaced by the data in the dataframe, and if there is no data for a route in the frame, no changes will be applied to that route (i.e. the trips attribute for routes missing from the dataframe will not be set as empty).</p> In\u00a0[44]: Copied! <pre>n.schedule.set_trips_dataframe(trips)\nn.schedule.route_attribute_data(keys=[{\"trips\": \"trip_id\"}]).head()\n</pre> n.schedule.set_trips_dataframe(trips) n.schedule.route_attribute_data(keys=[{\"trips\": \"trip_id\"}]).head() <pre>2023-12-08 13:44:19,838 - Changed Route attributes for 69 routes\n</pre> Out[44]: trips::trip_id VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a [trip_0, trip_1, trip_2, trip_3, trip_4, trip_... VJ5b511605b1e07428c2e0a7d676d301c6c40dcca6 [trip_12, trip_13, trip_14, trip_15, trip_16, ... VJ4e2b897edf0e7b8a8e3b5516ab43ce56f72c5cff [trip_26, trip_27, trip_28, trip_29, trip_30, ... VJd78967364a302cf232c5139d40622dcb6c238c9e [trip_45, trip_46] VJ256e98df611ff48afe737ddc81cbcde82e4e81c8 [trip_47] In\u00a0[45]: Copied! <pre>route_id = \"VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13\"\n\nn.schedule.route(route_id).trips\n</pre> route_id = \"VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13\"  n.schedule.route(route_id).trips Out[45]: <pre>{'trip_id': ['trip_203', 'trip_204'],\n 'trip_departure_time': ['07:51:00', '22:50:00'],\n 'vehicle_id': ['veh_887_bus', 'veh_888_bus']}</pre> In\u00a0[46]: Copied! <pre>n.schedule.generate_trips_from_headway(\n    route_id=route_id, headway_spec={(\"07:51:00\", \"22:50:00\"): 120}\n)  # headway in minutes\n</pre> n.schedule.generate_trips_from_headway(     route_id=route_id, headway_spec={(\"07:51:00\", \"22:50:00\"): 120} )  # headway in minutes <pre>2023-12-08 13:44:19,863 - Changed Route attributes for 1 routes\n</pre> In\u00a0[47]: Copied! <pre>n.schedule.route(route_id).trips\n</pre> n.schedule.route(route_id).trips Out[47]: <pre>{'trip_id': ['VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_07:51:00',\n  'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_09:51:00',\n  'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_11:51:00',\n  'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_13:51:00',\n  'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_15:51:00',\n  'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_17:51:00',\n  'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_19:51:00',\n  'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_21:51:00'],\n 'trip_departure_time': ['07:51:00',\n  '09:51:00',\n  '11:51:00',\n  '13:51:00',\n  '15:51:00',\n  '17:51:00',\n  '19:51:00',\n  '21:51:00'],\n 'vehicle_id': ['veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_07:51:00',\n  'veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_09:51:00',\n  'veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_11:51:00',\n  'veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_13:51:00',\n  'veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_15:51:00',\n  'veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_17:51:00',\n  'veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_19:51:00',\n  'veh_Bus_VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13_21:51:00']}</pre> In\u00a0[48]: Copied! <pre>from shapely.geometry import Point\n\n\ndef add_shapely_geometry_points(stop_attribs):\n    return Point(stop_attribs[\"x\"], stop_attribs[\"y\"])\n\n\nn.schedule.apply_function_to_stops(add_shapely_geometry_points, location=\"geometry\")\n</pre> from shapely.geometry import Point   def add_shapely_geometry_points(stop_attribs):     return Point(stop_attribs[\"x\"], stop_attribs[\"y\"])   n.schedule.apply_function_to_stops(add_shapely_geometry_points, location=\"geometry\") <pre>2023-12-08 13:44:19,894 - Changed Stop attributes for 85 stops\n</pre> In\u00a0[49]: Copied! <pre>n.schedule.change_log().tail(2)\n</pre> n.schedule.change_log().tail(2) Out[49]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 214 2023-12-08 13:44:19 modify stop 490000235YB 490000235YB {'id': '490000235YB', 'x': 529570.7813227688, ... {'id': '490000235YB', 'x': 529570.7813227688, ... [(add, , [('geometry', &lt;POINT (529570.781 1813... 215 2023-12-08 13:44:19 modify stop other_new_stop other_new_stop {'services': {'20274'}, 'routes': {'20274_4'},... {'services': {'20274'}, 'routes': {'20274_4'},... [(add, , [('geometry', &lt;POINT (529502 181302)&gt;... In\u00a0[50]: Copied! <pre>n.schedule.stop_attribute_data(keys=[\"name\", \"x\", \"y\", \"geometry\"]).head()\n</pre> n.schedule.stop_attribute_data(keys=[\"name\", \"x\", \"y\", \"geometry\"]).head() Out[50]: name x y geometry 490000235X.link:834 Tottenham Court Road Station (Stop X) 529981.795880 181412.097576 POINT (529981.7958802709 181412.0975758662) 490000235YB.link:574 Oxford Street  Soho Street (Stop YB) 529570.781323 181336.281593 POINT (529570.7813227688 181336.2815925331) 490014214HE.link:3154 Wardour Street (Stop OM) 529477.750156 181314.437043 POINT (529477.7501560802 181314.43704307207) 490010689KB.link:981 Great Titchfield Street  Oxford Circus Station... 529166.734973 181256.336723 POINT (529166.7349732723 181256.33672284335) 490000235V.link:3140 Tottenham Court Road Station (Stop V) 529716.723832 181371.384818 POINT (529716.7238324936 181371.3848181052) In\u00a0[51]: Copied! <pre>from geopandas import GeoDataFrame\n\nGeoDataFrame(n.schedule.stop_attribute_data(keys=\"geometry\")).plot()\n</pre> from geopandas import GeoDataFrame  GeoDataFrame(n.schedule.stop_attribute_data(keys=\"geometry\")).plot() Out[51]: <pre>&lt;Axes: &gt;</pre> In\u00a0[52]: Copied! <pre>n.schedule.stop(\"490000235YB.link:574\").__dict__\n</pre> n.schedule.stop(\"490000235YB.link:574\").__dict__ Out[52]: <pre>{'id': '490000235YB.link:574',\n 'x': 529570.7813227688,\n 'y': 181336.2815925331,\n 'epsg': 'epsg:27700',\n 'name': 'Oxford Street  Soho Street (Stop YB)',\n 'lat': 51.51609803324078,\n 'lon': -0.13404398709291904,\n 's2_id': 5221390696959560815,\n 'linkRefId': '574',\n 'isBlocking': 'false',\n 'new_attribute': 'hello!',\n 'geometry': &lt;POINT (529570.781 181336.282)&gt;}</pre> <p>For this let's say we want to reduce the number of trips. For simplicity of demonstration we don't have about which trips we delete, but logic around timings of trips can be added in this function, as the trips are saved as one of routes attributes (check out the summary methods)</p> In\u00a0[53]: Copied! <pre># before\nlen(n.schedule.route_trips_to_dataframe())\n</pre> # before len(n.schedule.route_trips_to_dataframe()) <pre>2023-12-08 13:44:20,294 - `route_trips_to_dataframe` method is deprecated and will be replaced by `trips_to_dataframe`in later versions.\n</pre> Out[53]: <pre>1570</pre> In\u00a0[54]: Copied! <pre>def reduce_trips(attribs):\n    # just delete any other trip\n    attribs[\"trips\"][\"trip_id\"] = attribs[\"trips\"][\"trip_id\"][::2]\n    attribs[\"trips\"][\"trip_departure_time\"] = attribs[\"trips\"][\"trip_departure_time\"][::2]\n    attribs[\"trips\"][\"vehicle_id\"] = attribs[\"trips\"][\"vehicle_id\"][::2]\n    return attribs[\"trips\"]\n\n\nn.schedule.apply_function_to_routes(reduce_trips, \"trips\")\n</pre> def reduce_trips(attribs):     # just delete any other trip     attribs[\"trips\"][\"trip_id\"] = attribs[\"trips\"][\"trip_id\"][::2]     attribs[\"trips\"][\"trip_departure_time\"] = attribs[\"trips\"][\"trip_departure_time\"][::2]     attribs[\"trips\"][\"vehicle_id\"] = attribs[\"trips\"][\"vehicle_id\"][::2]     return attribs[\"trips\"]   n.schedule.apply_function_to_routes(reduce_trips, \"trips\") <pre>2023-12-08 13:44:20,387 - Changed Route attributes for 69 routes\n</pre> In\u00a0[55]: Copied! <pre># after\nlen(n.schedule.route_trips_to_dataframe())\n</pre> # after len(n.schedule.route_trips_to_dataframe()) <pre>2023-12-08 13:44:20,395 - `route_trips_to_dataframe` method is deprecated and will be replaced by `trips_to_dataframe`in later versions.\n</pre> Out[55]: <pre>796</pre> <p>Note, this could also be done using the <code>route_trips_to_dataframe</code> and <code>set_route_trips_dataframe</code> mentioned above.</p> <p>Let's give an example of using a mapping. We can re-use the service name DataFrame we generated above.</p> In\u00a0[56]: Copied! <pre>df[\"new_name\"] = \"Brand_new_name\" + df[\"name\"]\ndf.head()\n</pre> df[\"new_name\"] = \"Brand_new_name\" + df[\"name\"] df.head() Out[56]: name new_name 20274 Service_N55 Brand_new_nameService_N55 18915 Service_N5 Brand_new_nameService_N5 14134 Service_98 Brand_new_nameService_98 15660 Service_113 Brand_new_nameService_113 18853 Service_N8 Brand_new_nameService_N8 In\u00a0[57]: Copied! <pre>name_map = dict(zip(df[\"name\"], df[\"new_name\"]))\nname_map\n</pre> name_map = dict(zip(df[\"name\"], df[\"new_name\"])) name_map Out[57]: <pre>{'Service_N55': 'Brand_new_nameService_N55',\n 'Service_N5': 'Brand_new_nameService_N5',\n 'Service_98': 'Brand_new_nameService_98',\n 'Service_113': 'Brand_new_nameService_113',\n 'Service_N8': 'Brand_new_nameService_N8',\n 'Service_205': 'Brand_new_nameService_205',\n 'Service_134': 'Brand_new_nameService_134',\n 'Service_N20': 'Brand_new_nameService_N20',\n 'Service_94': 'Brand_new_nameService_94'}</pre> <p>In this case, <code>location</code> refers to the attribute to be mapped.</p> In\u00a0[58]: Copied! <pre>n.schedule.apply_function_to_services(name_map, location=\"name\")\n</pre> n.schedule.apply_function_to_services(name_map, location=\"name\") <pre>2023-12-08 13:44:20,431 - Changed Service attributes for 9 services\n</pre> In\u00a0[59]: Copied! <pre>n.schedule.change_log().tail()\n</pre> n.schedule.change_log().tail() Out[59]: timestamp change_event object_type old_id new_id old_attributes new_attributes diff 289 2023-12-08 13:44:20 modify service 18853 18853 {'id': '18853', 'name': 'Service_N8'} {'id': '18853', 'name': 'Brand_new_nameService... [(change, name, (Service_N8, Brand_new_nameSer... 290 2023-12-08 13:44:20 modify service 12430 12430 {'id': '12430', 'name': 'Service_205'} {'id': '12430', 'name': 'Brand_new_nameService... [(change, name, (Service_205, Brand_new_nameSe... 291 2023-12-08 13:44:20 modify service 15234 15234 {'id': '15234', 'name': 'Service_134'} {'id': '15234', 'name': 'Brand_new_nameService... [(change, name, (Service_134, Brand_new_nameSe... 292 2023-12-08 13:44:20 modify service 17732 17732 {'id': '17732', 'name': 'Service_N20'} {'id': '17732', 'name': 'Brand_new_nameService... [(change, name, (Service_N20, Brand_new_nameSe... 293 2023-12-08 13:44:20 modify service 14073 14073 {'id': '14073', 'name': 'Service_94'} {'id': '14073', 'name': 'Brand_new_nameService... [(change, name, (Service_94, Brand_new_nameSer... In\u00a0[60]: Copied! <pre>{s.name for s in n.schedule.services()}\n</pre> {s.name for s in n.schedule.services()} Out[60]: <pre>{'Brand_new_nameService_113',\n 'Brand_new_nameService_134',\n 'Brand_new_nameService_205',\n 'Brand_new_nameService_94',\n 'Brand_new_nameService_98',\n 'Brand_new_nameService_N20',\n 'Brand_new_nameService_N5',\n 'Brand_new_nameService_N55',\n 'Brand_new_nameService_N8'}</pre> In\u00a0[61]: Copied! <pre>services = n.schedule.extract_service_ids_on_attributes(\n    {\"name\": [\"Brand_new_nameService_134\", \"Brand_new_nameService_98\"]}\n)\nlen(services)\n</pre> services = n.schedule.extract_service_ids_on_attributes(     {\"name\": [\"Brand_new_nameService_134\", \"Brand_new_nameService_98\"]} ) len(services) Out[61]: <pre>2</pre> In\u00a0[62]: Copied! <pre>n.schedule.print()\n</pre> n.schedule.print() <pre>Schedule:\nNumber of services: 9\nNumber of routes: 69\nNumber of stops: 85\n</pre> In\u00a0[63]: Copied! <pre>sub_s = n.schedule.subschedule(service_ids=services)\n</pre> sub_s = n.schedule.subschedule(service_ids=services) <pre>2023-12-08 13:44:20,655 - The following vehicle types are missing from the `vehicle_types`  attribute: {'piggyback'}\n2023-12-08 13:44:20,658 - Vehicles affected by missing vehicle types: {'veh_2331_bus': {'type': 'piggyback'}, 'veh_2333_bus': {'type': 'piggyback'}, 'veh_2335_bus': {'type': 'piggyback'}, 'veh_2337_bus': {'type': 'piggyback'}, 'veh_2339_bus': {'type': 'piggyback'}}\n2023-12-08 13:44:20,713 - Removed Services with IDs `20274`, and Routes: {'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e', '20274_4', 'VJ812fad65e7fa418645b57b446f00cba573f2cdaf', 'VJ375a660d47a2aa570aa20a8568012da8497ffecf'}\n2023-12-08 13:44:20,774 - Removed Services with IDs `18915`, and Routes: {'VJ887921c00645929c5402ac46592e57c368ea63a1', 'VJ8a4b1ca7dfd0a130abd1de9f55f3b756617dd4ca', 'VJ520ec0c0ca58a849349fa614b5cf9270ac5c93da', 'VJ0d304b95d39f4bce48e6ff26ddd73a9c06f17f4f', 'VJb08f8a2de01a4ef99d3b7fefd9022117ac307531'}\n2023-12-08 13:44:20,831 - Removed Services with IDs `15660`, and Routes: {'VJ3716910ec59c370d9f5c69137df7276b68cf0a08', 'VJf2e0de4f5dad68cb03064e6064e372dde52cc678', 'VJ1cf651142378958b52229bfe1fa552e49136e60e'}\n2023-12-08 13:44:20,895 - Removed Services with IDs `18853`, and Routes: {'VJ8cacca9a6722c497c413005568182ecf4d50b160', 'VJfc4917783c2ca3227789fa7c532c9adf47702095', 'VJf3e316e5e605bb512147dee2a989be5a82ef1b5f'}\n2023-12-08 13:44:20,935 - Removed Services with IDs `12430`, and Routes: {'VJf8e38a73359b6cf743d8e35ee64ef1f7b7914daa', 'VJ15419796737689e742962a625abcf3fd5b3d58b1', 'VJ0f3c08222de16c2e278be0a1bf0f9ea47370774e', 'VJ8f9aea7491080b0137d3092706f53dc11f7dba45', 'VJef7f20c3a9bf1419f6401e1e9131fe2c634bcb9a', 'VJ95b4c534d7c903d76ec0340025aa88b81dba3ce4', 'VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3', 'VJeb72539d69ddf8e29f1adf74d43953def196ae41', 'VJ948e8caa0f08b9c6bf6330927893942c474b5100', 'VJeae6e634f8479e0b6712780d5728f0afca964e64', 'VJ06cd41dcd58d947097df4a8f33234ef423210154', 'VJ235c8fca539cf931b3c673f9b056606384aff950'}\n2023-12-08 13:44:20,977 - Removed Services with IDs `17732`, and Routes: {'VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a', 'VJ85c23573d670bab5485618b0c5fddff3314efc89'}\n2023-12-08 13:44:21,006 - Removed Services with IDs `14073`, and Routes: {'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13', 'VJaa5ee0daec7529d7668c81fe7fac0c4ff545daea', 'VJe18efadf172576fea7989ec1f233f26854c0f66a', 'VJfc35884fc4f11dc408a209c19f56f3b60f634daf', 'VJe8cffad09738ff7b9698b333e3247918d5c45358', 'VJb4309b7a9598539ab9942ea1bcadc60a91b978ba', 'VJ24fe211d801738b556a39f815256d7f6bc544ec5', 'VJdbc280077e505b4f8d66586ca51751a125cb4ef0', 'VJc8cdbd902dadeebeeb4dbd7332b564ee2e4b00ce', 'VJd9dbeefeca6d74ef2594a17514ebc08ee2d503b2', 'VJea6046f64f85febf1854290fb8f76e921e3ac96b', 'VJd132b905afc6c0e8e8a994142e301ca5c0f70e22', 'VJe6ba07ef9f19ae40517261ad626bf34dd656491a', 'VJ93d8207ae8540b4ff59d47c9ee1ec5689084522d', 'VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc'}\n2023-12-08 13:44:21,007 - Removed Stops with indices `['490000173JB.link:1663', 'other_new_stop']`.Routes affected: set(). Services affected: set().\n</pre> In\u00a0[64]: Copied! <pre>sub_s.print()\n</pre> sub_s.print() <pre>Schedule:\nNumber of services: 2\nNumber of routes: 25\nNumber of stops: 83\n</pre> In\u00a0[65]: Copied! <pre># pop it in https://s2.sidewalklabs.com/ to see it\nregion = \"48761ad0b14,48761ad0b3,48761ad0b5,48761ad0b7,48761ad0b84,48761ad0d,48761ad0e04,48761ad11f4,48761ad11fc,48761ad13,48761ad145fc,48761ad147,48761ad14c,48761ad153,48761ad41df,48761ad41e4,48761ad41fc,48761ad421,48761ad427,48761ad429,48761ad42b,48761ad5d5,48761ad5d7,48761ad5d9,48761ad5df,48761ad5e1,48761ad5e3,48761ad64,48761ad6c,48761ad71,48761ad73,48761ad744,48761ad74c,48761ad751,48761ad753,48761ad757554,48761ad75c,48761ad77,48761ad79,48761ad7b,48761ad7d,48761ad7e4,48761ad7ec,48761ad7f4,48761ad7f9,48761ad7fb,48761ad7fd,48761ad827,48761ad829,48761ad82b,48761ad9d5,48761ad9d7,48761ad9d84,48761b2802c,48761b2817,48761b281c,48761b283,48761b2847fc,48761b2849,48761b284b,48761b29b5,48761b29b7,48761b29b9,48761b29d,48761b29e4,48761b29e9,48761b29ea4,48761b29ef,48761b29fb4,48761b29fd\"\n</pre> # pop it in https://s2.sidewalklabs.com/ to see it region = \"48761ad0b14,48761ad0b3,48761ad0b5,48761ad0b7,48761ad0b84,48761ad0d,48761ad0e04,48761ad11f4,48761ad11fc,48761ad13,48761ad145fc,48761ad147,48761ad14c,48761ad153,48761ad41df,48761ad41e4,48761ad41fc,48761ad421,48761ad427,48761ad429,48761ad42b,48761ad5d5,48761ad5d7,48761ad5d9,48761ad5df,48761ad5e1,48761ad5e3,48761ad64,48761ad6c,48761ad71,48761ad73,48761ad744,48761ad74c,48761ad751,48761ad753,48761ad757554,48761ad75c,48761ad77,48761ad79,48761ad7b,48761ad7d,48761ad7e4,48761ad7ec,48761ad7f4,48761ad7f9,48761ad7fb,48761ad7fd,48761ad827,48761ad829,48761ad82b,48761ad9d5,48761ad9d7,48761ad9d84,48761b2802c,48761b2817,48761b281c,48761b283,48761b2847fc,48761b2849,48761b284b,48761b29b5,48761b29b7,48761b29b9,48761b29d,48761b29e4,48761b29e9,48761b29ea4,48761b29ef,48761b29fb4,48761b29fd\" In\u00a0[66]: Copied! <pre>n.subnetwork_on_spatial_condition(region, how=\"intersect\")\n</pre> n.subnetwork_on_spatial_condition(region, how=\"intersect\") <pre>2023-12-08 13:44:21,462 - Subsetting a Network will likely result in a disconnected network graph. A cleaner will be ran that will remove links to make the resulting Network strongly connected for modes: car, walk, bike.\n2023-12-08 13:44:21,512 - Schedule will be subsetted using given services: ['12430']. Links pertaining to their network routes will also be retained.\n2023-12-08 13:44:21,599 - The following vehicle types are missing from the `vehicle_types`  attribute: {'piggyback'}\n2023-12-08 13:44:21,599 - Vehicles affected by missing vehicle types: {'veh_2331_bus': {'type': 'piggyback'}, 'veh_2333_bus': {'type': 'piggyback'}, 'veh_2335_bus': {'type': 'piggyback'}, 'veh_2337_bus': {'type': 'piggyback'}, 'veh_2339_bus': {'type': 'piggyback'}}\n2023-12-08 13:44:21,658 - Removed Services with IDs `20274`, and Routes: {'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e', '20274_4', 'VJ812fad65e7fa418645b57b446f00cba573f2cdaf', 'VJ375a660d47a2aa570aa20a8568012da8497ffecf'}\n2023-12-08 13:44:21,789 - Removed Services with IDs `18915`, and Routes: {'VJ887921c00645929c5402ac46592e57c368ea63a1', 'VJ8a4b1ca7dfd0a130abd1de9f55f3b756617dd4ca', 'VJ520ec0c0ca58a849349fa614b5cf9270ac5c93da', 'VJ0d304b95d39f4bce48e6ff26ddd73a9c06f17f4f', 'VJb08f8a2de01a4ef99d3b7fefd9022117ac307531'}\n2023-12-08 13:44:21,834 - Removed Services with IDs `14134`, and Routes: {'VJ4e2b897edf0e7b8a8e3b5516ab43ce56f72c5cff', 'VJd78967364a302cf232c5139d40622dcb6c238c9e', 'VJ256e98df611ff48afe737ddc81cbcde82e4e81c8', 'VJ4e311a625836374adf4cfaa841224840dbeb7619', 'VJ2c87b2a59184888f3175b55bde7b02d024ea8607', 'VJ26095b8f9f9db92ca2e53d4c086a7dcd82a13be9', 'VJdb0c128567fcbcc063d554ae1c95851cee41b909', 'VJ5909ba51575a9459eb0013fbd31c8205455ca2fd', 'VJa7f37392e276aeac26c7e73bbc05e6a71af38dba', 'VJb93a17a405fe502c5b3a2d6544105b0311da9fe2', 'VJ2aba67e3ed98f2ed5f5966c1ac394cbf6d1943d7', 'VJ12ba6089dfb2733e29c415a1a0015fef30fd5305', 'VJ4c6fa387b0d4be94a6c3679b94790b183e2558ca', 'VJdf3936da1a51eb33db594ef99738802c14b19995', 'VJf9a22035ae6f25bb420df833474943ad76065c89', 'VJ323d02e117552af1565f2ff1273a612655c829c4'}\n2023-12-08 13:44:21,875 - Removed Services with IDs `15660`, and Routes: {'VJ3716910ec59c370d9f5c69137df7276b68cf0a08', 'VJf2e0de4f5dad68cb03064e6064e372dde52cc678', 'VJ1cf651142378958b52229bfe1fa552e49136e60e'}\n2023-12-08 13:44:21,912 - Removed Services with IDs `18853`, and Routes: {'VJ8cacca9a6722c497c413005568182ecf4d50b160', 'VJfc4917783c2ca3227789fa7c532c9adf47702095', 'VJf3e316e5e605bb512147dee2a989be5a82ef1b5f'}\n2023-12-08 13:44:21,938 - Removed Services with IDs `15234`, and Routes: {'VJ5b511605b1e07428c2e0a7d676d301c6c40dcca6', 'VJ28a8a6a4ab02807a4fdfd199e5c2ca0622d34d0c', 'VJ3d50b96792ae8495dbe5a5e372849a60c48b2279', 'VJd4cbfb092a104ac6a3164a86e9765f68734fdfcf', 'VJ652c769bc42361cc0308dff59a1fdcf0949bdade', 'VJ8ccf92aa0f351b2e31f1a078b968dff4c2505c02', 'VJ1a8cc306354fdc322d739ae644eb73444341d08d', 'VJ9b58a59e3d74941586a5bca7726a8aa624da67fc', 'VJbf9d4fdb976223e6a026c0c669ed290418abefee'}\n2023-12-08 13:44:21,963 - Removed Services with IDs `17732`, and Routes: {'VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a', 'VJ85c23573d670bab5485618b0c5fddff3314efc89'}\n2023-12-08 13:44:21,979 - Removed Services with IDs `14073`, and Routes: {'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13', 'VJaa5ee0daec7529d7668c81fe7fac0c4ff545daea', 'VJe18efadf172576fea7989ec1f233f26854c0f66a', 'VJfc35884fc4f11dc408a209c19f56f3b60f634daf', 'VJe8cffad09738ff7b9698b333e3247918d5c45358', 'VJb4309b7a9598539ab9942ea1bcadc60a91b978ba', 'VJ24fe211d801738b556a39f815256d7f6bc544ec5', 'VJdbc280077e505b4f8d66586ca51751a125cb4ef0', 'VJc8cdbd902dadeebeeb4dbd7332b564ee2e4b00ce', 'VJd9dbeefeca6d74ef2594a17514ebc08ee2d503b2', 'VJea6046f64f85febf1854290fb8f76e921e3ac96b', 'VJd132b905afc6c0e8e8a994142e301ca5c0f70e22', 'VJe6ba07ef9f19ae40517261ad626bf34dd656491a', 'VJ93d8207ae8540b4ff59d47c9ee1ec5689084522d', 'VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc'}\n2023-12-08 13:44:21,981 - Removed Stops with indices `['490000173JB.link:1663', 'other_new_stop']`.Routes affected: set(). Services affected: set().\n2023-12-08 13:44:21,990 - Param: strongly_connected_modes is defaulting to `{'car', 'walk', 'bike'}` You can change this behaviour by passing the parameter.\n2023-12-08 13:44:21,995 - The graph for mode car is not strongly connected. The largest 1 connected components will be extracted.\n2023-12-08 13:44:22,000 - Extracting largest connected components resulted in mode: car being deleted from 82 edges\n/Users/bryn.pickering/Repos/arup-group/genet/genet/core.py:674: UserWarning: Boolean Series key will be reindexed to match DataFrame index.\n  df = df.loc[df.index.intersection(links)][df[\"modes\"].apply(lambda x: bool(mode &amp; x))]\n2023-12-08 13:44:22,033 - Changed Link attributes for 82 links\n2023-12-08 13:44:22,036 - Removed 56 links\n2023-12-08 13:44:22,037 - The graph for modes: walk does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2023-12-08 13:44:22,038 - The graph for modes: bike does not have any connected components. This method returns True because if the graph is empty for this mode there is no reason to fail this check.\n2023-12-08 13:44:22,039 - Subsetted Network is ready - do not forget to validate and visualise your subset!\n</pre> Out[66]: <pre>&lt;Network instance at 11001368784: with \ngraph: MultiDiGraph with 156 nodes and 203 edges and \nschedule Schedule:\nNumber of services: 1\nNumber of routes: 12\nNumber of stops: 83</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/5_2_modifying_network_pt_schedule/#52-modifying-the-network-object-public-transport-schedules","title":"5.2. Modifying the <code>Network</code> object: Public transport schedules\u00b6","text":"<p>GeNet has a number of methods to change the Schedule objects. Available as a jupyter notebook or wiki page. Make sure you validate the end result.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#adding-routes-services","title":"Adding Routes, Services\u00b6","text":"<p>You can add <code>Route</code>s and <code>Service</code>s. To add a <code>Route</code>, you need to identify which existing <code>Service</code> it should come under.</p> <p>You can make Routes by specifying a headway parameter, that will generate explicit trips for you:</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#routing-added-servicesroutes","title":"Routing added Services/Routes\u00b6","text":"<p>You can use methods in GeNet to relate the Stops of PT services and find network routes between them. First you need to know the ID of the Service you want to snap (you can also snap the entire schedule, but depending on the size and complexity of your network and schedule it might take a long time). GeNet will then relate all stops in that service to a link in the Network graph and route all of the <code>Route</code>s of the <code>Service</code> object. It will do this for directed subsets (subgraphs) of the Service (e.g. if you have a Northbound and Southboud service, the stops may have to find different links in the graph)</p> <p>There are a lot of different parameters you can add to this method, that give you a bit more control.</p> <ul> <li><code>solver</code>: You can specify different mathematical solvers. For example GLPK, an open source solver which can be found here: https://www.gnu.org/software/glpk/. Another good open source choice is CBC: https://projects.coin-or.org/Cbc. You specify it as a string e.g. 'glpk', 'cbc', 'gurobi'. The solver needs to support MILP - mixed integer linear programming</li> <li><code>allow_partial</code>: Sometimes there isn't a link available for snapping within threshold for all stops. If allowed (default) an artificial self-loop link will be created as well as any connecting links to that unsnapped stop, under modal conditions. If set to False and the problem is partial, it will raise PartialMaxStableSetProblem error instead.</li> <li><code>distance_threshold</code>, <code>step_size</code>: You can vary the threshold for snapping stops to links. There are two parameters, the overall threshold and a step size; when snapping, the search area for links increases in steps until some links are found, we don't use the threshold right away because we don't want to have too many choices for snapping (makes it a little less heavy computationally)).</li> <li><code>additional_modes</code>: You can specify additional modes (when snapping, genet will consider a modal subset of the network that matches the pt service, e.g. bus, but you might want to use links that allow cars too).</li> <li><code>allow_directional_split</code>: You can opt for splitting the problem of snapping by direction. GeNet will then solve a series of problems for subgraphs (disjoint w.r.t. edges) of the Service. This is useful for rail type services that might share the same stop regardless of direction (in comparison to buses which have distinct bus stops, depending on which way they're travelling).</li> </ul> <p>Check the methods' doc strings for up to date details.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#reindexing","title":"Reindexing\u00b6","text":""},{"location":"examples/5_2_modifying_network_pt_schedule/#removing-stops-routes-services","title":"Removing Stops, Routes, Services\u00b6","text":""},{"location":"examples/5_2_modifying_network_pt_schedule/#modifying-data-stored-for-stops-routes-services","title":"Modifying data stored for Stops, Routes, Services\u00b6","text":""},{"location":"examples/5_2_modifying_network_pt_schedule/#applying-known-or-pre-computed-changes","title":"Applying known or pre-computed changes\u00b6","text":"<p>Applying changes or new attributes to Services, Routes and Stops can be done via Schedule level methods. They all work with a dictionary where the keys are the object IDs and the values are dictionaries holding attribute names and values. The method to extract a DataFrame on attributes comes in handy here. E.g.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#trip-and-vehicle-changes","title":"Trip and vehicle changes\u00b6","text":"<p>You can use <code>trips_to_dataframe</code> to extract all of the trips, their departures and vehicle IDs associated with the trips in the schedule. Trip ids need not be unique, route IDs provide a secondary index. Associated service IDs are also given for convenience.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#generating-new-trips-using-headway-information","title":"Generating new trips using headway information\u00b6","text":"<p>You can replace old trips using headway information. This is useful when creating scenario networks. You can do it to a Route or Service (by specifying the route ID to be changed within) objects.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#applying-changes-using-functions-or-dictionary-mappings","title":"Applying changes using functions or dictionary mappings\u00b6","text":"<p>If you have some logic that can be written into a function of object's attributes, you can pass this to <code>apply_function_to_x</code> methods. You need to select <code>location</code>, which refers to the name of the attribute the result should be stored under. It can already exist and be overwritten. The function passed, is not expected to work with all objects. It will fail silently, only evaluating and generating outputs where possible.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#subsetting","title":"Subsetting\u00b6","text":"<p>You can subset the Schedule object using Service IDs.</p>"},{"location":"examples/5_2_modifying_network_pt_schedule/#spatial-subsetting","title":"Spatial Subsetting\u00b6","text":"<p>There is a convenience method to extract a subset schedule using spatial conditions - refer to Using Schedule notebook or docs to learn more about what spatial inputs are supported.</p>"},{"location":"examples/5_3_modifying_network_simplification/","title":"5.3. Modifying the object: Simplifying","text":"In\u00a0[1]: Copied! <pre>import importlib_resources\n\nfrom genet import read_osm\n\nn = read_osm(\n    \"example_data/example.osm\",\n    importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"slim_config.yml\",\n    epsg=\"epsg:27700\",\n)\nn.print()\n</pre> import importlib_resources  from genet import read_osm  n = read_osm(     \"example_data/example.osm\",     importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"slim_config.yml\",     epsg=\"epsg:27700\", ) n.print() <pre>2022-07-14 16:04:32,948 - Building OSM graph from file example_data/example.osm\n2022-07-14 16:04:33,358 - Creating networkx graph from OSM data\n2022-07-14 16:04:33,360 - OSM: Extract Nodes and Paths from OSM data\n2022-07-14 16:04:33,653 - OSM: Add each OSM way (aka, path) to the OSM graph\n2022-07-14 16:04:33,654 - Created OSM edges\n2022-07-14 16:04:34,608 - Added 8695 nodes\n2022-07-14 16:04:39,558 - Generated 802 link ids.\n2022-07-14 16:04:39,748 - Added 802 links\n2022-07-14 16:04:39,749 - Deleting isolated nodes which have no edges.\n2022-07-14 16:04:39,972 - Removed 8132 nodes.\n</pre> <pre>Graph info: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 563\nNumber of edges: 802\nAverage in degree:   1.4245\nAverage out degree:   1.4245 \nSchedule info: Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0\n</pre> <p>You can simplify a <code>genet.Network</code> using the <code>simplify</code> method.</p> In\u00a0[2]: Copied! <pre>n.simplify(no_processes=1)\n\nn.print()\n</pre> n.simplify(no_processes=1)  n.print() <pre>2022-07-14 16:04:39,982 - Begin simplifying the graph\n2022-07-14 16:04:39,985 - Generating paths to be simplified\n2022-07-14 16:04:39,990 - Identified 114 edge endpoints\n2022-07-14 16:04:39,991 - Identified 163 possible paths\n2022-07-14 16:04:39,993 - Processing 163 paths\n2022-07-14 16:04:39,995 - Found 110 paths to simplify.\n2022-07-14 16:04:39,996 - Generated 110 link ids.\n2022-07-14 16:04:40,007 - Processing links for all paths to be simplified\n2022-07-14 16:04:40,032 - Adding new simplified links\n2022-07-14 16:04:40,057 - Generated 0 link ids.\n2022-07-14 16:04:40,078 - Added 110 links\n2022-07-14 16:04:40,084 - Simplified graph: 563 to 114 nodes, 802 to 163 edges\n</pre> <pre>Graph info: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 114\nNumber of edges: 163\nAverage in degree:   1.4298\nAverage out degree:   1.4298 \nSchedule info: Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0\n</pre> <p>Specifying number of processes is optional but defaults to 1. It is recommended you select a number appropriate for  the machine you're using to spread the computational load. Having said that, we have seen large memory spikes when using more than one process. It may take a few attempts to get this number right.</p> <p>This is a complicated process and can take a long time. To that end, it may be more convenient to use a script, see an example <code>scripts/simplify_network.py</code>.</p> <p>The process is an altered version of graph simplification available in the <code>osmnx</code> package. Network links will be simplified between end-point nodes which meet the following conditions:</p> <ul> <li>the number of nodes in the union of successor and predecessor nodes of that node is greater than two<ul> <li>i.e. if the node is connected to more than one node in any direction it cannot be simplified</li> </ul> </li> <li>the node has no successor or predecessor nodes<ul> <li>i.e. the node is a sink or source</li> </ul> </li> <li>there is a loop at the node<ul> <li>the only successor node is the node itself</li> </ul> </li> <li>the number of successor and predecessor nodes is not equal<ul> <li>this should be thought of cases where number of successor and predecessor nodes is 0, 1 or 2 (earlier condition prohibits other cases). This condition means we end link simplification at nodes where direction of flow changes so in a situation where <code>... NODE_1 ---&gt; NODE_2 &lt;--&gt; NODE_3 ...</code>, <code>NODE_2</code> will be be an endpoint and remain in the graph</li> </ul> </li> <li>if the number of nodes in the union of successor and predecessor nodes is 1 and that node is both the successor and predecessor node<ul> <li>i.e. <code>... NODE_1 &lt;--&gt; NODE_2 &lt;--&gt; NODE_3</code>, <code>NODE_3</code> will be an endpoint to avoid cul-de-sacs being big loops at single point in the graph</li> </ul> </li> </ul> <p>Below is an example of a simplified network.</p> <p></p> <p></p> <p>Upon simplification, the nodes which are being simplified are used for the creation of geometry for the link. This geometry is used in any geojson outputs, preserving the original look of the network. The data stored under links which are being simplified is fused handles in the following way:</p> <ul> <li><code>freespeed</code>: The maximum value across links is taken</li> <li><code>capacity</code>: Rounded up to integer of median across links</li> <li><code>permlanes</code>: Rounded up to integer of median across links</li> <li><code>length</code>: Sum across links</li> <li><code>modes</code>: Union across links, i.e. <code>{'bus'} | {'car'} = {'bus', 'car}'</code></li> <li>In the case of overlapping OSM attributes such as osm ids or highway types they are stored as sets under the same attributes in the graph.</li> </ul> <pre>&gt;&gt;&gt; n.link('12')['attributes']['osm:way:osmid'] = {'123','124'}\n</pre> <p>GeNet by default supports such mixture of data types when filtering the network on conditions e.g. to get links with OSM ids 123, you need only use the familiar syntax:</p> <pre>osm_id_123_links = genet.graph_operations.extract_links_on_edge_attributes(\n        n,\n        conditions= {'attributes': {'osm:way:highway': '123'}}\n    )\n</pre> <p>If you need this method to work only for non iterable values, you need to specify <code>mixed_dtypes=False</code>:</p> <pre>osm_id_123_links = genet.graph_operations.extract_links_on_edge_attributes(\n        n,\n        conditions= {'attributes': {'osm:way:highway': '123'}},\n        mixed_dtypes=False\n    )\n</pre> <p>This will result in link with id <code>12</code> not being included in the resulting <code>osm_id_123_links</code>.</p> <p>In the output MATSim network these are saved as comma separated values under link attributes. Upon reading such a network into GeNet, the attributes become sets again. The geometry is also saved to a MATSim network under attributes and encoded as polyline. Unlike other attributes, upon reading it back with GeNet the geometry is decoded into <code>shapely.LineString</code> and becomes a main data key, i.e.</p> <pre><code>&gt;&gt;&gt; n.link_attribute_summary()\n\nattribute\n\u251c\u2500\u2500 id ['12']\n\u251c\u2500\u2500 geometry [LineString((x,y), (v,w)]\n...\n\u2514\u2500\u2500 attributes\n    ...\n    \u2514\u2500\u2500 osm:way:highway [{'residential','minor'}]</code></pre> <p>instead of</p> <pre><code>&gt;&gt;&gt; n.link_attribute_summary()\n\nattribute\n\u251c\u2500\u2500 id ['12']\n...\n\u2514\u2500\u2500 attributes\n    \u251c\u2500\u2500 geometry ['}qtqa{aBwfc`_y`@jfq|Hdzm~A...']\n    ...\n    \u2514\u2500\u2500 osm:way:highway [{'residential','minor'}]</code></pre> <p>This is the same schema as for the network right after simplification, before it is saved. The output MATSim link is saved in the following way:</p> <pre>&lt;link id=\"12\" from=\"NODE_1\" to=\"NODE_4\" freespeed=\"12.5\" capacity=\"600\" permlanes=\"1\" oneway=\"1\" modes=\"car,walk,bike\" length=\"232.733\"&gt;\n    &lt;attributes&gt;\n        &lt;attribute name=\"osm:way:osmid\" class=\"java.lang.String\"&gt;123,124&lt;/attribute&gt;\n        &lt;attribute name=\"osm:way:highway\" class=\"java.lang.String\"&gt;residential,minor&lt;/attribute&gt;\n        &lt;attribute name=\"osm:way:lanes\" class=\"java.lang.String\"&gt;1&lt;/attribute&gt;\n        &lt;attribute name=\"geometry\" class=\"java.lang.String\"&gt;}qtqa{aBwfc`_y`@jfq|Hdzm~Adn~tMlnkoDlpa|OttblF&lt;/attribute&gt;\n    &lt;/attributes&gt;\n&lt;/link&gt;\n</pre>"},{"location":"examples/5_3_modifying_network_simplification/#53-modifying-the-network-object-simplifying","title":"5.3. Modifying the <code>Network</code> object: Simplifying\u00b6","text":"<p>This page goes through network simplification in GeNet. Available as a jupyter notebook or wiki page.</p> <p>Using OSM data to generate a network results in a very node-dense network. GeNet has methods to simplify such networks.</p>"},{"location":"examples/5_3_modifying_network_simplification/#attention-always-make-sure-to-validate-connectivity-of-the-simplified-network","title":"! Attention - Always make sure to validate connectivity of the simplified network\u00b6","text":"<p>In case of <code>Network</code>s featuring a <code>Schedule</code>. After the process of simplifying the <code>Network</code> graph is complete all of the link references for PT stops get checked and updated by simplified links. All of the network routes also get updated by simplified links. Because our condition for simplification is in-degree = out-degree = 1, the updated do not have the potential to disrupt the PT network route. It could mean that two or more stops could now refer to the same long link. It is encouraged that you run validation on your network post simplification (included in <code>scripts/simplify_network.py</code>) and verify your network visually.</p>"},{"location":"examples/5_4_modifying_network_addition/","title":"5.4. Modifying the object: Addition","text":"In\u00a0[1]: Copied! <pre>import importlib_resources\n\nfrom genet import read_osm\n\n_n_tiny = read_osm(\n    \"example_data/tiny_example.osm\",\n    importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"default_config.yml\",\n    epsg=\"epsg:27700\",\n)\n_n_tiny\n</pre> import importlib_resources  from genet import read_osm  _n_tiny = read_osm(     \"example_data/tiny_example.osm\",     importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"default_config.yml\",     epsg=\"epsg:27700\", ) _n_tiny <pre>2022-07-14 15:59:27,733 - Building OSM graph from file example_data/tiny_example.osm\n2022-07-14 15:59:27,820 - Creating networkx graph from OSM data\n2022-07-14 15:59:27,821 - OSM: Extract Nodes and Paths from OSM data\n2022-07-14 15:59:27,847 - OSM: Add each OSM way (aka, path) to the OSM graph\n2022-07-14 15:59:27,848 - Created OSM edges\n2022-07-14 15:59:27,974 - Added 810 nodes\n2022-07-14 15:59:30,482 - Generated 275 link ids.\n2022-07-14 15:59:30,553 - Added 275 links\n2022-07-14 15:59:30,554 - Deleting isolated nodes which have no edges.\n2022-07-14 15:59:30,633 - Removed 634 nodes.\n</pre> Out[1]: <pre>&lt;Network instance at 140176888271440: with \ngraph: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 176\nNumber of edges: 275\nAverage in degree:   1.5625\nAverage out degree:   1.5625 and \nschedule Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0</pre> In\u00a0[2]: Copied! <pre># _n_tiny.plot()\n</pre> # _n_tiny.plot() In\u00a0[3]: Copied! <pre>_n = read_osm(\n    \"example_data/example.osm\",\n    importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"slim_config.yml\",\n    epsg=\"epsg:27700\",\n)\n_n\n</pre> _n = read_osm(     \"example_data/example.osm\",     importlib_resources.files(\"genet\") / \"configs\" / \"OSM\" / \"slim_config.yml\",     epsg=\"epsg:27700\", ) _n <pre>2022-07-14 15:59:30,750 - Building OSM graph from file example_data/example.osm\n2022-07-14 15:59:31,091 - Creating networkx graph from OSM data\n2022-07-14 15:59:31,091 - OSM: Extract Nodes and Paths from OSM data\n2022-07-14 15:59:31,260 - OSM: Add each OSM way (aka, path) to the OSM graph\n2022-07-14 15:59:31,262 - Created OSM edges\n2022-07-14 15:59:32,314 - Added 8695 nodes\n2022-07-14 15:59:37,207 - Generated 802 link ids.\n2022-07-14 15:59:37,399 - Added 802 links\n2022-07-14 15:59:37,400 - Deleting isolated nodes which have no edges.\n2022-07-14 15:59:37,634 - Removed 8132 nodes.\n</pre> Out[3]: <pre>&lt;Network instance at 140177000302160: with \ngraph: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 563\nNumber of edges: 802\nAverage in degree:   1.4245\nAverage out degree:   1.4245 and \nschedule Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0</pre> In\u00a0[4]: Copied! <pre># _n.plot()\n</pre> # _n.plot() <p>The <code>add</code> method actually adds one <code>Network</code> onto another, rather than create a new instance to save some memory. The <code>Network</code> being added will inherit or change link or node ids depending on the <code>Network</code> it's being added to.</p> In\u00a0[5]: Copied! <pre>_n.add(_n_tiny)\n</pre> _n.add(_n_tiny) <pre>2022-07-14 15:59:37,677 - Generated node id 7195968685.\n2022-07-14 15:59:37,681 - Changed Link attributes for 1 links\n2022-07-14 15:59:37,687 - Changed Link attributes for 0 links\n2022-07-14 15:59:37,697 - Changed Node attributes under index: 101998\n2022-07-14 15:59:37,700 - Changed Node index from 101998 to 7195968685\n2022-07-14 15:59:37,702 - Generated node id 7195968686.\n2022-07-14 15:59:37,710 - Changed Link attributes for 2 links\n2022-07-14 15:59:37,715 - Changed Link attributes for 2 links\n2022-07-14 15:59:37,722 - Changed Node attributes under index: 1684410096\n2022-07-14 15:59:37,728 - Changed Node index from 1684410096 to 7195968686\n/Users/kasia.kozlowska/PycharmProjects/ABM/genet/genet/utils/graph_operations.py:348: UserWarning: Boolean Series key will be reindexed to match DataFrame index.\n  for idx in s2_id_df.dropna()[s2_id_df['right'] != s2_id_df['left']].index]\n2022-07-14 15:59:37,736 - Finished consolidating node indexing between the two graphs\n2022-07-14 15:59:43,839 - Removed 74 links\n2022-07-14 15:59:43,842 - Generated 1 link ids.\n2022-07-14 15:59:43,843 - Generated link id 802.\n2022-07-14 15:59:43,852 - Changed Link attributes under index: 83\n2022-07-14 15:59:43,853 - Changed Link index from 83 to 802\n2022-07-14 15:59:43,858 - Generated 1 link ids.\n2022-07-14 15:59:43,861 - Generated link id 803.\n2022-07-14 15:59:43,875 - Changed Link attributes under index: 86\n2022-07-14 15:59:43,876 - Changed Link index from 86 to 803\n2022-07-14 15:59:43,879 - Generated 1 link ids.\n2022-07-14 15:59:43,882 - Generated link id 804.\n2022-07-14 15:59:43,905 - Changed Link attributes under index: 219\n2022-07-14 15:59:43,907 - Changed Link index from 219 to 804\n2022-07-14 15:59:43,909 - Generated 1 link ids.\n2022-07-14 15:59:43,911 - Generated link id 805.\n2022-07-14 15:59:43,946 - Changed Link attributes under index: 185\n2022-07-14 15:59:43,947 - Changed Link index from 185 to 805\n2022-07-14 15:59:43,950 - Generated 1 link ids.\n2022-07-14 15:59:43,951 - Generated link id 806.\n2022-07-14 15:59:43,980 - Changed Link attributes under index: 113\n2022-07-14 15:59:43,981 - Changed Link index from 113 to 806\n2022-07-14 15:59:43,985 - Generated 1 link ids.\n2022-07-14 15:59:43,992 - Generated link id 807.\n2022-07-14 15:59:44,010 - Changed Link attributes under index: 123\n2022-07-14 15:59:44,011 - Changed Link index from 123 to 807\n2022-07-14 15:59:44,013 - Generated 1 link ids.\n2022-07-14 15:59:44,014 - Generated link id 808.\n2022-07-14 15:59:44,033 - Changed Link attributes under index: 189\n2022-07-14 15:59:44,035 - Changed Link index from 189 to 808\n2022-07-14 15:59:44,041 - Generated 1 link ids.\n2022-07-14 15:59:44,057 - Generated link id 809.\n2022-07-14 15:59:44,070 - Changed Link attributes under index: 237\n2022-07-14 15:59:44,076 - Changed Link index from 237 to 809\n2022-07-14 15:59:44,079 - Generated 1 link ids.\n2022-07-14 15:59:44,080 - Generated link id 810.\n2022-07-14 15:59:44,097 - Changed Link attributes under index: 75\n2022-07-14 15:59:44,099 - Changed Link index from 75 to 810\n2022-07-14 15:59:44,103 - Generated 1 link ids.\n2022-07-14 15:59:44,112 - Generated link id 811.\n2022-07-14 15:59:44,135 - Changed Link attributes under index: 11\n2022-07-14 15:59:44,141 - Changed Link index from 11 to 811\n2022-07-14 15:59:44,145 - Generated 1 link ids.\n2022-07-14 15:59:44,147 - Generated link id 812.\n2022-07-14 15:59:44,166 - Changed Link attributes under index: 18\n2022-07-14 15:59:44,168 - Changed Link index from 18 to 812\n2022-07-14 15:59:44,171 - Generated 1 link ids.\n2022-07-14 15:59:44,177 - Generated link id 813.\n2022-07-14 15:59:44,198 - Changed Link attributes under index: 167\n2022-07-14 15:59:44,200 - Changed Link index from 167 to 813\n2022-07-14 15:59:44,214 - Generated 1 link ids.\n2022-07-14 15:59:44,230 - Generated link id 814.\n2022-07-14 15:59:44,247 - Changed Link attributes under index: 43\n2022-07-14 15:59:44,250 - Changed Link index from 43 to 814\n2022-07-14 15:59:44,262 - Generated 1 link ids.\n2022-07-14 15:59:44,263 - Generated link id 815.\n2022-07-14 15:59:44,281 - Changed Link attributes under index: 223\n2022-07-14 15:59:44,282 - Changed Link index from 223 to 815\n2022-07-14 15:59:44,284 - Generated 1 link ids.\n2022-07-14 15:59:44,286 - Generated link id 816.\n2022-07-14 15:59:44,304 - Changed Link attributes under index: 256\n2022-07-14 15:59:44,306 - Changed Link index from 256 to 816\n2022-07-14 15:59:44,309 - Generated 1 link ids.\n2022-07-14 15:59:44,311 - Generated link id 817.\n2022-07-14 15:59:44,325 - Changed Link attributes under index: 13\n2022-07-14 15:59:44,326 - Changed Link index from 13 to 817\n2022-07-14 15:59:44,329 - Generated 1 link ids.\n2022-07-14 15:59:44,331 - Generated link id 818.\n2022-07-14 15:59:44,344 - Changed Link attributes under index: 165\n2022-07-14 15:59:44,346 - Changed Link index from 165 to 818\n2022-07-14 15:59:44,350 - Generated 1 link ids.\n2022-07-14 15:59:44,354 - Generated link id 819.\n2022-07-14 15:59:44,374 - Changed Link attributes under index: 254\n2022-07-14 15:59:44,377 - Changed Link index from 254 to 819\n2022-07-14 15:59:44,380 - Generated 1 link ids.\n2022-07-14 15:59:44,389 - Generated link id 820.\n2022-07-14 15:59:44,401 - Changed Link attributes under index: 57\n2022-07-14 15:59:44,405 - Changed Link index from 57 to 820\n2022-07-14 15:59:44,411 - Generated 1 link ids.\n2022-07-14 15:59:44,412 - Generated link id 821.\n2022-07-14 15:59:44,431 - Changed Link attributes under index: 12\n2022-07-14 15:59:44,433 - Changed Link index from 12 to 821\n2022-07-14 15:59:44,436 - Generated 1 link ids.\n2022-07-14 15:59:44,440 - Generated link id 822.\n2022-07-14 15:59:44,454 - Changed Link attributes under index: 32\n2022-07-14 15:59:44,456 - Changed Link index from 32 to 822\n2022-07-14 15:59:44,462 - Generated 1 link ids.\n2022-07-14 15:59:44,463 - Generated link id 823.\n2022-07-14 15:59:44,477 - Changed Link attributes under index: 240\n2022-07-14 15:59:44,479 - Changed Link index from 240 to 823\n2022-07-14 15:59:44,481 - Generated 1 link ids.\n2022-07-14 15:59:44,483 - Generated link id 824.\n2022-07-14 15:59:44,492 - Changed Link attributes under index: 262\n2022-07-14 15:59:44,495 - Changed Link index from 262 to 824\n2022-07-14 15:59:44,499 - Generated 1 link ids.\n2022-07-14 15:59:44,501 - Generated link id 825.\n2022-07-14 15:59:44,534 - Changed Link attributes under index: 144\n2022-07-14 15:59:44,543 - Changed Link index from 144 to 825\n2022-07-14 15:59:44,546 - Generated 1 link ids.\n2022-07-14 15:59:44,550 - Generated link id 826.\n2022-07-14 15:59:44,574 - Changed Link attributes under index: 242\n2022-07-14 15:59:44,578 - Changed Link index from 242 to 826\n2022-07-14 15:59:44,582 - Generated 1 link ids.\n2022-07-14 15:59:44,583 - Generated link id 827.\n2022-07-14 15:59:44,606 - Changed Link attributes under index: 173\n2022-07-14 15:59:44,616 - Changed Link index from 173 to 827\n2022-07-14 15:59:44,622 - Generated 1 link ids.\n2022-07-14 15:59:44,646 - Generated link id 828.\n2022-07-14 15:59:44,729 - Changed Link attributes under index: 180\n2022-07-14 15:59:44,733 - Changed Link index from 180 to 828\n2022-07-14 15:59:44,765 - Generated 1 link ids.\n2022-07-14 15:59:44,773 - Generated link id 829.\n2022-07-14 15:59:44,815 - Changed Link attributes under index: 202\n2022-07-14 15:59:44,817 - Changed Link index from 202 to 829\n2022-07-14 15:59:44,821 - Generated 1 link ids.\n2022-07-14 15:59:44,823 - Generated link id 830.\n2022-07-14 15:59:44,848 - Changed Link attributes under index: 92\n2022-07-14 15:59:44,850 - Changed Link index from 92 to 830\n2022-07-14 15:59:44,866 - Generated 1 link ids.\n2022-07-14 15:59:44,869 - Generated link id 831.\n2022-07-14 15:59:44,887 - Changed Link attributes under index: 53\n2022-07-14 15:59:44,889 - Changed Link index from 53 to 831\n2022-07-14 15:59:44,894 - Generated 1 link ids.\n2022-07-14 15:59:44,897 - Generated link id 832.\n2022-07-14 15:59:44,913 - Changed Link attributes under index: 3\n2022-07-14 15:59:44,927 - Changed Link index from 3 to 832\n2022-07-14 15:59:44,937 - Generated 1 link ids.\n2022-07-14 15:59:44,948 - Generated link id 833.\n2022-07-14 15:59:44,960 - Changed Link attributes under index: 198\n2022-07-14 15:59:44,961 - Changed Link index from 198 to 833\n2022-07-14 15:59:44,964 - Generated 1 link ids.\n</pre> <pre>2022-07-14 15:59:44,966 - Generated link id 834.\n2022-07-14 15:59:44,978 - Changed Link attributes under index: 99\n2022-07-14 15:59:44,979 - Changed Link index from 99 to 834\n2022-07-14 15:59:44,981 - Generated 1 link ids.\n2022-07-14 15:59:44,983 - Generated link id 835.\n2022-07-14 15:59:44,992 - Changed Link attributes under index: 241\n2022-07-14 15:59:44,993 - Changed Link index from 241 to 835\n2022-07-14 15:59:44,995 - Generated 1 link ids.\n2022-07-14 15:59:44,995 - Generated link id 836.\n2022-07-14 15:59:45,005 - Changed Link attributes under index: 48\n2022-07-14 15:59:45,007 - Changed Link index from 48 to 836\n2022-07-14 15:59:45,009 - Generated 1 link ids.\n2022-07-14 15:59:45,010 - Generated link id 837.\n2022-07-14 15:59:45,022 - Changed Link attributes under index: 101\n2022-07-14 15:59:45,024 - Changed Link index from 101 to 837\n2022-07-14 15:59:45,027 - Generated 1 link ids.\n2022-07-14 15:59:45,028 - Generated link id 838.\n2022-07-14 15:59:45,036 - Changed Link attributes under index: 274\n2022-07-14 15:59:45,038 - Changed Link index from 274 to 838\n2022-07-14 15:59:45,040 - Generated 1 link ids.\n2022-07-14 15:59:45,041 - Generated link id 839.\n2022-07-14 15:59:45,048 - Changed Link attributes under index: 269\n2022-07-14 15:59:45,049 - Changed Link index from 269 to 839\n2022-07-14 15:59:45,050 - Generated 1 link ids.\n2022-07-14 15:59:45,052 - Generated link id 840.\n2022-07-14 15:59:45,066 - Changed Link attributes under index: 116\n2022-07-14 15:59:45,068 - Changed Link index from 116 to 840\n2022-07-14 15:59:45,077 - Generated 1 link ids.\n2022-07-14 15:59:45,078 - Generated link id 841.\n2022-07-14 15:59:45,090 - Changed Link attributes under index: 163\n2022-07-14 15:59:45,093 - Changed Link index from 163 to 841\n2022-07-14 15:59:45,096 - Generated 1 link ids.\n2022-07-14 15:59:45,097 - Generated link id 842.\n2022-07-14 15:59:45,115 - Changed Link attributes under index: 182\n2022-07-14 15:59:45,116 - Changed Link index from 182 to 842\n2022-07-14 15:59:45,120 - Generated 1 link ids.\n2022-07-14 15:59:45,128 - Generated link id 843.\n2022-07-14 15:59:45,141 - Changed Link attributes under index: 15\n2022-07-14 15:59:45,143 - Changed Link index from 15 to 843\n2022-07-14 15:59:45,146 - Generated 1 link ids.\n2022-07-14 15:59:45,148 - Generated link id 844.\n2022-07-14 15:59:45,165 - Changed Link attributes under index: 261\n2022-07-14 15:59:45,166 - Changed Link index from 261 to 844\n2022-07-14 15:59:45,181 - Generated 1 link ids.\n2022-07-14 15:59:45,183 - Generated link id 845.\n2022-07-14 15:59:45,200 - Changed Link attributes under index: 5\n2022-07-14 15:59:45,206 - Changed Link index from 5 to 845\n2022-07-14 15:59:45,214 - Generated 1 link ids.\n2022-07-14 15:59:45,216 - Generated link id 846.\n2022-07-14 15:59:45,233 - Changed Link attributes under index: 16\n2022-07-14 15:59:45,234 - Changed Link index from 16 to 846\n2022-07-14 15:59:45,247 - Generated 1 link ids.\n2022-07-14 15:59:45,249 - Generated link id 847.\n2022-07-14 15:59:45,266 - Changed Link attributes under index: 196\n2022-07-14 15:59:45,270 - Changed Link index from 196 to 847\n2022-07-14 15:59:45,279 - Generated 1 link ids.\n2022-07-14 15:59:45,280 - Generated link id 848.\n2022-07-14 15:59:45,293 - Changed Link attributes under index: 222\n2022-07-14 15:59:45,294 - Changed Link index from 222 to 848\n2022-07-14 15:59:45,296 - Generated 1 link ids.\n2022-07-14 15:59:45,297 - Generated link id 849.\n2022-07-14 15:59:45,314 - Changed Link attributes under index: 78\n2022-07-14 15:59:45,316 - Changed Link index from 78 to 849\n2022-07-14 15:59:45,321 - Generated 1 link ids.\n2022-07-14 15:59:45,330 - Generated link id 850.\n2022-07-14 15:59:45,343 - Changed Link attributes under index: 245\n2022-07-14 15:59:45,344 - Changed Link index from 245 to 850\n2022-07-14 15:59:45,346 - Generated 1 link ids.\n2022-07-14 15:59:45,361 - Generated link id 851.\n2022-07-14 15:59:45,380 - Changed Link attributes under index: 156\n2022-07-14 15:59:45,381 - Changed Link index from 156 to 851\n2022-07-14 15:59:45,384 - Generated 1 link ids.\n2022-07-14 15:59:45,385 - Generated link id 852.\n2022-07-14 15:59:45,402 - Changed Link attributes under index: 55\n2022-07-14 15:59:45,405 - Changed Link index from 55 to 852\n2022-07-14 15:59:45,411 - Generated 1 link ids.\n2022-07-14 15:59:45,413 - Generated link id 853.\n2022-07-14 15:59:45,431 - Changed Link attributes under index: 148\n2022-07-14 15:59:45,442 - Changed Link index from 148 to 853\n2022-07-14 15:59:45,450 - Generated 1 link ids.\n2022-07-14 15:59:45,454 - Generated link id 854.\n2022-07-14 15:59:45,471 - Changed Link attributes under index: 88\n2022-07-14 15:59:45,476 - Changed Link index from 88 to 854\n2022-07-14 15:59:45,480 - Generated 1 link ids.\n2022-07-14 15:59:45,481 - Generated link id 855.\n2022-07-14 15:59:45,495 - Changed Link attributes under index: 164\n2022-07-14 15:59:45,497 - Changed Link index from 164 to 855\n2022-07-14 15:59:45,500 - Generated 1 link ids.\n2022-07-14 15:59:45,502 - Generated link id 856.\n2022-07-14 15:59:45,527 - Changed Link attributes under index: 61\n2022-07-14 15:59:45,529 - Changed Link index from 61 to 856\n2022-07-14 15:59:45,532 - Generated 1 link ids.\n2022-07-14 15:59:45,533 - Generated link id 857.\n2022-07-14 15:59:45,544 - Changed Link attributes under index: 66\n2022-07-14 15:59:45,546 - Changed Link index from 66 to 857\n2022-07-14 15:59:45,550 - Generated 1 link ids.\n2022-07-14 15:59:45,553 - Generated link id 858.\n2022-07-14 15:59:45,570 - Changed Link attributes under index: 120\n2022-07-14 15:59:45,580 - Changed Link index from 120 to 858\n2022-07-14 15:59:45,583 - Generated 1 link ids.\n2022-07-14 15:59:45,584 - Generated link id 859.\n2022-07-14 15:59:45,597 - Changed Link attributes under index: 230\n2022-07-14 15:59:45,598 - Changed Link index from 230 to 859\n2022-07-14 15:59:45,600 - Generated 1 link ids.\n2022-07-14 15:59:45,601 - Generated link id 860.\n2022-07-14 15:59:45,618 - Changed Link attributes under index: 4\n2022-07-14 15:59:45,619 - Changed Link index from 4 to 860\n2022-07-14 15:59:45,630 - Generated 1 link ids.\n2022-07-14 15:59:45,632 - Generated link id 861.\n2022-07-14 15:59:45,644 - Changed Link attributes under index: 0\n2022-07-14 15:59:45,645 - Changed Link index from 0 to 861\n2022-07-14 15:59:45,648 - Generated 1 link ids.\n2022-07-14 15:59:45,650 - Generated link id 862.\n2022-07-14 15:59:45,664 - Changed Link attributes under index: 62\n2022-07-14 15:59:45,665 - Changed Link index from 62 to 862\n2022-07-14 15:59:45,669 - Generated 1 link ids.\n2022-07-14 15:59:45,681 - Generated link id 863.\n2022-07-14 15:59:45,697 - Changed Link attributes under index: 186\n2022-07-14 15:59:45,698 - Changed Link index from 186 to 863\n2022-07-14 15:59:45,701 - Generated 1 link ids.\n2022-07-14 15:59:45,713 - Generated link id 864.\n2022-07-14 15:59:45,746 - Changed Link attributes under index: 220\n2022-07-14 15:59:45,760 - Changed Link index from 220 to 864\n2022-07-14 15:59:45,763 - Generated 1 link ids.\n2022-07-14 15:59:45,765 - Generated link id 865.\n2022-07-14 15:59:45,784 - Changed Link attributes under index: 253\n2022-07-14 15:59:45,785 - Changed Link index from 253 to 865\n2022-07-14 15:59:45,791 - Generated 1 link ids.\n2022-07-14 15:59:45,795 - Generated link id 866.\n2022-07-14 15:59:45,808 - Changed Link attributes under index: 59\n2022-07-14 15:59:45,811 - Changed Link index from 59 to 866\n2022-07-14 15:59:45,817 - Generated 1 link ids.\n2022-07-14 15:59:45,818 - Generated link id 867.\n2022-07-14 15:59:45,832 - Changed Link attributes under index: 246\n2022-07-14 15:59:45,834 - Changed Link index from 246 to 867\n2022-07-14 15:59:45,836 - Generated 1 link ids.\n2022-07-14 15:59:45,838 - Generated link id 868.\n2022-07-14 15:59:45,848 - Changed Link attributes under index: 34\n2022-07-14 15:59:45,849 - Changed Link index from 34 to 868\n2022-07-14 15:59:45,850 - Generated 1 link ids.\n2022-07-14 15:59:45,856 - Generated link id 869.\n2022-07-14 15:59:45,865 - Changed Link attributes under index: 158\n2022-07-14 15:59:45,865 - Changed Link index from 158 to 869\n2022-07-14 15:59:45,867 - Generated 1 link ids.\n2022-07-14 15:59:45,869 - Generated link id 870.\n2022-07-14 15:59:45,883 - Changed Link attributes under index: 118\n2022-07-14 15:59:45,886 - Changed Link index from 118 to 870\n</pre> <pre>2022-07-14 15:59:45,888 - Generated 1 link ids.\n2022-07-14 15:59:45,890 - Generated link id 871.\n2022-07-14 15:59:45,899 - Changed Link attributes under index: 154\n2022-07-14 15:59:45,900 - Changed Link index from 154 to 871\n2022-07-14 15:59:45,901 - Generated 1 link ids.\n2022-07-14 15:59:45,904 - Generated link id 872.\n2022-07-14 15:59:45,914 - Changed Link attributes under index: 125\n2022-07-14 15:59:45,915 - Changed Link index from 125 to 872\n2022-07-14 15:59:45,917 - Generated 1 link ids.\n2022-07-14 15:59:45,918 - Generated link id 873.\n2022-07-14 15:59:45,928 - Changed Link attributes under index: 181\n2022-07-14 15:59:45,929 - Changed Link index from 181 to 873\n2022-07-14 15:59:45,930 - Generated 1 link ids.\n2022-07-14 15:59:45,931 - Generated link id 874.\n2022-07-14 15:59:45,942 - Changed Link attributes under index: 227\n2022-07-14 15:59:45,943 - Changed Link index from 227 to 874\n2022-07-14 15:59:45,946 - Generated 1 link ids.\n2022-07-14 15:59:45,947 - Generated link id 875.\n2022-07-14 15:59:45,956 - Changed Link attributes under index: 152\n2022-07-14 15:59:45,957 - Changed Link index from 152 to 875\n2022-07-14 15:59:45,958 - Generated 1 link ids.\n2022-07-14 15:59:45,960 - Generated link id 876.\n2022-07-14 15:59:45,967 - Changed Link attributes under index: 27\n2022-07-14 15:59:45,967 - Changed Link index from 27 to 876\n2022-07-14 15:59:45,970 - Generated 1 link ids.\n2022-07-14 15:59:45,971 - Generated link id 877.\n2022-07-14 15:59:45,981 - Changed Link attributes under index: 153\n2022-07-14 15:59:45,982 - Changed Link index from 153 to 877\n2022-07-14 15:59:45,984 - Generated 1 link ids.\n2022-07-14 15:59:45,985 - Generated link id 878.\n2022-07-14 15:59:45,996 - Changed Link attributes under index: 30\n2022-07-14 15:59:45,997 - Changed Link index from 30 to 878\n2022-07-14 15:59:45,998 - Generated 1 link ids.\n2022-07-14 15:59:45,999 - Generated link id 879.\n2022-07-14 15:59:46,007 - Changed Link attributes under index: 249\n2022-07-14 15:59:46,009 - Changed Link index from 249 to 879\n2022-07-14 15:59:46,011 - Generated 1 link ids.\n2022-07-14 15:59:46,012 - Generated link id 880.\n2022-07-14 15:59:46,021 - Changed Link attributes under index: 260\n2022-07-14 15:59:46,023 - Changed Link index from 260 to 880\n2022-07-14 15:59:46,026 - Generated 1 link ids.\n2022-07-14 15:59:46,027 - Generated link id 881.\n2022-07-14 15:59:46,036 - Changed Link attributes under index: 188\n2022-07-14 15:59:46,039 - Changed Link index from 188 to 881\n2022-07-14 15:59:46,042 - Generated 1 link ids.\n2022-07-14 15:59:46,043 - Generated link id 882.\n2022-07-14 15:59:46,050 - Changed Link attributes under index: 207\n2022-07-14 15:59:46,051 - Changed Link index from 207 to 882\n2022-07-14 15:59:46,053 - Generated 1 link ids.\n2022-07-14 15:59:46,057 - Generated link id 883.\n2022-07-14 15:59:46,064 - Changed Link attributes under index: 157\n2022-07-14 15:59:46,065 - Changed Link index from 157 to 883\n2022-07-14 15:59:46,067 - Generated 1 link ids.\n2022-07-14 15:59:46,068 - Generated link id 884.\n2022-07-14 15:59:46,077 - Changed Link attributes under index: 226\n2022-07-14 15:59:46,078 - Changed Link index from 226 to 884\n2022-07-14 15:59:46,079 - Generated 1 link ids.\n2022-07-14 15:59:46,080 - Generated link id 885.\n2022-07-14 15:59:46,087 - Changed Link attributes under index: 60\n2022-07-14 15:59:46,089 - Changed Link index from 60 to 885\n2022-07-14 15:59:46,092 - Generated 1 link ids.\n2022-07-14 15:59:46,093 - Generated link id 886.\n2022-07-14 15:59:46,100 - Changed Link attributes under index: 72\n2022-07-14 15:59:46,101 - Changed Link index from 72 to 886\n2022-07-14 15:59:46,104 - Generated 1 link ids.\n2022-07-14 15:59:46,107 - Generated link id 887.\n2022-07-14 15:59:46,114 - Changed Link attributes under index: 268\n2022-07-14 15:59:46,115 - Changed Link index from 268 to 887\n2022-07-14 15:59:46,117 - Generated 1 link ids.\n2022-07-14 15:59:46,118 - Generated link id 888.\n2022-07-14 15:59:46,128 - Changed Link attributes under index: 109\n2022-07-14 15:59:46,129 - Changed Link index from 109 to 888\n2022-07-14 15:59:46,130 - Generated 1 link ids.\n2022-07-14 15:59:46,131 - Generated link id 889.\n2022-07-14 15:59:46,140 - Changed Link attributes under index: 224\n2022-07-14 15:59:46,141 - Changed Link index from 224 to 889\n2022-07-14 15:59:46,143 - Generated 1 link ids.\n2022-07-14 15:59:46,144 - Generated link id 890.\n2022-07-14 15:59:46,153 - Changed Link attributes under index: 38\n2022-07-14 15:59:46,155 - Changed Link index from 38 to 890\n2022-07-14 15:59:46,158 - Generated 1 link ids.\n2022-07-14 15:59:46,159 - Generated link id 891.\n2022-07-14 15:59:46,166 - Changed Link attributes under index: 26\n2022-07-14 15:59:46,167 - Changed Link index from 26 to 891\n2022-07-14 15:59:46,194 - Generated 1 link ids.\n2022-07-14 15:59:46,194 - Generated link id 892.\n2022-07-14 15:59:46,201 - Changed Link attributes under index: 17\n2022-07-14 15:59:46,210 - Changed Link index from 17 to 892\n2022-07-14 15:59:46,211 - Generated 1 link ids.\n2022-07-14 15:59:46,212 - Generated link id 893.\n2022-07-14 15:59:46,222 - Changed Link attributes under index: 239\n2022-07-14 15:59:46,224 - Changed Link index from 239 to 893\n2022-07-14 15:59:46,228 - Generated 1 link ids.\n2022-07-14 15:59:46,230 - Generated link id 894.\n2022-07-14 15:59:46,236 - Changed Link attributes under index: 33\n2022-07-14 15:59:46,240 - Changed Link index from 33 to 894\n2022-07-14 15:59:46,246 - Generated 1 link ids.\n2022-07-14 15:59:46,247 - Generated link id 895.\n2022-07-14 15:59:46,266 - Changed Link attributes under index: 24\n2022-07-14 15:59:46,267 - Changed Link index from 24 to 895\n2022-07-14 15:59:46,279 - Generated 1 link ids.\n2022-07-14 15:59:46,280 - Generated link id 896.\n2022-07-14 15:59:46,293 - Changed Link attributes under index: 139\n2022-07-14 15:59:46,295 - Changed Link index from 139 to 896\n2022-07-14 15:59:46,297 - Generated 1 link ids.\n2022-07-14 15:59:46,299 - Generated link id 897.\n2022-07-14 15:59:46,312 - Changed Link attributes under index: 138\n2022-07-14 15:59:46,316 - Changed Link index from 138 to 897\n2022-07-14 15:59:46,321 - Generated 1 link ids.\n2022-07-14 15:59:46,326 - Generated link id 898.\n2022-07-14 15:59:46,341 - Changed Link attributes under index: 176\n2022-07-14 15:59:46,344 - Changed Link index from 176 to 898\n2022-07-14 15:59:46,348 - Generated 1 link ids.\n2022-07-14 15:59:46,349 - Generated link id 899.\n2022-07-14 15:59:46,361 - Changed Link attributes under index: 218\n2022-07-14 15:59:46,362 - Changed Link index from 218 to 899\n2022-07-14 15:59:46,364 - Generated 1 link ids.\n2022-07-14 15:59:46,368 - Generated link id 900.\n2022-07-14 15:59:46,383 - Changed Link attributes under index: 199\n2022-07-14 15:59:46,384 - Changed Link index from 199 to 900\n2022-07-14 15:59:46,397 - Generated 1 link ids.\n2022-07-14 15:59:46,398 - Generated link id 901.\n2022-07-14 15:59:46,411 - Changed Link attributes under index: 80\n2022-07-14 15:59:46,413 - Changed Link index from 80 to 901\n2022-07-14 15:59:46,418 - Generated 1 link ids.\n2022-07-14 15:59:46,419 - Generated link id 902.\n2022-07-14 15:59:46,434 - Changed Link attributes under index: 31\n2022-07-14 15:59:46,443 - Changed Link index from 31 to 902\n2022-07-14 15:59:46,449 - Generated 1 link ids.\n2022-07-14 15:59:46,459 - Generated link id 903.\n2022-07-14 15:59:46,482 - Changed Link attributes under index: 45\n2022-07-14 15:59:46,483 - Changed Link index from 45 to 903\n2022-07-14 15:59:46,486 - Generated 1 link ids.\n2022-07-14 15:59:46,488 - Generated link id 904.\n2022-07-14 15:59:46,505 - Changed Link attributes under index: 141\n2022-07-14 15:59:46,509 - Changed Link index from 141 to 904\n2022-07-14 15:59:46,513 - Generated 1 link ids.\n2022-07-14 15:59:46,514 - Generated link id 905.\n2022-07-14 15:59:46,529 - Changed Link attributes under index: 121\n2022-07-14 15:59:46,531 - Changed Link index from 121 to 905\n2022-07-14 15:59:46,533 - Generated 1 link ids.\n2022-07-14 15:59:46,534 - Generated link id 906.\n2022-07-14 15:59:46,548 - Changed Link attributes under index: 110\n2022-07-14 15:59:46,550 - Changed Link index from 110 to 906\n2022-07-14 15:59:46,554 - Generated 1 link ids.\n2022-07-14 15:59:46,559 - Generated link id 907.\n2022-07-14 15:59:46,570 - Changed Link attributes under index: 233\n</pre> <pre>2022-07-14 15:59:46,573 - Changed Link index from 233 to 907\n2022-07-14 15:59:46,577 - Generated 1 link ids.\n2022-07-14 15:59:46,578 - Generated link id 908.\n2022-07-14 15:59:46,585 - Changed Link attributes under index: 114\n2022-07-14 15:59:46,591 - Changed Link index from 114 to 908\n2022-07-14 15:59:46,595 - Generated 1 link ids.\n2022-07-14 15:59:46,596 - Generated link id 909.\n2022-07-14 15:59:46,605 - Changed Link attributes under index: 71\n2022-07-14 15:59:46,607 - Changed Link index from 71 to 909\n2022-07-14 15:59:46,609 - Generated 1 link ids.\n2022-07-14 15:59:46,610 - Generated link id 910.\n2022-07-14 15:59:46,618 - Changed Link attributes under index: 111\n2022-07-14 15:59:46,619 - Changed Link index from 111 to 910\n2022-07-14 15:59:46,627 - Generated 1 link ids.\n2022-07-14 15:59:46,628 - Generated link id 911.\n2022-07-14 15:59:46,634 - Changed Link attributes under index: 149\n2022-07-14 15:59:46,640 - Changed Link index from 149 to 911\n2022-07-14 15:59:46,642 - Generated 1 link ids.\n2022-07-14 15:59:46,643 - Generated link id 912.\n2022-07-14 15:59:46,650 - Changed Link attributes under index: 108\n2022-07-14 15:59:46,651 - Changed Link index from 108 to 912\n2022-07-14 15:59:46,657 - Generated 1 link ids.\n2022-07-14 15:59:46,659 - Generated link id 913.\n2022-07-14 15:59:46,666 - Changed Link attributes under index: 174\n2022-07-14 15:59:46,668 - Changed Link index from 174 to 913\n2022-07-14 15:59:46,676 - Generated 1 link ids.\n2022-07-14 15:59:46,676 - Generated link id 914.\n2022-07-14 15:59:46,683 - Changed Link attributes under index: 124\n2022-07-14 15:59:46,685 - Changed Link index from 124 to 914\n2022-07-14 15:59:46,691 - Generated 1 link ids.\n2022-07-14 15:59:46,692 - Generated link id 915.\n2022-07-14 15:59:46,699 - Changed Link attributes under index: 216\n2022-07-14 15:59:46,701 - Changed Link index from 216 to 915\n2022-07-14 15:59:46,708 - Generated 1 link ids.\n2022-07-14 15:59:46,709 - Generated link id 916.\n2022-07-14 15:59:46,717 - Changed Link attributes under index: 67\n2022-07-14 15:59:46,722 - Changed Link index from 67 to 916\n2022-07-14 15:59:46,725 - Generated 1 link ids.\n2022-07-14 15:59:46,726 - Generated link id 917.\n2022-07-14 15:59:46,738 - Changed Link attributes under index: 132\n2022-07-14 15:59:46,741 - Changed Link index from 132 to 917\n2022-07-14 15:59:46,745 - Generated 1 link ids.\n2022-07-14 15:59:46,760 - Generated link id 918.\n2022-07-14 15:59:46,768 - Changed Link attributes under index: 41\n2022-07-14 15:59:46,770 - Changed Link index from 41 to 918\n2022-07-14 15:59:46,774 - Generated 1 link ids.\n2022-07-14 15:59:46,777 - Generated link id 919.\n2022-07-14 15:59:46,782 - Changed Link attributes under index: 150\n2022-07-14 15:59:46,784 - Changed Link index from 150 to 919\n2022-07-14 15:59:46,787 - Generated 1 link ids.\n2022-07-14 15:59:46,789 - Generated link id 920.\n2022-07-14 15:59:46,801 - Changed Link attributes under index: 36\n2022-07-14 15:59:46,804 - Changed Link index from 36 to 920\n2022-07-14 15:59:46,810 - Generated 1 link ids.\n2022-07-14 15:59:46,811 - Generated link id 921.\n2022-07-14 15:59:46,818 - Changed Link attributes under index: 210\n2022-07-14 15:59:46,819 - Changed Link index from 210 to 921\n2022-07-14 15:59:46,823 - Generated 1 link ids.\n2022-07-14 15:59:46,825 - Generated link id 922.\n2022-07-14 15:59:46,833 - Changed Link attributes under index: 122\n2022-07-14 15:59:46,834 - Changed Link index from 122 to 922\n2022-07-14 15:59:46,836 - Generated 1 link ids.\n2022-07-14 15:59:46,837 - Generated link id 923.\n2022-07-14 15:59:46,847 - Changed Link attributes under index: 46\n2022-07-14 15:59:46,848 - Changed Link index from 46 to 923\n2022-07-14 15:59:46,850 - Generated 1 link ids.\n2022-07-14 15:59:46,851 - Generated link id 924.\n2022-07-14 15:59:46,861 - Changed Link attributes under index: 206\n2022-07-14 15:59:46,864 - Changed Link index from 206 to 924\n2022-07-14 15:59:46,869 - Generated 1 link ids.\n2022-07-14 15:59:46,870 - Generated link id 925.\n2022-07-14 15:59:46,883 - Changed Link attributes under index: 234\n2022-07-14 15:59:46,884 - Changed Link index from 234 to 925\n2022-07-14 15:59:46,887 - Generated 1 link ids.\n2022-07-14 15:59:46,896 - Generated link id 926.\n2022-07-14 15:59:46,915 - Changed Link attributes under index: 272\n2022-07-14 15:59:46,916 - Changed Link index from 272 to 926\n2022-07-14 15:59:46,918 - Generated 1 link ids.\n2022-07-14 15:59:46,928 - Generated link id 927.\n2022-07-14 15:59:46,939 - Changed Link attributes under index: 140\n2022-07-14 15:59:46,942 - Changed Link index from 140 to 927\n2022-07-14 15:59:46,947 - Generated 1 link ids.\n2022-07-14 15:59:46,948 - Generated link id 928.\n2022-07-14 15:59:46,964 - Changed Link attributes under index: 7\n2022-07-14 15:59:46,965 - Changed Link index from 7 to 928\n2022-07-14 15:59:46,976 - Generated 1 link ids.\n2022-07-14 15:59:46,977 - Generated link id 929.\n2022-07-14 15:59:46,990 - Changed Link attributes under index: 137\n2022-07-14 15:59:46,993 - Changed Link index from 137 to 929\n2022-07-14 15:59:46,995 - Generated 1 link ids.\n2022-07-14 15:59:46,996 - Generated link id 930.\n2022-07-14 15:59:47,017 - Changed Link attributes under index: 232\n2022-07-14 15:59:47,019 - Changed Link index from 232 to 930\n2022-07-14 15:59:47,027 - Generated 1 link ids.\n2022-07-14 15:59:47,029 - Generated link id 931.\n2022-07-14 15:59:47,038 - Changed Link attributes under index: 162\n2022-07-14 15:59:47,042 - Changed Link index from 162 to 931\n2022-07-14 15:59:47,045 - Generated 1 link ids.\n2022-07-14 15:59:47,046 - Generated link id 932.\n2022-07-14 15:59:47,054 - Changed Link attributes under index: 107\n2022-07-14 15:59:47,055 - Changed Link index from 107 to 932\n2022-07-14 15:59:47,060 - Generated 1 link ids.\n2022-07-14 15:59:47,061 - Generated link id 933.\n2022-07-14 15:59:47,073 - Changed Link attributes under index: 136\n2022-07-14 15:59:47,075 - Changed Link index from 136 to 933\n2022-07-14 15:59:47,077 - Generated 1 link ids.\n2022-07-14 15:59:47,078 - Generated link id 934.\n2022-07-14 15:59:47,085 - Changed Link attributes under index: 221\n2022-07-14 15:59:47,090 - Changed Link index from 221 to 934\n2022-07-14 15:59:47,096 - Generated 1 link ids.\n2022-07-14 15:59:47,097 - Generated link id 935.\n2022-07-14 15:59:47,105 - Changed Link attributes under index: 65\n2022-07-14 15:59:47,105 - Changed Link index from 65 to 935\n2022-07-14 15:59:47,108 - Generated 1 link ids.\n2022-07-14 15:59:47,111 - Generated link id 936.\n2022-07-14 15:59:47,121 - Changed Link attributes under index: 81\n2022-07-14 15:59:47,122 - Changed Link index from 81 to 936\n2022-07-14 15:59:47,125 - Generated 1 link ids.\n2022-07-14 15:59:47,127 - Generated link id 937.\n2022-07-14 15:59:47,137 - Changed Link attributes under index: 10\n2022-07-14 15:59:47,139 - Changed Link index from 10 to 937\n2022-07-14 15:59:47,142 - Generated 1 link ids.\n2022-07-14 15:59:47,143 - Generated link id 938.\n2022-07-14 15:59:47,151 - Changed Link attributes under index: 127\n2022-07-14 15:59:47,153 - Changed Link index from 127 to 938\n2022-07-14 15:59:47,159 - Generated 1 link ids.\n2022-07-14 15:59:47,160 - Generated link id 939.\n2022-07-14 15:59:47,166 - Changed Link attributes under index: 134\n2022-07-14 15:59:47,168 - Changed Link index from 134 to 939\n2022-07-14 15:59:47,178 - Generated 1 link ids.\n2022-07-14 15:59:47,181 - Generated link id 940.\n2022-07-14 15:59:47,191 - Changed Link attributes under index: 192\n2022-07-14 15:59:47,193 - Changed Link index from 192 to 940\n2022-07-14 15:59:47,198 - Generated 1 link ids.\n2022-07-14 15:59:47,201 - Generated link id 941.\n2022-07-14 15:59:47,213 - Changed Link attributes under index: 208\n2022-07-14 15:59:47,214 - Changed Link index from 208 to 941\n2022-07-14 15:59:47,217 - Generated 1 link ids.\n2022-07-14 15:59:47,225 - Generated link id 942.\n2022-07-14 15:59:47,232 - Changed Link attributes under index: 228\n2022-07-14 15:59:47,233 - Changed Link index from 228 to 942\n2022-07-14 15:59:47,235 - Generated 1 link ids.\n2022-07-14 15:59:47,242 - Generated link id 943.\n2022-07-14 15:59:47,248 - Changed Link attributes under index: 194\n2022-07-14 15:59:47,249 - Changed Link index from 194 to 943\n2022-07-14 15:59:47,251 - Generated 1 link ids.\n2022-07-14 15:59:47,252 - Generated link id 944.\n</pre> <pre>2022-07-14 15:59:47,267 - Changed Link attributes under index: 22\n2022-07-14 15:59:47,269 - Changed Link index from 22 to 944\n2022-07-14 15:59:47,277 - Generated 1 link ids.\n2022-07-14 15:59:47,278 - Generated link id 945.\n2022-07-14 15:59:47,290 - Changed Link attributes under index: 236\n2022-07-14 15:59:47,291 - Changed Link index from 236 to 945\n2022-07-14 15:59:47,294 - Generated 1 link ids.\n2022-07-14 15:59:47,296 - Generated link id 946.\n2022-07-14 15:59:47,305 - Changed Link attributes under index: 172\n2022-07-14 15:59:47,307 - Changed Link index from 172 to 946\n2022-07-14 15:59:47,310 - Generated 1 link ids.\n2022-07-14 15:59:47,313 - Generated link id 947.\n2022-07-14 15:59:47,323 - Changed Link attributes under index: 178\n2022-07-14 15:59:47,327 - Changed Link index from 178 to 947\n2022-07-14 15:59:47,330 - Generated 1 link ids.\n2022-07-14 15:59:47,331 - Generated link id 948.\n2022-07-14 15:59:47,343 - Changed Link attributes under index: 104\n2022-07-14 15:59:47,344 - Changed Link index from 104 to 948\n2022-07-14 15:59:47,346 - Generated 1 link ids.\n2022-07-14 15:59:47,348 - Generated link id 949.\n2022-07-14 15:59:47,359 - Changed Link attributes under index: 19\n2022-07-14 15:59:47,360 - Changed Link index from 19 to 949\n2022-07-14 15:59:47,363 - Generated 1 link ids.\n2022-07-14 15:59:47,365 - Generated link id 950.\n2022-07-14 15:59:47,378 - Changed Link attributes under index: 20\n2022-07-14 15:59:47,379 - Changed Link index from 20 to 950\n2022-07-14 15:59:47,384 - Generated 1 link ids.\n2022-07-14 15:59:47,388 - Generated link id 951.\n2022-07-14 15:59:47,398 - Changed Link attributes under index: 145\n2022-07-14 15:59:47,400 - Changed Link index from 145 to 951\n2022-07-14 15:59:47,410 - Generated 1 link ids.\n2022-07-14 15:59:47,412 - Generated link id 952.\n2022-07-14 15:59:47,421 - Changed Link attributes under index: 214\n2022-07-14 15:59:47,423 - Changed Link index from 214 to 952\n2022-07-14 15:59:47,426 - Generated 1 link ids.\n2022-07-14 15:59:47,427 - Generated link id 953.\n2022-07-14 15:59:47,435 - Changed Link attributes under index: 252\n2022-07-14 15:59:47,438 - Changed Link index from 252 to 953\n2022-07-14 15:59:47,441 - Generated 1 link ids.\n2022-07-14 15:59:47,442 - Generated link id 954.\n2022-07-14 15:59:47,451 - Changed Link attributes under index: 255\n2022-07-14 15:59:47,453 - Changed Link index from 255 to 954\n2022-07-14 15:59:47,469 - Generated 1 link ids.\n2022-07-14 15:59:47,476 - Generated link id 955.\n2022-07-14 15:59:47,495 - Changed Link attributes under index: 117\n2022-07-14 15:59:47,497 - Changed Link index from 117 to 955\n2022-07-14 15:59:47,502 - Generated 1 link ids.\n2022-07-14 15:59:47,503 - Generated link id 956.\n2022-07-14 15:59:47,528 - Changed Link attributes under index: 8\n2022-07-14 15:59:47,540 - Changed Link index from 8 to 956\n2022-07-14 15:59:47,545 - Generated 1 link ids.\n2022-07-14 15:59:47,547 - Generated link id 957.\n2022-07-14 15:59:47,580 - Changed Link attributes under index: 6\n2022-07-14 15:59:47,582 - Changed Link index from 6 to 957\n2022-07-14 15:59:47,590 - Generated 1 link ids.\n2022-07-14 15:59:47,599 - Generated link id 958.\n2022-07-14 15:59:47,631 - Changed Link attributes under index: 159\n2022-07-14 15:59:47,632 - Changed Link index from 159 to 958\n2022-07-14 15:59:47,646 - Generated 1 link ids.\n2022-07-14 15:59:47,647 - Generated link id 959.\n2022-07-14 15:59:47,691 - Changed Link attributes under index: 112\n2022-07-14 15:59:47,698 - Changed Link index from 112 to 959\n2022-07-14 15:59:47,710 - Generated 1 link ids.\n2022-07-14 15:59:47,732 - Generated link id 960.\n2022-07-14 15:59:47,775 - Changed Link attributes under index: 166\n2022-07-14 15:59:47,783 - Changed Link index from 166 to 960\n2022-07-14 15:59:47,790 - Generated 1 link ids.\n2022-07-14 15:59:47,791 - Generated link id 961.\n2022-07-14 15:59:47,812 - Changed Link attributes under index: 42\n2022-07-14 15:59:47,815 - Changed Link index from 42 to 961\n2022-07-14 15:59:47,819 - Generated 1 link ids.\n2022-07-14 15:59:47,824 - Generated link id 962.\n2022-07-14 15:59:47,835 - Changed Link attributes under index: 95\n2022-07-14 15:59:47,838 - Changed Link index from 95 to 962\n2022-07-14 15:59:47,845 - Generated 1 link ids.\n2022-07-14 15:59:47,846 - Generated link id 963.\n2022-07-14 15:59:47,861 - Changed Link attributes under index: 142\n2022-07-14 15:59:47,863 - Changed Link index from 142 to 963\n2022-07-14 15:59:47,866 - Generated 1 link ids.\n2022-07-14 15:59:47,874 - Generated link id 964.\n2022-07-14 15:59:47,884 - Changed Link attributes under index: 93\n2022-07-14 15:59:47,886 - Changed Link index from 93 to 964\n2022-07-14 15:59:47,892 - Generated 1 link ids.\n2022-07-14 15:59:47,896 - Generated link id 965.\n2022-07-14 15:59:47,908 - Changed Link attributes under index: 94\n2022-07-14 15:59:47,911 - Changed Link index from 94 to 965\n2022-07-14 15:59:47,926 - Generated 1 link ids.\n2022-07-14 15:59:47,947 - Generated link id 966.\n2022-07-14 15:59:47,959 - Changed Link attributes under index: 44\n2022-07-14 15:59:47,963 - Changed Link index from 44 to 966\n2022-07-14 15:59:47,973 - Generated 1 link ids.\n2022-07-14 15:59:47,975 - Generated link id 967.\n2022-07-14 15:59:47,988 - Changed Link attributes under index: 190\n2022-07-14 15:59:47,991 - Changed Link index from 190 to 967\n2022-07-14 15:59:47,995 - Generated 1 link ids.\n2022-07-14 15:59:47,997 - Generated link id 968.\n2022-07-14 15:59:48,007 - Changed Link attributes under index: 264\n2022-07-14 15:59:48,009 - Changed Link index from 264 to 968\n2022-07-14 15:59:48,012 - Generated 1 link ids.\n2022-07-14 15:59:48,014 - Generated link id 969.\n2022-07-14 15:59:48,027 - Changed Link attributes under index: 146\n2022-07-14 15:59:48,028 - Changed Link index from 146 to 969\n2022-07-14 15:59:48,031 - Generated 1 link ids.\n2022-07-14 15:59:48,032 - Generated link id 970.\n2022-07-14 15:59:48,048 - Changed Link attributes under index: 82\n2022-07-14 15:59:48,049 - Changed Link index from 82 to 970\n2022-07-14 15:59:48,052 - Generated 1 link ids.\n2022-07-14 15:59:48,059 - Generated link id 971.\n2022-07-14 15:59:48,068 - Changed Link attributes under index: 69\n2022-07-14 15:59:48,073 - Changed Link index from 69 to 971\n2022-07-14 15:59:48,077 - Generated 1 link ids.\n2022-07-14 15:59:48,077 - Generated link id 972.\n2022-07-14 15:59:48,094 - Changed Link attributes under index: 58\n2022-07-14 15:59:48,096 - Changed Link index from 58 to 972\n2022-07-14 15:59:48,099 - Generated 1 link ids.\n2022-07-14 15:59:48,103 - Generated link id 973.\n2022-07-14 15:59:48,117 - Changed Link attributes under index: 56\n2022-07-14 15:59:48,118 - Changed Link index from 56 to 973\n2022-07-14 15:59:48,124 - Generated 1 link ids.\n2022-07-14 15:59:48,126 - Generated link id 974.\n2022-07-14 15:59:48,133 - Changed Link attributes under index: 171\n2022-07-14 15:59:48,135 - Changed Link index from 171 to 974\n2022-07-14 15:59:48,138 - Generated 1 link ids.\n2022-07-14 15:59:48,143 - Generated link id 975.\n2022-07-14 15:59:48,149 - Changed Link attributes under index: 273\n2022-07-14 15:59:48,150 - Changed Link index from 273 to 975\n2022-07-14 15:59:48,151 - Generated 1 link ids.\n2022-07-14 15:59:48,159 - Generated link id 976.\n2022-07-14 15:59:48,166 - Changed Link attributes under index: 179\n2022-07-14 15:59:48,166 - Changed Link index from 179 to 976\n2022-07-14 15:59:48,168 - Generated 1 link ids.\n2022-07-14 15:59:48,169 - Generated link id 977.\n2022-07-14 15:59:48,182 - Changed Link attributes under index: 170\n2022-07-14 15:59:48,183 - Changed Link index from 170 to 977\n2022-07-14 15:59:48,186 - Generated 1 link ids.\n2022-07-14 15:59:48,192 - Generated link id 978.\n2022-07-14 15:59:48,199 - Changed Link attributes under index: 201\n2022-07-14 15:59:48,200 - Changed Link index from 201 to 978\n2022-07-14 15:59:48,203 - Generated 1 link ids.\n2022-07-14 15:59:48,211 - Generated link id 979.\n2022-07-14 15:59:48,218 - Changed Link attributes under index: 251\n2022-07-14 15:59:48,223 - Changed Link index from 251 to 979\n2022-07-14 15:59:48,227 - Generated 1 link ids.\n2022-07-14 15:59:48,228 - Generated link id 980.\n2022-07-14 15:59:48,235 - Changed Link attributes under index: 40\n2022-07-14 15:59:48,247 - Changed Link index from 40 to 980\n</pre> <pre>2022-07-14 15:59:48,250 - Generated 1 link ids.\n2022-07-14 15:59:48,253 - Generated link id 981.\n2022-07-14 15:59:48,266 - Changed Link attributes under index: 73\n2022-07-14 15:59:48,267 - Changed Link index from 73 to 981\n2022-07-14 15:59:48,275 - Generated 1 link ids.\n2022-07-14 15:59:48,277 - Generated link id 982.\n2022-07-14 15:59:48,285 - Changed Link attributes under index: 248\n2022-07-14 15:59:48,285 - Changed Link index from 248 to 982\n2022-07-14 15:59:48,291 - Generated 1 link ids.\n2022-07-14 15:59:48,292 - Generated link id 983.\n2022-07-14 15:59:48,299 - Changed Link attributes under index: 212\n2022-07-14 15:59:48,300 - Changed Link index from 212 to 983\n2022-07-14 15:59:48,302 - Generated 1 link ids.\n2022-07-14 15:59:48,304 - Generated link id 984.\n2022-07-14 15:59:48,315 - Changed Link attributes under index: 49\n2022-07-14 15:59:48,315 - Changed Link index from 49 to 984\n2022-07-14 15:59:48,317 - Generated 1 link ids.\n2022-07-14 15:59:48,319 - Generated link id 985.\n2022-07-14 15:59:48,331 - Changed Link attributes under index: 97\n2022-07-14 15:59:48,332 - Changed Link index from 97 to 985\n2022-07-14 15:59:48,334 - Generated 1 link ids.\n2022-07-14 15:59:48,334 - Generated link id 986.\n2022-07-14 15:59:48,345 - Changed Link attributes under index: 21\n2022-07-14 15:59:48,346 - Changed Link index from 21 to 986\n2022-07-14 15:59:48,348 - Generated 1 link ids.\n2022-07-14 15:59:48,348 - Generated link id 987.\n2022-07-14 15:59:48,359 - Changed Link attributes under index: 131\n2022-07-14 15:59:48,360 - Changed Link index from 131 to 987\n2022-07-14 15:59:48,361 - Generated 1 link ids.\n2022-07-14 15:59:48,362 - Generated link id 988.\n2022-07-14 15:59:48,370 - Changed Link attributes under index: 266\n2022-07-14 15:59:48,372 - Changed Link index from 266 to 988\n2022-07-14 15:59:48,375 - Generated 1 link ids.\n2022-07-14 15:59:48,376 - Generated link id 989.\n2022-07-14 15:59:48,382 - Changed Link attributes under index: 14\n2022-07-14 15:59:48,382 - Changed Link index from 14 to 989\n2022-07-14 15:59:48,384 - Generated 1 link ids.\n2022-07-14 15:59:48,386 - Generated link id 990.\n2022-07-14 15:59:48,398 - Changed Link attributes under index: 102\n2022-07-14 15:59:48,399 - Changed Link index from 102 to 990\n2022-07-14 15:59:48,401 - Generated 1 link ids.\n2022-07-14 15:59:48,408 - Generated link id 991.\n2022-07-14 15:59:48,415 - Changed Link attributes under index: 211\n2022-07-14 15:59:48,416 - Changed Link index from 211 to 991\n2022-07-14 15:59:48,417 - Generated 1 link ids.\n2022-07-14 15:59:48,418 - Generated link id 992.\n2022-07-14 15:59:48,430 - Changed Link attributes under index: 2\n2022-07-14 15:59:48,431 - Changed Link index from 2 to 992\n2022-07-14 15:59:48,433 - Generated 1 link ids.\n2022-07-14 15:59:48,434 - Generated link id 993.\n2022-07-14 15:59:48,443 - Changed Link attributes under index: 213\n2022-07-14 15:59:48,444 - Changed Link index from 213 to 993\n2022-07-14 15:59:48,445 - Generated 1 link ids.\n2022-07-14 15:59:48,446 - Generated link id 994.\n2022-07-14 15:59:48,454 - Changed Link attributes under index: 243\n2022-07-14 15:59:48,456 - Changed Link index from 243 to 994\n2022-07-14 15:59:48,460 - Generated 1 link ids.\n2022-07-14 15:59:48,461 - Generated link id 995.\n2022-07-14 15:59:48,471 - Changed Link attributes under index: 133\n2022-07-14 15:59:48,477 - Changed Link index from 133 to 995\n2022-07-14 15:59:48,481 - Generated 1 link ids.\n2022-07-14 15:59:48,483 - Generated link id 996.\n2022-07-14 15:59:48,495 - Changed Link attributes under index: 84\n2022-07-14 15:59:48,496 - Changed Link index from 84 to 996\n2022-07-14 15:59:48,498 - Generated 1 link ids.\n2022-07-14 15:59:48,499 - Generated link id 997.\n2022-07-14 15:59:48,509 - Changed Link attributes under index: 70\n2022-07-14 15:59:48,512 - Changed Link index from 70 to 997\n2022-07-14 15:59:48,515 - Generated 1 link ids.\n2022-07-14 15:59:48,516 - Generated link id 998.\n2022-07-14 15:59:48,527 - Changed Link attributes under index: 64\n2022-07-14 15:59:48,528 - Changed Link index from 64 to 998\n2022-07-14 15:59:48,530 - Generated 1 link ids.\n2022-07-14 15:59:48,531 - Generated link id 999.\n2022-07-14 15:59:48,540 - Changed Link attributes under index: 47\n2022-07-14 15:59:48,542 - Changed Link index from 47 to 999\n2022-07-14 15:59:48,544 - Generated 1 link ids.\n2022-07-14 15:59:48,544 - Generated link id 1000.\n2022-07-14 15:59:48,551 - Changed Link attributes under index: 258\n2022-07-14 15:59:48,552 - Changed Link index from 258 to 1000\n2022-07-14 15:59:48,554 - Generated 1 link ids.\n2022-07-14 15:59:48,558 - Generated link id 1001.\n2022-07-14 15:59:48,569 - Changed Link attributes under index: 161\n2022-07-14 15:59:48,571 - Changed Link index from 161 to 1001\n2022-07-14 15:59:48,577 - Generated 1 link ids.\n2022-07-14 15:59:48,578 - Generated link id 1002.\n2022-07-14 15:59:48,584 - Changed Link attributes under index: 9\n2022-07-14 15:59:48,585 - Changed Link index from 9 to 1002\n2022-07-14 15:59:48,791 - Finished consolidating link indexing between the two graphs\n2022-07-14 15:59:48,801 - The following vehicle types clash: {'funicular', 'gondola', 'cablecar', 'ferry', 'rail', 'subway', 'bus', 'tram'}\n2022-07-14 15:59:48,802 - Overwrite is on. Vehicle types listed above will be overwritten.\n</pre> In\u00a0[6]: Copied! <pre>_n\n</pre> _n Out[6]: <pre>&lt;Network instance at 140177000302160: with \ngraph: Name: Network graph\nType: MultiDiGraph\nNumber of nodes: 665\nNumber of edges: 1003\nAverage in degree:   1.5083\nAverage out degree:   1.5083 and \nschedule Schedule:\nNumber of services: 0\nNumber of routes: 0\nNumber of stops: 0</pre> In\u00a0[7]: Copied! <pre># _n.plot()\n</pre> # _n.plot()"},{"location":"examples/5_4_modifying_network_addition/#54-modifying-the-network-object-addition","title":"5.4. Modifying the <code>Network</code> object: Addition\u00b6","text":"<p>This page goes through the process of adding two Network objects together. Available as a jupyter notebook or wiki page.</p> <p>You can add one network to another. The network you're adding the other network too will be updated with the nodes, link and data from the other network. The process aims to consolidate node and link indexing, for nodes in the same spot and links with the same modes.</p> <p>This method should only be used with networks that have been generated in the same manner, so two PT2MATSim networks or two GeNet OSM networks, both of which either simplified or not. It is recommended that they are not simplified at the time of adding, as some nodes may have ceased to exist through simplification, possibly leading to a network with weird behaviour, duplicated links (especially when the networks have different density) or connectivity issues.</p> <p>For now, the method only supports non overlapping services for <code>Schedules</code>, so let's merge two <code>Network</code>s with just graphs.</p> <p>Below we make two networks from OSM. One a small, but denser subset of the other and add them together.</p>"},{"location":"examples/6_1_validating_network_matsim_specific/","title":"6.1. Validating the object: MatSim","text":"In\u00a0[1]: Copied! <pre># read sample network\nimport os\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> # read sample network import os  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> In\u00a0[2]: Copied! <pre>report = n.generate_validation_report()\n</pre> report = n.generate_validation_report() <pre>2022-10-19 14:00:13,074 - Checking validity of the Network\n2022-10-19 14:00:13,074 - Checking validity of the Network graph\n2022-10-19 14:00:13,075 - Defaulting to checking graph connectivity for modes: ['car', 'walk', 'bike']. You can change this by passing a `modes_for_strong_connectivity` param\n2022-10-19 14:00:13,075 - Checking network connectivity for mode: car\n2022-10-19 14:00:13,130 - The graph for mode: car has: 1 connected components, 0 sinks/dead_ends and 0 sources/unreachable nodes.\n2022-10-19 14:00:13,131 - Checking network connectivity for mode: walk\n2022-10-19 14:00:13,140 - The graph for mode: walk has: 0 connected components, 0 sinks/dead_ends and 0 sources/unreachable nodes.\n2022-10-19 14:00:13,140 - Checking network connectivity for mode: bike\n2022-10-19 14:00:13,149 - The graph for mode: bike has: 0 connected components, 0 sinks/dead_ends and 0 sources/unreachable nodes.\n2022-10-19 14:00:13,194 - Checking link values for `freespeed`\n2022-10-19 14:00:13,245 - Checking link values for `capacity`\n2022-10-19 14:00:13,294 - Checking link values for `permlanes`\n2022-10-19 14:00:13,344 - Checking link values for `oneway`\n2022-10-19 14:00:13,395 - Checking link values for `modes`\n2022-10-19 14:00:13,452 - Checking link values for `{'attributes': 'osm:way:access'}`\n2022-10-19 14:00:13,496 - Checking link values for `{'attributes': 'osm:way:highway'}`\n2022-10-19 14:00:13,557 - Checking link values for `{'attributes': 'osm:way:id'}`\n2022-10-19 14:00:13,613 - Checking link values for `{'attributes': 'osm:way:name'}`\n2022-10-19 14:00:13,674 - Checking link values for `{'attributes': 'osm:relation:route'}`\n2022-10-19 14:00:13,725 - Checking link values for `{'attributes': 'osm:way:lanes'}`\n2022-10-19 14:00:13,772 - Checking link values for `{'attributes': 'osm:way:oneway'}`\n2022-10-19 14:00:13,822 - Checking link values for `{'attributes': 'osm:way:tunnel'}`\n2022-10-19 14:00:13,867 - Checking link values for `{'attributes': 'osm:way:psv'}`\n2022-10-19 14:00:13,913 - Checking link values for `{'attributes': 'osm:way:vehicle'}`\n2022-10-19 14:00:13,963 - Checking link values for `{'attributes': 'osm:way:traffic_calming'}`\n2022-10-19 14:00:14,011 - Checking link values for `{'attributes': 'osm:way:junction'}`\n2022-10-19 14:00:14,056 - Checking link values for `{'attributes': 'osm:way:service'}`\n2022-10-19 14:00:14,100 - Checking link values for `length`\n2022-10-19 14:00:14,141 - 1 of links have fractional values for `length`\n2022-10-19 14:00:14,152 - Checking validity of the Schedule\n2022-10-19 14:00:14,152 - Computing headway stats\n2022-10-19 14:00:14,346 - Checking validity of PT vehicles\n2022-10-19 14:00:14,360 - 1 unused vehicles have been found.\n2022-10-19 14:00:14,373 - No vehicles being used for multiple trips have been found.\n2022-10-19 14:00:14,374 - Computing speeds\n2022-10-19 14:00:14,432 - Checking speeds for prohibitive values 0 and infinity. You should verify speed values separately\n</pre> In\u00a0[3]: Copied! <pre>from pprint import pprint\n\npprint(report[\"graph\"])\n</pre> from pprint import pprint  pprint(report[\"graph\"]) <pre>{'graph_connectivity': {'bike': {'number_of_connected_subgraphs': 0,\n                                 'problem_nodes': {'dead_ends': [],\n                                                   'unreachable_node': []}},\n                        'car': {'number_of_connected_subgraphs': 1,\n                                'problem_nodes': {'dead_ends': [],\n                                                  'unreachable_node': []}},\n                        'walk': {'number_of_connected_subgraphs': 0,\n                                 'problem_nodes': {'dead_ends': [],\n                                                   'unreachable_node': []}}},\n 'isolated_nodes': {'nodes': [], 'number_of_nodes': 0},\n 'link_attributes': {'fractional_attributes': {'length': {'link_ids': ['3151'],\n                                                          'number_of': 1,\n                                                          'percentage': 0.0003158559696778269}},\n                     'infinite_attributes': {},\n                     'links_over_1000_length': {'link_ids': [],\n                                                'number_of': 0,\n                                                'percentage': 0.0},\n                     'negative_attributes': {},\n                     'none_attributes': {},\n                     'zero_attributes': {}}}\n</pre> In\u00a0[4]: Copied! <pre>pprint(report[\"schedule\"][\"schedule_level\"])\n</pre> pprint(report[\"schedule\"][\"schedule_level\"]) <pre>{'has_valid_services': True,\n 'headways': {'has_zero_min_headways': False},\n 'invalid_services': [],\n 'invalid_stages': [],\n 'is_valid_schedule': True,\n 'speeds': {}}\n</pre> In\u00a0[5]: Copied! <pre>pprint(report[\"schedule\"][\"service_level\"][\"12430\"])\n</pre> pprint(report[\"schedule\"][\"service_level\"][\"12430\"]) <pre>{'has_valid_routes': True,\n 'invalid_routes': [],\n 'invalid_stages': [],\n 'is_valid_service': True}\n</pre> In\u00a0[13]: Copied! <pre># ['schedule']['route_level'][SERVICE_ID][ROUTE_ID]\npprint(report[\"schedule\"][\"route_level\"][\"12430\"][\"VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3\"])\n</pre> # ['schedule']['route_level'][SERVICE_ID][ROUTE_ID] pprint(report[\"schedule\"][\"route_level\"][\"12430\"][\"VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3\"]) <pre>{'headway_stats': {'max_headway_mins': 10.0,\n                   'mean_headway_mins': 8.886363636363637,\n                   'min_headway_mins': 8.000000000000002,\n                   'std_headway_mins': 0.3867520743564629},\n 'invalid_stages': [],\n 'is_valid_route': True}\n</pre> In\u00a0[7]: Copied! <pre>pprint(report[\"schedule\"][\"vehicle_level\"])\n</pre> pprint(report[\"schedule\"][\"vehicle_level\"]) <pre>{'vehicle_definitions_valid': True,\n 'vehicle_definitions_validity_components': {'missing_vehicles': {'missing_vehicles_types': set(),\n                                                                  'vehicles_affected': {}},\n                                             'multiple_use_vehicles': {},\n                                             'unused_vehicles': {'veh_unused_bus'}}}\n</pre> In\u00a0[8]: Copied! <pre>pprint(report[\"routing\"])\n</pre> pprint(report[\"routing\"]) <pre>{'route_to_crow_fly_ratio': {'12430': {'VJ06420fdab0dfe5c8e7f2f9504df05cf6289cd7d3': 1.3239649602342694,\n                                       'VJ06cd41dcd58d947097df4a8f33234ef423210154': 1.3239649602342694,\n                                       'VJ0f3c08222de16c2e278be0a1bf0f9ea47370774e': 1.0701730717991658,\n                                       'VJ15419796737689e742962a625abcf3fd5b3d58b1': 1.3239649602342694,\n                                       'VJ235c8fca539cf931b3c673f9b056606384aff950': 1.0701730717991658,\n                                       'VJ8f9aea7491080b0137d3092706f53dc11f7dba45': 1.0701730717991658,\n                                       'VJ948e8caa0f08b9c6bf6330927893942c474b5100': 1.0701730717991658,\n                                       'VJ95b4c534d7c903d76ec0340025aa88b81dba3ce4': 1.0701730717991658,\n                                       'VJeae6e634f8479e0b6712780d5728f0afca964e64': 1.3239649602342694,\n                                       'VJeb72539d69ddf8e29f1adf74d43953def196ae41': 1.3239649602342694,\n                                       'VJef7f20c3a9bf1419f6401e1e9131fe2c634bcb9a': 1.0701730717991658,\n                                       'VJf8e38a73359b6cf743d8e35ee64ef1f7b7914daa': 1.3239649602342694},\n                             '14073': {'VJ24fe211d801738b556a39f815256d7f6bc544ec5': 1.3173846040975918,\n                                       'VJ6cf76a4c03cca468cb6954db7f7aad5ae189df13': 1.473100979468389,\n                                       'VJ93d8207ae8540b4ff59d47c9ee1ec5689084522d': 1.3173846040975918,\n                                       'VJaa5ee0daec7529d7668c81fe7fac0c4ff545daea': 1.3173846040975918,\n                                       'VJb4309b7a9598539ab9942ea1bcadc60a91b978ba': 1.473100979468389,\n                                       'VJc8cdbd902dadeebeeb4dbd7332b564ee2e4b00ce': 1.473100979468389,\n                                       'VJd132b905afc6c0e8e8a994142e301ca5c0f70e22': 1.473100979468389,\n                                       'VJd9dbeefeca6d74ef2594a17514ebc08ee2d503b2': 1.3173846040975918,\n                                       'VJdbc280077e505b4f8d66586ca51751a125cb4ef0': 1.473100979468389,\n                                       'VJe18efadf172576fea7989ec1f233f26854c0f66a': 1.473100979468389,\n                                       'VJe6ba07ef9f19ae40517261ad626bf34dd656491a': 1.3173846040975918,\n                                       'VJe8cffad09738ff7b9698b333e3247918d5c45358': 1.3173846040975918,\n                                       'VJea6046f64f85febf1854290fb8f76e921e3ac96b': 1.3173846040975918,\n                                       'VJf6055fdf9ef0dd6d0500b6c11adcfdd4d10655dc': 1.473100979468389,\n                                       'VJfc35884fc4f11dc408a209c19f56f3b60f634daf': 1.473100979468389},\n                             '14134': {'VJ12ba6089dfb2733e29c415a1a0015fef30fd5305': 0.954099779234282,\n                                       'VJ256e98df611ff48afe737ddc81cbcde82e4e81c8': 0.954099779234282,\n                                       'VJ26095b8f9f9db92ca2e53d4c086a7dcd82a13be9': 1.0124733183340817,\n                                       'VJ2aba67e3ed98f2ed5f5966c1ac394cbf6d1943d7': 0.954099779234282,\n                                       'VJ2c87b2a59184888f3175b55bde7b02d024ea8607': 1.0124733183340817,\n                                       'VJ323d02e117552af1565f2ff1273a612655c829c4': 1.0124733183340817,\n                                       'VJ4c6fa387b0d4be94a6c3679b94790b183e2558ca': 1.0124733183340817,\n                                       'VJ4e2b897edf0e7b8a8e3b5516ab43ce56f72c5cff': 0.954099779234282,\n                                       'VJ4e311a625836374adf4cfaa841224840dbeb7619': 1.0124733183340817,\n                                       'VJ5909ba51575a9459eb0013fbd31c8205455ca2fd': 1.0124733183340817,\n                                       'VJa7f37392e276aeac26c7e73bbc05e6a71af38dba': 0.954099779234282,\n                                       'VJb93a17a405fe502c5b3a2d6544105b0311da9fe2': 1.0124733183340817,\n                                       'VJd78967364a302cf232c5139d40622dcb6c238c9e': 0.954099779234282,\n                                       'VJdb0c128567fcbcc063d554ae1c95851cee41b909': 1.0124733183340817,\n                                       'VJdf3936da1a51eb33db594ef99738802c14b19995': 0.954099779234282,\n                                       'VJf9a22035ae6f25bb420df833474943ad76065c89': 0.954099779234282},\n                             '15234': {'VJ1a8cc306354fdc322d739ae644eb73444341d08d': 0.6044359898130892,\n                                       'VJ28a8a6a4ab02807a4fdfd199e5c2ca0622d34d0c': 0.6044359898130892,\n                                       'VJ3d50b96792ae8495dbe5a5e372849a60c48b2279': 0.6044359898130892,\n                                       'VJ5b511605b1e07428c2e0a7d676d301c6c40dcca6': 0.6044359898130892,\n                                       'VJ652c769bc42361cc0308dff59a1fdcf0949bdade': 0.6044359898130892,\n                                       'VJ8ccf92aa0f351b2e31f1a078b968dff4c2505c02': 0.6044359898130892,\n                                       'VJ9b58a59e3d74941586a5bca7726a8aa624da67fc': 1.7553468141267645,\n                                       'VJbf9d4fdb976223e6a026c0c669ed290418abefee': 0.6044359898130892,\n                                       'VJd4cbfb092a104ac6a3164a86e9765f68734fdfcf': 0.6044359898130892},\n                             '15660': {'VJ1cf651142378958b52229bfe1fa552e49136e60e': 1.9980050355042769,\n                                       'VJ3716910ec59c370d9f5c69137df7276b68cf0a08': 1.9980050355042769,\n                                       'VJf2e0de4f5dad68cb03064e6064e372dde52cc678': 2.564487408294133},\n                             '17732': {'VJ0cb60de3ed229c1413abac506e770b6ab8a7c49a': 1.0944770548062988,\n                                       'VJ85c23573d670bab5485618b0c5fddff3314efc89': 1.5960560577867031},\n                             '18853': {'VJ8cacca9a6722c497c413005568182ecf4d50b160': 1.4017046875467802,\n                                       'VJf3e316e5e605bb512147dee2a989be5a82ef1b5f': 0.940133288488219,\n                                       'VJfc4917783c2ca3227789fa7c532c9adf47702095': 1.4017046875467802},\n                             '18915': {'VJ0d304b95d39f4bce48e6ff26ddd73a9c06f17f4f': 1.0944770548062988,\n                                       'VJ520ec0c0ca58a849349fa614b5cf9270ac5c93da': 1.5960560577867031,\n                                       'VJ887921c00645929c5402ac46592e57c368ea63a1': 1.5960560577867031,\n                                       'VJ8a4b1ca7dfd0a130abd1de9f55f3b756617dd4ca': 1.0944770548062988,\n                                       'VJb08f8a2de01a4ef99d3b7fefd9022117ac307531': 1.5960560577867031},\n                             '20274': {'VJ375a660d47a2aa570aa20a8568012da8497ffecf': 0.9400449355418125,\n                                       'VJ6c64ab7b477e201cae950efde5bd0cb4e2e8888e': 1.388832075763858,\n                                       'VJ812fad65e7fa418645b57b446f00cba573f2cdaf': 1.388832075763858}},\n 'service_routes_with_invalid_network_route': [],\n 'services_have_routes_in_the_graph': True}\n</pre> <p>The above report relies on a lot of convenience methods which can be used on their own. For example, you can list all invalid routes for the network using:</p> In\u00a0[9]: Copied! <pre>n.invalid_network_routes()\n</pre> n.invalid_network_routes() Out[9]: <pre>[]</pre> In\u00a0[10]: Copied! <pre>n.schedule.is_valid_schedule()\n</pre> n.schedule.is_valid_schedule() Out[10]: <pre>True</pre> <p>Something that is not included in the validity report is strong connectivity of PT (MATSim doesn't insist on it being satified). You can call <code>is_strongly_connected</code> on <code>Schedule</code> or the schedule components: <code>Service</code> and <code>Route</code>. The process uses an underlying  directed graph of stop connections (which you can access by calling <code>graph</code> method on a schedule-type element, e.g. if <code>s</code> is a <code>genet.Service</code> object, <code>s.graph()</code> will give you this directed graph)).</p> In\u00a0[11]: Copied! <pre>n.schedule.is_strongly_connected()\n</pre> n.schedule.is_strongly_connected() Out[11]: <pre>False</pre> In\u00a0[12]: Copied! <pre>n.schedule.graph().is_directed()\n</pre> n.schedule.graph().is_directed() Out[12]: <pre>True</pre>"},{"location":"examples/6_1_validating_network_matsim_specific/#61-validating-the-network-object-matsim","title":"6.1. Validating the <code>Network</code> object: MatSim\u00b6","text":"<p>This page goes through validation checks available in GeNet. Available as a jupyter notebook or wiki page.</p> <p>You can generate a validation report for the genet Network encompassing validity of the network, schedule and routing (of the transit services in the schedule on the network). It aims to provide a good collection of checks known to have affected MatSim simulations in the past. The report is a simple dictionary with keys: <code>graph</code>, <code>schedule</code> and <code>routing</code>.</p>"},{"location":"examples/6_1_validating_network_matsim_specific/#graph","title":"Graph\u00b6","text":"<p>The <code>graph</code> section:</p> <ul> <li>describes strongly connected components of the modal subgraphs, for modes that agents in MATSim need to find routes on: <code>car</code>, and <code>walk</code> and <code>bike</code> if you are allowing agents to route on the network for those modes.</li> <li>checks for isolated nodes (nodes that are not connected to anything, which can arise when deleting links for a network scenario)</li> <li>checks for links with attributes with values that are problematic such as:<ul> <li>fractions</li> <li>infinity</li> <li>zero</li> <li>negative</li> <li>none</li> </ul> </li> <li>flags links of length 1km or longer</li> </ul>"},{"location":"examples/6_1_validating_network_matsim_specific/#schedule","title":"Schedule\u00b6","text":"<p>The <code>schedule</code> section describes correctness of the schedule on three levels:</p> <ul> <li><p><code>schedule_level</code>: Overall look at the schedule validity. A <code>Schedule</code> is valid if:</p> <ul> <li>all of its' services are valid</li> <li>its' services are uniquely indexed</li> </ul> <p>Schedule <code>has_valid_services</code> if all services within the schedule are deemed valid. The invalid services are flagged in <code>invalid_services</code> and the invalid stages of schedule validity are flagged in <code>invalid_stages</code>.</p> <p>At this level we also report checks on: - <code>headways</code> (zero values) - <code>speeds</code> (zero and infinite values)</p> </li> <li><p><code>service_level</code>: Provides a look at validity of services within the schedule. It is indexed by service ids. Each <code>Service</code> is valid if:</p> <ul> <li>each of its' routes is valid</li> <li>its' routes are uniquely indexed</li> </ul> <p>A service <code>has_valid_routes</code> if all routes within the service are deemed valid. The invalid routes are flagged in <code>invalid_routes</code> and the invalid stages of service validity are flagged in <code>invalid_stages</code>.</p> </li> <li><p><code>route_level</code>: Provides a look at validity of each route within each service indexed by service id and route id (or service id and the indexin the <code>Service.routes</code> list if not uniquely indexed). Each <code>Route</code> is valid if it</p> <ul> <li>has more than one <code>Stop</code></li> <li>has correctly ordered route (the stops (their link reference ids) and links a route refers to are in the same order)</li> <li>arrival and departure offsets are correct (each stop has one and they are correctly ordered temporally)</li> <li>does not have self loops (there are no trips such as: Stop A -&gt; Stop A)</li> </ul> <p>If a route satisfies the above <code>is_valid_route</code> is <code>True</code>. If not, the <code>invalid_stages</code> flag where the route did not satisfy validity conditions.</p> <p>At this level, for each Route we also report <code>headway_stats</code>: - <code>mean_headway_mins</code> - <code>std_headway_mins</code> - <code>max_headway_mins</code> - <code>min_headway_mins</code></p> </li> <li><p><code>vehicle_level</code>: Looks at the validity of vehicle definitions and their uses. Checks that there is a valid definition for each vehicle, which consists of the following components:</p> <ul> <li>whether any definitions are missing</li> <li>whether any vehicles are not being used any more</li> <li>whether any vehicles are being used for multiple trips</li> </ul> </li> </ul> <p>Nb. The same dictionary output can be generated by using <code>Schedule</code> object's own <code>generate_validation_report</code> method.</p>"},{"location":"examples/6_1_validating_network_matsim_specific/#routing","title":"Routing\u00b6","text":"<p>Finally, the <code>routing</code> section describes routing of the transit schedule services onto the network graph.</p> <ul> <li><code>services_have_routes_in_the_graph</code>: all routes have network routes and the links they refer to exist in the graph, are connected (to nodes of preceding link is the from node of the next link in the chain) and the <code>modes</code> saved on the link data accept the mode of the route.</li> <li><code>service_routes_with_invalid_network_route</code>: flags routes not satifying the above,</li> <li><code>route_to_crow_fly_ratio</code>: gives ratio of the length of route to crow-fly distance between each of the stops along route. If the route is invalid, it will result in 0. If the route has only one stop it will result in <code>'Division by zero'</code>.</li> </ul>"},{"location":"examples/6_2_validating_network_google_directions_api/","title":"6.2. Validating the object: Google Directions API for speed calculation","text":"In\u00a0[1]: Copied! <pre>import logging\nimport os\nimport random\n\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import LineString\n\nimport genet\nfrom genet import google_directions, read_matsim\nfrom genet.output.spatial import generate_geodataframes\nfrom genet.utils.io import save_geodataframe\n</pre> import logging import os import random  import matplotlib.pyplot as plt from shapely.geometry import LineString  import genet from genet import google_directions, read_matsim from genet.output.spatial import generate_geodataframes from genet.utils.io import save_geodataframe <p>First of all, we need to read in the network for which the requests are being generated</p> In\u00a0[2]: Copied! <pre>path_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\n\nnetwork_epsg = \"epsg:27700\"\n\nn = read_matsim(\n    path_to_network=network, epsg=network_epsg, path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n\n# you don't need to read the vehicles file, but doing so ensures all vehicles in the schedule\n# are of the expected type and the definition of the vehicle is preserved\nn.print()\n</pre> path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")  network_epsg = \"epsg:27700\"  n = read_matsim(     path_to_network=network, epsg=network_epsg, path_to_schedule=schedule, path_to_vehicles=vehicles )  # you don't need to read the vehicles file, but doing so ensures all vehicles in the schedule # are of the expected type and the definition of the vehicle is preserved n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> <p>Next we define the function to generate requests; it takes as input the network and the list of osm tags</p> <p>Let's create requests to get speed information for the main roads, print the number of requests, and save requests in a json file.</p> In\u00a0[3]: Copied! <pre># osm_tag = takes a list of osm tags to filter the network on, e.g. ['primary', 'secondary', 'tertiary']\nosm_tag = [\"secondary\"]\nrequests = genet.utils.google_directions.generate_requests(n, osm_tag)\n\nprint(len(requests))\n\ngenet.utils.google_directions.dump_all_api_requests_to_json(\n    requests, \"example_data/outputs/google_speed_data\", \"api_requests_send.json\"\n)\n</pre> # osm_tag = takes a list of osm tags to filter the network on, e.g. ['primary', 'secondary', 'tertiary'] osm_tag = [\"secondary\"] requests = genet.utils.google_directions.generate_requests(n, osm_tag)  print(len(requests))  genet.utils.google_directions.dump_all_api_requests_to_json(     requests, \"example_data/outputs/google_speed_data\", \"api_requests_send.json\" ) <pre>2022-07-14 16:11:30,771 - Generating Google Directions API requests for a non-simplified network.\n2022-07-14 16:11:30,799 - Identified 45 edge endpoints\n2022-07-14 16:11:30,800 - Identified 57 possible paths\n2022-07-14 16:11:30,801 - Processing 57 paths\n2022-07-14 16:11:30,805 - Saving Google Directions API requests to example_data/\n</pre> <pre>52\n</pre> <p>52 requests were generated. The number of requests to be sent is important as it will influence the cost of Google Directions API. Current pricing can be found here: https://developers.google.com/maps/documentation/directions/usage-and-billing</p> <p>It can be useful to visualise the requests before sending them, to confirm that they are as expected. Section 5 explains how to visualise requests you generate and results you receive from the API using Kepler.</p> <p>To send requests to Google Direction API you need a key (read more here). After obtaining a key, you can either pass it to the elevant function directly</p> In\u00a0[4]: Copied! <pre># Specify your own key\napi_key = \"YOUR API KEY\"\n</pre> # Specify your own key api_key = \"YOUR API KEY\" In\u00a0[5]: Copied! <pre># Read in the API requests generated in the previous section\npath = \"example_data/outputs/google_speed_data/api_requests_send.json\"\napi_requests = genet.utils.google_directions.read_api_requests(path)\n</pre> # Read in the API requests generated in the previous section path = \"example_data/outputs/google_speed_data/api_requests_send.json\" api_requests = genet.utils.google_directions.read_api_requests(path) <p>Before we send the requests, we need to specify the time of departure:</p> <ul> <li><code>None</code> to get duration based on road network and average time-independent traffic conditions</li> <li><code>now</code> for current time</li> <li>Time in the future as an integer in seconds since midnight, January 1, 1970 UTC, i.e. unix time (this website is useful for converting to unix time https://www.epochconverter.com )</li> </ul> <p>More details about <code>departure_time</code> parameter can be found here: https://developers.google.com/maps/documentation/directions/get-directions#departure_time</p> <p>If you set <code>departure_time</code> parameter to <code>now</code> or a time in the future, you can also specify the <code>traffic_model</code> parameter:</p> <ul> <li><code>best_guess</code> (default): indicates that the returned duration_in_traffic should be the best estimate of travel time given what is known about both historical traffic conditions and live traffic. Live traffic becomes more important the closer the departure_time is to now.</li> <li><code>pessimistic</code>: indicates that the returned duration_in_traffic should be longer than the actual travel time on most days, though occasional days with particularly bad traffic conditions may exceed this value.</li> <li><code>optimistic</code>: indicates that the returned duration_in_traffic should be shorter than the actual travel time on most days, though occasional days with particularly good traffic conditions may be faster than this value.</li> </ul> <p>More details about <code>traffic_model</code> parameter can be found here: https://developers.google.com/maps/documentation/directions/get-directions#traffic_model</p> # You may want to set a limit on the number of requests you are happy to send, # to avoid excess costs if there is a mistake  lim = 55  if len(api_requests) &lt; lim:     output_dir = 'example_data/outputs/google_speed_data/'     filename = 'api_requests_received.json'      logging.info('Sending API requests')     api_requests = genet.google_directions.send_requests(api_requests=api_requests,                                                          departure_time=1665563400,                                                          traffic_model='best_guess',                                                          key=api_key)      logging.info('Parsing API requests')     api_requests = genet.google_directions.parse_results(api_requests=api_requests)      logging.info('Saving API requests')     genet.google_directions.dump_all_api_requests_to_json(api_requests=api_requests,                                                           output_dir=output_dir,                                                           output_file_name=filename)  <p>This method will save derived results in the output directory provided, an example can be found here: <code>example_data/outputs/google_speed_data</code>.</p> <p>It comprises of the google polyline of the response and speed derived from distance and time taken to travel as well as information that was generated in order to make the response such as the node IDs in the network for which this response holds, the <code>path_nodes</code> which denote any extra nodes from the non-simplified chain of nodes/edges in the request, the polyline of the network path, encoded using the same polyline encoding as the Google request polyline; as well as spatial information about the origin and destination of the request and timestamp.</p> <p>The steps described above give you flexibility in choosing the parts of the network for which you want to send the requests. If you are happy to send the requests for the whole network, you can skip sections 1 and 2.1 and go straight to the steps below (you still need to load the network first).</p> <p>If you know the API key, you can specify it in the function call:</p> api_requests = google_directions.send_requests_for_network(     n=n,     request_number_threshold=3000,     key='API_key',     output_dir='example_data/outputs/google_speed_data',     departure_time='now' )  <p>Or set it as an environmental variable called <code>GOOGLE_DIR_API_KEY</code>, if using command line: <code>$ export GOOGLE_DIR_API_KEY='key'</code></p> api_requests = google_directions.send_requests_for_network(     n=n,     request_number_threshold=3000,     output_dir='example_data/outputs/google_speed_data',     departure_time='now' )  <p>If you use AWS, you can also store the key in the <code>Secrets Manager</code> (read more here) authenticate to your AWS account and then pass the <code>secret_name</code> and <code>region_name</code> to the <code>send_requests_for_network</code> method:</p> api_requests = google_directions.send_requests_for_network(     n=_n,     request_number_threshold=3000,     output_dir='example_data/outputs/google_speed_data',     departure_time='now',     secret_name='secret_name',     region_name='region_name' )  <p>Once the request results have been received, you can read them in from the output directory you specified. For now, we will use an example dataset.</p> In\u00a0[6]: Copied! <pre>api_requests = google_directions.read_api_requests(\n    \"example_data/example_google_speed_data/api_requests_received.json\"\n)\n</pre> api_requests = google_directions.read_api_requests(     \"example_data/example_google_speed_data/api_requests_received.json\" ) In\u00a0[7]: Copied! <pre>random.sample(sorted(api_requests.items()), 1)\n</pre> random.sample(sorted(api_requests.items()), 1) Out[7]: <pre>[(('1614978621', '351788581'),\n  {'path_nodes': ['1614978621',\n    '455705622',\n    '9475528',\n    '2441993346',\n    '21704017',\n    '351788581'],\n   'path_polyline': 'kxlyH`jVD\\\\fBlD|DlFB@z@x@',\n   'origin': {'id': '1614978621',\n    'x': 530576.8274248724,\n    'y': 181393.9033903911,\n    'lon': -0.11953208708639783,\n    'lat': 51.5163844332409,\n    's2_id': 5221390732826561719},\n   'destination': {'id': '351788581',\n    'x': 530408.2266209685,\n    'y': 181187.08346980734,\n    'lon': -0.12203698708857721,\n    'lat': 51.514564733241166,\n    's2_id': 5221366089140130631},\n   'timestamp': 1637671582.669343,\n   'request_payload': {'geocoded_waypoints': [{'geocoder_status': 'OK',\n      'place_id': 'ChIJyf-1bDUbdkgRPXzY5S3KuqI',\n      'types': ['street_address']},\n     {'geocoder_status': 'OK',\n      'place_id': 'ChIJ_dwjTssEdkgRiFkpcNxtMhM',\n      'types': ['street_address']}],\n    'routes': [{'bounds': {'northeast': {'lat': 51.51638999999999,\n        'lng': -0.1195499},\n       'southwest': {'lat': 51.5145685, 'lng': -0.122045}},\n      'copyrights': 'Map data \u00a92021 Google',\n      'legs': [{'distance': {'text': '0.3 km', 'value': 273},\n        'duration': {'text': '1 min', 'value': 68},\n        'duration_in_traffic': {'text': '1 min', 'value': 70},\n        'end_address': '78 Long Acre, London WC2E 9NG, UK',\n        'end_location': {'lat': 51.5145685, 'lng': -0.122045},\n        'start_address': '60 Kingsway, London WC2B 6DS, UK',\n        'start_location': {'lat': 51.51638999999999, 'lng': -0.1195499},\n        'steps': [{'distance': {'text': '0.3 km', 'value': 273},\n          'duration': {'text': '1 min', 'value': 68},\n          'end_location': {'lat': 51.5145685, 'lng': -0.122045},\n          'html_instructions': 'Head &lt;b&gt;southwest&lt;/b&gt; on &lt;b&gt;Great Queen St&lt;/b&gt;/&lt;wbr/&gt;&lt;b&gt;B402&lt;/b&gt; toward &lt;b&gt;Kingsway&lt;/b&gt;/&lt;wbr/&gt;&lt;b&gt;A4200&lt;/b&gt;&lt;div style=\"font-size:0.9em\"&gt;Continue to follow B402&lt;/div&gt;&lt;div style=\"font-size:0.9em\"&gt;Leaving toll zone in 270&amp;nbsp;m at Drury Ln&lt;/div&gt;',\n          'polyline': {'points': 'mxlyHdjVDX@DBBd@`ABFh@dAFLLX@@LVT^FJb@p@NTDHFHX`@BBDF@@FHB@@@@?@AHA@?B?@?B@@@@@DDh@h@BD'},\n          'start_location': {'lat': 51.51638999999999, 'lng': -0.1195499},\n          'travel_mode': 'DRIVING'}],\n        'traffic_speed_entry': [],\n        'via_waypoint': []}],\n      'overview_polyline': {'points': 'mxlyHdjVF^h@dAbAtBnB`Dd@n@NLPCHDr@t@'},\n      'summary': 'B402',\n      'warnings': [],\n      'waypoint_order': []}],\n    'status': 'OK'},\n   'parsed_response': {'google_speed': 3.9,\n    'google_polyline': 'mxlyHdjVF^h@dAbAtBnB`Dd@n@NLPCHDr@t@'}})]</pre> <p>Once you have results, you can attach them to the network. This will create a dictionary of non-simplified edges to which the response data applies.</p> In\u00a0[8]: Copied! <pre>google_edge_data = google_directions.map_results_to_edges(api_requests)\n</pre> google_edge_data = google_directions.map_results_to_edges(api_requests) In\u00a0[9]: Copied! <pre>random.sample(sorted(google_edge_data.items()), 1)\n</pre> random.sample(sorted(google_edge_data.items()), 1) Out[9]: <pre>[(('3085109046', '3085109045'),\n  {'google_speed': 4.087248322147651,\n   'google_polyline': 'kunyHjcUt@rAb@n@f@j@tBxBVh@tAxDn@hEpBrNn@pE'})]</pre> In\u00a0[10]: Copied! <pre>n.edge(\"9791490\", \"4698712638\")\n</pre> n.edge(\"9791490\", \"4698712638\") Out[10]: <pre>{0: {'id': '596',\n  'from': '9791490',\n  'to': '4698712638',\n  'freespeed': 4.166666666666667,\n  'capacity': 600.0,\n  'permlanes': 1.0,\n  'oneway': '1',\n  'modes': {'car'},\n  's2_from': 5221390682074967269,\n  's2_to': 5221390682013665025,\n  'attributes': {'osm:way:access': 'no',\n   'osm:way:highway': 'unclassified',\n   'osm:way:id': 476247613.0,\n   'osm:way:name': 'Chitty Street'},\n  'length': 33.76444553419279}}</pre> <p>If we're working with a network that may have multiple edges between the same pair of nodes, we can restrict the links to which the data will be applied by specifying a modal condition, so that at least only links allowing cars will inherit this data.</p> In\u00a0[11]: Copied! <pre>def modal_condition(value):\n    return \"car\" in value\n</pre> def modal_condition(value):     return \"car\" in value In\u00a0[12]: Copied! <pre>n.apply_attributes_to_edges(google_edge_data, conditions={\"modes\": modal_condition})\n</pre> n.apply_attributes_to_edges(google_edge_data, conditions={\"modes\": modal_condition}) <pre>2022-07-14 16:11:30,927 - Changed Edge attributes for 180 edges\n</pre> <p>This will result in two new data points in the relevant links: <code>google_speed</code> and <code>google_polyline</code>.</p> In\u00a0[13]: Copied! <pre>n.edge(\"9791490\", \"4698712638\")\n</pre> n.edge(\"9791490\", \"4698712638\") Out[13]: <pre>{0: {'id': '596',\n  'from': '9791490',\n  'to': '4698712638',\n  'freespeed': 4.166666666666667,\n  'capacity': 600.0,\n  'permlanes': 1.0,\n  'oneway': '1',\n  'modes': {'car'},\n  's2_from': 5221390682074967269,\n  's2_to': 5221390682013665025,\n  'attributes': {'osm:way:access': 'no',\n   'osm:way:highway': 'unclassified',\n   'osm:way:id': 476247613.0,\n   'osm:way:name': 'Chitty Street'},\n  'length': 33.76444553419279}}</pre> <p>Next, we can validate the difference between <code>freespeed</code> and <code>google_speed</code>.</p> In\u00a0[14]: Copied! <pre>def speed_difference(link_attribs):\n    return link_attribs[\"freespeed\"] - link_attribs[\"google_speed\"]\n</pre> def speed_difference(link_attribs):     return link_attribs[\"freespeed\"] - link_attribs[\"google_speed\"] In\u00a0[15]: Copied! <pre>n.apply_function_to_links(speed_difference, \"speed_difference\")\n</pre> n.apply_function_to_links(speed_difference, \"speed_difference\") <pre>2022-07-14 16:11:30,968 - 2986 out of 3166 links have not been affected by the function. Links affected: ['1020', '1065', '1066', '1078', '1086', '1087', '1088', '1089', '1090', '1091', '1092', '1123', '1175', '1176', '1178', '1184', '1185', '1186', '1199', '1200', '1201', '1202', '1238', '1240', '1244', '1251', '1252', '1253', '1254', '1256', '1257', '1258', '1259', '1289', '1290', '1317', '1318', '1319', '1320', '146', '147', '1474', '1476', '1477', '1530', '1531', '1532', '1533', '1534', '1535', '1536', '1537', '1638', '1641', '1645', '1646', '1647', '1648', '1649', '1650', '1651', '1652', '1653', '1654', '1655', '1656', '1736', '1760', '1761', '1799', '18', '1800', '1891', '1892', '19', '191', '1917', '1918', '192', '1953', '1954', '1955', '1973', '1992', '2041', '2042', '2043', '2044', '2053', '2054', '2119', '2171', '2178', '2179', '2180', '2181', '2182', '2183', '2184', '2185', '2225', '2247', '2248', '2249', '2275', '2348', '2361', '2362', '2369', '2370', '2371', '2373', '2378', '2381', '2382', '2468', '2469', '252', '2566', '2567', '2568', '2569', '2600', '262', '2673', '2674', '2745', '2839', '2881', '2897', '2898', '2955', '2956', '2979', '2980', '2981', '2982', '30', '3056', '3098', '3099', '31', '3171', '3172', '3183', '327', '33', '334', '3340', '3341', '3342', '3344', '3345', '34', '366', '367', '404', '405', '409', '414', '415', '440', '486', '487', '765', '798', '799', '802', '806', '810', '811', '812', '83', '877', '878', '880', '881', '930', '931', '948']\n2022-07-14 16:11:30,996 - Changed Link attributes for 180 links\n</pre> <p>You can also choose to set google speed as the <code>freespeed</code> in the network. But be mindful if you use it for MATSim simulations, <code>freespeed</code> denotes the maximum speed a vehicle can travel on a certain link, Google Directions API data with <code>departure_time='now'</code> should be ran late at night/early morning ~4am local time to the network for any reliable results. Otherwise you are adding traffic conditions to the network which should be simulated by demand (population) side of the model rather than supply (network).</p> In\u00a0[16]: Copied! <pre>def set_google_speed(link_attribs):\n    if link_attribs[\"google_speed\"] != 0:\n        return link_attribs[\"google_speed\"]\n    else:\n        return link_attribs[\"freespeed\"]\n</pre> def set_google_speed(link_attribs):     if link_attribs[\"google_speed\"] != 0:         return link_attribs[\"google_speed\"]     else:         return link_attribs[\"freespeed\"] In\u00a0[17]: Copied! <pre>n.apply_function_to_links(set_google_speed, \"freespeed\")\n</pre> n.apply_function_to_links(set_google_speed, \"freespeed\") <pre>2022-07-14 16:11:31,037 - 2986 out of 3166 links have not been affected by the function. Links affected: ['1020', '1065', '1066', '1078', '1086', '1087', '1088', '1089', '1090', '1091', '1092', '1123', '1175', '1176', '1178', '1184', '1185', '1186', '1199', '1200', '1201', '1202', '1238', '1240', '1244', '1251', '1252', '1253', '1254', '1256', '1257', '1258', '1259', '1289', '1290', '1317', '1318', '1319', '1320', '146', '147', '1474', '1476', '1477', '1530', '1531', '1532', '1533', '1534', '1535', '1536', '1537', '1638', '1641', '1645', '1646', '1647', '1648', '1649', '1650', '1651', '1652', '1653', '1654', '1655', '1656', '1736', '1760', '1761', '1799', '18', '1800', '1891', '1892', '19', '191', '1917', '1918', '192', '1953', '1954', '1955', '1973', '1992', '2041', '2042', '2043', '2044', '2053', '2054', '2119', '2171', '2178', '2179', '2180', '2181', '2182', '2183', '2184', '2185', '2225', '2247', '2248', '2249', '2275', '2348', '2361', '2362', '2369', '2370', '2371', '2373', '2378', '2381', '2382', '2468', '2469', '252', '2566', '2567', '2568', '2569', '2600', '262', '2673', '2674', '2745', '2839', '2881', '2897', '2898', '2955', '2956', '2979', '2980', '2981', '2982', '30', '3056', '3098', '3099', '31', '3171', '3172', '3183', '327', '33', '334', '3340', '3341', '3342', '3344', '3345', '34', '366', '367', '404', '405', '409', '414', '415', '440', '486', '487', '765', '798', '799', '802', '806', '810', '811', '812', '83', '877', '878', '880', '881', '930', '931', '948']\n2022-07-14 16:11:31,065 - Changed Link attributes for 180 links\n</pre> In\u00a0[18]: Copied! <pre>n.edge(\"9791490\", \"4698712638\")\n</pre> n.edge(\"9791490\", \"4698712638\") Out[18]: <pre>{0: {'id': '596',\n  'from': '9791490',\n  'to': '4698712638',\n  'freespeed': 4.166666666666667,\n  'capacity': 600.0,\n  'permlanes': 1.0,\n  'oneway': '1',\n  'modes': {'car'},\n  's2_from': 5221390682074967269,\n  's2_to': 5221390682013665025,\n  'attributes': {'osm:way:access': 'no',\n   'osm:way:highway': 'unclassified',\n   'osm:way:id': 476247613.0,\n   'osm:way:name': 'Chitty Street'},\n  'length': 33.76444553419279}}</pre> <p>Once you have attached the google speed values to the network, you may want to do some validation, to check if the values make sense and if there are any missing values.</p> <p>To do that, we first need to convert the network to a geodataframe.</p> In\u00a0[19]: Copied! <pre># If you only sent the requests for parts of the network with a certain OSM tag,\n# you should pass the list of those tags to the function graph_to_gdf()\n\n\ndef graph_to_gdf(network, osm_tag=all):\n    subgraph_t = network.subgraph_on_link_conditions(\n        conditions=[{\"attributes\": {\"osm:way:highway\": osm_tag}}, {\"modes\": \"car\"}],\n        how=all,\n        mixed_dtypes=True,\n    )\n\n    # convert subgraph to geodataframe\n    gdf_dict = generate_geodataframes(subgraph_t)\n    gdf = gdf_dict[\"links\"]\n\n    # fill in missing points (due to network structure when filtering by osm_tag)\n    gdf.loc[gdf[\"geometry\"].isna(), \"geometry\"] = gdf.loc[gdf[\"geometry\"].isna()].apply(\n        lambda x: line_geometry(x[\"from\"], x[\"to\"]), axis=1\n    )\n\n    # convert to epsg:4326 to allow visualisation in Kepler in section 4\n    gdf = gdf.to_crs(\"epsg:4326\")\n\n    return gdf\n\n\n# For filling in missing points\ndef line_geometry(u, v):\n    from_node = n.node(u)\n    to_node = n.node(v)\n    return LineString(\n        [(float(from_node[\"x\"]), float(from_node[\"y\"])), (float(to_node[\"x\"]), float(to_node[\"y\"]))]\n    )\n</pre> # If you only sent the requests for parts of the network with a certain OSM tag, # you should pass the list of those tags to the function graph_to_gdf()   def graph_to_gdf(network, osm_tag=all):     subgraph_t = network.subgraph_on_link_conditions(         conditions=[{\"attributes\": {\"osm:way:highway\": osm_tag}}, {\"modes\": \"car\"}],         how=all,         mixed_dtypes=True,     )      # convert subgraph to geodataframe     gdf_dict = generate_geodataframes(subgraph_t)     gdf = gdf_dict[\"links\"]      # fill in missing points (due to network structure when filtering by osm_tag)     gdf.loc[gdf[\"geometry\"].isna(), \"geometry\"] = gdf.loc[gdf[\"geometry\"].isna()].apply(         lambda x: line_geometry(x[\"from\"], x[\"to\"]), axis=1     )      # convert to epsg:4326 to allow visualisation in Kepler in section 4     gdf = gdf.to_crs(\"epsg:4326\")      return gdf   # For filling in missing points def line_geometry(u, v):     from_node = n.node(u)     to_node = n.node(v)     return LineString(         [(float(from_node[\"x\"]), float(from_node[\"y\"])), (float(to_node[\"x\"]), float(to_node[\"y\"]))]     ) In\u00a0[20]: Copied! <pre>gdf = graph_to_gdf(n)\n\nwith_gs = gdf[gdf[\"google_speed\"].notna()]\ngoogle_speed_list = with_gs[\"google_speed\"].to_list()\n</pre> gdf = graph_to_gdf(n)  with_gs = gdf[gdf[\"google_speed\"].notna()] google_speed_list = with_gs[\"google_speed\"].to_list() In\u00a0[21]: Copied! <pre>zeros = sum(i &lt;= 0 for i in google_speed_list)\nif zeros &gt; 0:\n    google_speed_list = google_speed_list.remove(0)\nminimum = min(google_speed_list)\nmaximum = max(google_speed_list)\naverage = sum(google_speed_list) / len(google_speed_list)\n\nsummary = (\n    \"Average value of google_speed is \"\n    + str(average)\n    + \" meters/seconds (=\"\n    + str(average * 3.6)\n    + \" km/hour), \"\n    \"maximum value of google_speed is \"\n    + str(maximum)\n    + \" m/s (=\"\n    + str(maximum * 3.6)\n    + \" km/h), minimum (non-zero) \"\n    \"value of google_speed is \"\n    + str(minimum)\n    + \" m/s (=\"\n    + str(minimum * 3.6)\n    + \" km/h); there are \"\n    + str(zeros)\n    + \" links \"\n    \"with google_speed value equal to 0 m/s\"\n)\n\nlogging.info(summary)\n</pre> zeros = sum(i &lt;= 0 for i in google_speed_list) if zeros &gt; 0:     google_speed_list = google_speed_list.remove(0) minimum = min(google_speed_list) maximum = max(google_speed_list) average = sum(google_speed_list) / len(google_speed_list)  summary = (     \"Average value of google_speed is \"     + str(average)     + \" meters/seconds (=\"     + str(average * 3.6)     + \" km/hour), \"     \"maximum value of google_speed is \"     + str(maximum)     + \" m/s (=\"     + str(maximum * 3.6)     + \" km/h), minimum (non-zero) \"     \"value of google_speed is \"     + str(minimum)     + \" m/s (=\"     + str(minimum * 3.6)     + \" km/h); there are \"     + str(zeros)     + \" links \"     \"with google_speed value equal to 0 m/s\" )  logging.info(summary) <pre>2022-07-14 16:11:32,349 - Average value of google_speed is 3.815765080269415 meters/seconds (=13.736754288969895 km/hour), maximum value of google_speed is 8.0 m/s (=28.8 km/h), minimum (non-zero) value of google_speed is 2.0416666666666665 m/s (=7.35 km/h); there are 0 links with google_speed value equal to 0 m/s\n</pre> <p>There various tools available to visualise a genet network, and these are described in detail in the notebook <code>7. Visualising Network</code>. Here, we will have a quick look at how to visualise the google speeds in particular.</p> <p>First, we can do a quick visualisation using GeoPandas tools themselves, by plotting the parts of the network which have a <code>google_speed</code> value.</p> In\u00a0[22]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(12, 8))\ngdf.plot(column=\"google_speed\", ax=ax, legend=True, cmap=\"hot\", linewidth=2.5)\n</pre> fig, ax = plt.subplots(1, 1, figsize=(12, 8)) gdf.plot(column=\"google_speed\", ax=ax, legend=True, cmap=\"hot\", linewidth=2.5) Out[22]: <pre>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f7a55d1ded0&gt;</pre> <p>Since the visualisation above is quite simplistic, you may want to use Kepler instead. To do so, you just need to save the geodataframe in geojson format, and upload the file to Kepler: https://kepler.gl/demo</p> In\u00a0[23]: Copied! <pre>logging.info(\"saving network links with valid google speed values to geojson\")\nsave_geodataframe(\n    with_gs, \"api_requests_viz\", \"example_data/outputs/google_speed_data/\", filetype=\"geojson\"\n)\n</pre> logging.info(\"saving network links with valid google speed values to geojson\") save_geodataframe(     with_gs, \"api_requests_viz\", \"example_data/outputs/google_speed_data/\", filetype=\"geojson\" ) <pre>2022-07-14 16:11:32,789 - saving network links with valid google speed values to geojson\n</pre> <p>Once the geojson file is uploaded to Kepler, click on the button next to <code>Stroke Colour</code> field (shown by green arrow in the image below). Then, in the field <code>Stroke Color Based On</code> choose <code>google_speed</code> from the drop down menu. You can also click on the table icon in the top right corner to display the legend.</p> <p></p> <p>You can save this map in html format by clicking on the 'Share' button in the top left corner and selecting 'Export Map'.</p>"},{"location":"examples/6_2_validating_network_google_directions_api/#62-validating-the-network-object-google-directions-api-for-speed-calculation","title":"6.2. Validating the <code>Network</code> object: Google Directions API for speed calculation\u00b6","text":"<p>This page goes through methods available for generating speeds based off of Google Directions requests based off of the network links. Available as a jupyter notebook or wiki page.</p> <p>You can generate and send google directions API requests based on the network. The process will create a 'car' modal subgraph and generate API requests for all edges in the subgraph. The number of requests is at most the number of edges in the subgraph. The process simplifies edges using <code>osmnx</code> library's method to extract a chains of nodes with no intersections, in this way reducing the number of requests. If your graph is already simplified, the number of requests will be equal to the number of edges.</p>"},{"location":"examples/6_2_validating_network_google_directions_api/#1-creating-requests","title":"1. Creating requests\u00b6","text":""},{"location":"examples/6_2_validating_network_google_directions_api/#2-sending-requests","title":"2. Sending requests\u00b6","text":""},{"location":"examples/6_2_validating_network_google_directions_api/#21-sending-requests-created-in-section-1","title":"2.1 Sending requests created in Section 1\u00b6","text":""},{"location":"examples/6_2_validating_network_google_directions_api/#22-generating-and-sending-requests-in-one-step","title":"2.2 Generating and sending requests in one step\u00b6","text":""},{"location":"examples/6_2_validating_network_google_directions_api/#3-processing-the-requests","title":"3. Processing the requests\u00b6","text":""},{"location":"examples/6_2_validating_network_google_directions_api/#31-attaching-the-speed-values-from-requests-to-the-network","title":"3.1 Attaching the speed values from requests to the network\u00b6","text":""},{"location":"examples/6_2_validating_network_google_directions_api/#32-validating-google-speed-values","title":"3.2 Validating google speed values\u00b6","text":""},{"location":"examples/6_2_validating_network_google_directions_api/#4-visualising-google-speeds","title":"4. Visualising google speeds\u00b6","text":""},{"location":"examples/7_visualising_network/","title":"7. Visualising","text":"In\u00a0[1]: Copied! <pre># read sample network\nimport os\n\nfrom genet import read_matsim\n\npath_to_matsim_network = \"example_data/pt2matsim_network\"\n\nnetwork = os.path.join(path_to_matsim_network, \"network.xml\")\nschedule = os.path.join(path_to_matsim_network, \"schedule.xml\")\nvehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\")\nn = read_matsim(\n    path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles\n)\n# you don't need to read the vehicles file, but doing so ensures all vehicles\n# in the schedule are of the expected type and the definition of the vehicle\n# is preserved\nn.print()\n</pre> # read sample network import os  from genet import read_matsim  path_to_matsim_network = \"example_data/pt2matsim_network\"  network = os.path.join(path_to_matsim_network, \"network.xml\") schedule = os.path.join(path_to_matsim_network, \"schedule.xml\") vehicles = os.path.join(path_to_matsim_network, \"vehicles.xml\") n = read_matsim(     path_to_network=network, epsg=\"epsg:27700\", path_to_schedule=schedule, path_to_vehicles=vehicles ) # you don't need to read the vehicles file, but doing so ensures all vehicles # in the schedule are of the expected type and the definition of the vehicle # is preserved n.print() <pre>Graph info: Name: \nType: MultiDiGraph\nNumber of nodes: 1662\nNumber of edges: 3166\nAverage in degree:   1.9049\nAverage out degree:   1.9049 \nSchedule info: Schedule:\nNumber of services: 9\nNumber of routes: 68\nNumber of stops: 118\n</pre> In\u00a0[2]: Copied! <pre>m = n.plot(data={\"freespeed\"})\nm\n</pre> m = n.plot(data={\"freespeed\"}) m <pre>User Guide: https://docs.kepler.gl/docs/keplergl-jupyter\n</pre> <pre>/Users/kasia.kozlowska/PycharmProjects/CML/genet/venv_3_7/lib/python3.7/site-packages/pandas/core/dtypes/cast.py:118: ShapelyDeprecationWarning: The array interface is deprecated and will no longer work in Shapely 2.0. Convert the '.coords' to a numpy array instead.\n  arr = construct_1d_object_array_from_listlike(values)\n/Users/kasia.kozlowska/PycharmProjects/CML/genet/venv_3_7/lib/python3.7/site-packages/pandas/core/dtypes/cast.py:1990: ShapelyDeprecationWarning: __len__ for multi-part geometries is deprecated and will be removed in Shapely 2.0. Check the length of the `geoms` property instead to get the  number of parts of a multi-part geometry.\n  result[:] = values\n</pre> In\u00a0[3]: Copied! <pre>n.plot(output_dir=\"example_data/outputs/kepler/\")\n</pre> n.plot(output_dir=\"example_data/outputs/kepler/\") <pre>/Users/kasia.kozlowska/PycharmProjects/CML/genet/venv_3_7/lib/python3.7/site-packages/pandas/core/dtypes/cast.py:118: ShapelyDeprecationWarning: The array interface is deprecated and will no longer work in Shapely 2.0. Convert the '.coords' to a numpy array instead.\n  arr = construct_1d_object_array_from_listlike(values)\n/Users/kasia.kozlowska/PycharmProjects/CML/genet/venv_3_7/lib/python3.7/site-packages/pandas/core/dtypes/cast.py:1990: ShapelyDeprecationWarning: __len__ for multi-part geometries is deprecated and will be removed in Shapely 2.0. Check the length of the `geoms` property instead to get the  number of parts of a multi-part geometry.\n  result[:] = values\n</pre> <pre>User Guide: https://docs.kepler.gl/docs/keplergl-jupyter\nMap saved to example_data/output_kepler/network_with_pt_routes.html!\n</pre> In\u00a0[4]: Copied! <pre>m.save_to_html(file_name=\"example_data/outputs/kepler/kepler_map.html\")\n</pre> m.save_to_html(file_name=\"example_data/outputs/kepler/kepler_map.html\") <pre>Map saved to example_data/output_kepler/kepler_map.html!\n</pre> <p>Due to github's restriction on file size, we supress outputs for the remain plots, to see them, you will need to remove <code># </code> from the beginning of the line.</p> In\u00a0[5]: Copied! <pre># n.schedule.plot(data=True)\n</pre> # n.schedule.plot(data=True) In\u00a0[6]: Copied! <pre># n.schedule['12430'].plot()\n</pre> # n.schedule['12430'].plot() In\u00a0[7]: Copied! <pre># n.schedule.route('VJ948e8caa0f08b9c6bf6330927893942c474b5100').plot()\n</pre> # n.schedule.route('VJ948e8caa0f08b9c6bf6330927893942c474b5100').plot() <p>GeNet <code>Network</code> can an additional two methods to</p> <ul> <li>just plot the underlying graph and</li> <li>to plot the un-routed schedule on top of the graph</li> </ul> In\u00a0[8]: Copied! <pre># n.plot_graph()\n</pre> # n.plot_graph() In\u00a0[9]: Copied! <pre># n.plot_schedule()\n</pre> # n.plot_schedule() n.generate_standard_outputs(output_dir='path/to/standard_outputs', gtfs_day='19700101')  <p>Specifying <code>gtfs_day</code> is optional and only useful for generating visualisations which don't rise eyebrows. In this bundle you get a number of outputs which you can drop into kepler.gl or qgis.</p> <p>This method will output complete geojsons for the links and nodes of the <code>Network.graph</code> and <code>Schedule.graph()</code> (if present). These will usually be too large to put in kepler but can still be read back using <code>geopandas</code> and worked with easily as <code>GeoDataFrames</code>. These can be generated separately using <code>save_network_to_geojson</code> method. In addition to this, the method will output a few geojsons which have been subsetted on mode or values, to be immediately useful, and other files with high-level Schedule stats: (note, for each geojson there are corresponding shapefiles in a <code>shp_files</code> folder)</p> n.schedule.generate_standard_outputs(output_dir='path/to/standard_outputs', gtfs_day='19700101')"},{"location":"examples/7_visualising_network/#7-visualising-network","title":"7. Visualising <code>Network</code>\u00b6","text":"<p>This page goes through examples of visualising networks in GeNet. Available as a jupyter notebook or wiki page.</p>"},{"location":"examples/7_visualising_network/#kepler-plots","title":"Kepler plots\u00b6","text":"<p>Each GeNet class has a <code>plot</code> method, which depends on <code>kepler</code>. Make sure to follow installation instructions to use in-notebook visualisations.</p>"},{"location":"examples/7_visualising_network/#save-kepler-map-to-html","title":"Save Kepler map to html\u00b6","text":"<p>You can use kepler's method to save the map object to html (this will save the current state so should include any changes you made to the map), or you can pass the output directory to the plot method.</p>"},{"location":"examples/7_visualising_network/#standard-outputs","title":"Standard Outputs\u00b6","text":"<p>You can generate a long list of outputs which are useful for validating and visualising the network and its schedule.</p>"},{"location":"examples/7_visualising_network/#network-graph-related","title":"Network graph related\u00b6","text":"<ul> <li>geojsons for car mode featuring 'freespeed', 'capacity', 'permlanes' (separately, because these can get large)</li> <li>geojsons, featuring full data but each a subset of the graph on an OSM highway tag (e.g. all motorways)</li> <li>geojsons with geometry only for all other modal subgraphs</li> </ul>"},{"location":"examples/7_visualising_network/#schedule-related","title":"Schedule related\u00b6","text":"<ul> <li><code>vehicles_per_hour</code><ul> <li>geojsons featuring schedule graph with vehicles per hour for every mode separately and all together (with mode data present fo subsetting) in the schedule for all hours of the day, this can be used within kepler to animate across hours of the day. (Use 'filter' option on 'hour' field and click on the little clock)</li> <li>the same as above for all modes together but subsetted for am/inter/pm peak within hours 7, 8, 9, 13, 16, 17, 18 for convenience (in case the big geojson may be too large to load in kepler)</li> </ul> </li> <li><code>subgraphs</code> - links and nodes geojson modal subgraphs of the <code>Schedule</code> graph, the same as the large geojson, but chopped by mode to make each file easier to handle in kepler for example</li> <li><code>speed</code><ul> <li><code>pt_network_speeds</code> - geojson with network geometry and <code>routed_speed</code> based on distances between stops that use the <code>length</code>s of network links given in the network route for the <code>Route</code>. Note that it is not precise, as stops reference links, if the link is long this will throw off the speed (partial distance along a link with respect to the location of the stop is not considered).</li> <li><code>pt_speeds</code> - geojson with stop-to-stop, straight line, geometry. The <code>speed</code> is based on crow-fly distance between each stop pair multiplied by a <code>schedule_network_factor</code> which, if not passed explicitly, defaults to <code>1.3</code>.</li> </ul> </li> <li>CSVs - Stats:<ul> <li><code>trips_per_day_per_route.csv</code> - Number of trips made by each <code>Route</code> object, complete with mode and huma-readable name if present</li> <li><code>trips_per_day_per_service.csv</code> - Number of trips made by each <code>Service</code> object, complete with mode and huma-readable name if present. (This is an aggregation of the <code>Route</code> level output, as each Service is a list of <code>Route</code>s)</li> <li><code>trips_per_day_per_route_aggregated_per_stop_id_pair.csv</code> - pairs of stops that exist as end-points of <code>Route</code>s. Number of trains between those stops per mode, a record of <code>Route</code>s in common. Respects stop IDs, human-readable names included but can be repeated if there are more stops in <code>Schedule</code> with the same name (common for bigger stations). There is no directionality to the column names <code>station_A</code> and <code>station_B</code>. The number given is between <code>station_A</code> and <code>station_B</code> and <code>station_B</code> and <code>station_A</code> w.r.t ID. Data is not repeated, it could be that if an expected station is not in <code>station_A</code> column, it's in the <code>station_B</code> column instead.</li> <li><code>trips_per_day_per_route_aggregated_per_stop_name_pair.csv</code> - The same as <code>trips_per_day_per_route_aggregated_per_stop_id_pair.csv</code>, but aggregated by stop names, so does not respect stop IDs. Again, The number given is between <code>station_A_name</code> and <code>station_B_name</code> and <code>station_B_name</code> and <code>station_A_name</code> w.r.t stop names. Data is not repeated, it could be that if an expected station is not in <code>station_A_name</code> column, it's in the <code>station_B_name</code> column instead.</li> </ul> </li> </ul>"},{"location":"examples/7_visualising_network/#routing-related-for-a-network-object-with-a-schedule","title":"Routing related (for a Network object with a Schedule)\u00b6","text":"<ul> <li><code>schedule_network_routes_geodataframe.geojson</code> - GeoJSON output, rows exist for each <code>Route</code> that has non empty <code>route</code> attribute - links in the network referring to the network route of that <code>Route</code>. The geometry is a combined geometry of all links referenced in the route. Columns/Fields relating to corresponding service, route IDs and mode, as well as human-readable name (if available) are included.</li> </ul> <p>You can also generate standard outputs for schedule only:</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Convenience method to strip all links of a given mode #243</li> <li>Method to split links on mode. New links are generated of given mode based on existing links #244</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Issue when adding edges to fill spaces left by removing other edges (failure in resolving multi indexing) #248</li> <li>Fixed generating standard outputs by highway tag which were broken after moving to storing additional attributes in short form #217</li> <li>Fixed summary report:</li> <li>Intermodal Access/Egress reporting is more general (not expecting just car and bike mode access to PT) #204</li> <li>Node/Links numbers were reported incorrectly (switched) #207</li> <li>Fixed reading <code>java.lang.Array</code> types in MATSim xml files #216</li> <li>Fixed problem snapping and routing PT services with stops whose names started with 'x' #225</li> <li>Fixed issues saving geodataframes with missing geometry values, refined how geodataframes with empty values are saved to keep them more true to originals #226</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>GeNet's standard outputs now produce geoparquet format by default #217. The output file size is reduced significantly (e.g. network links output was reduced by ~80% on a test network). Networks/Schedules can still be saved to geojson and shape files as before.</li> <li>GeNet's pre-baked python scripts have been retired in favour of CLI #194</li> <li>Support for python v3.11 #192 and v3.12 #234</li> <li>[Breaking change] Updated to more accurate pyproj version #192</li> <li>[Breaking change] Update <code>Route.route</code> attribute to <code>Route.network_links</code> to differentiate it from the <code>Route.route</code> method. <code>Route</code> instantiation argument <code>route</code> is also now <code>network_links</code> #231</li> </ul>"},{"location":"CHANGELOG/#v400-2023-08-22","title":"[v4.0.0] - 2023-08-22","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Validation for intermodal access/egress for MATSim</li> <li>GeNet Scripts for: #179</li> <li>automated PT Schedule fixing (zero headways and infinite speeds)</li> <li>'squeezing' (or reducing attribute values) speed and capacity on links defined by spatial boundaries</li> <li>scaling vehicles (separately from any other operation, so it can be performed independently)</li> <li>Script to split modal subgraphs (so they have dedicated links) #153</li> <li>Validation checks for zero and infinite speeds PT speeds + many convenience methods #147</li> <li>Validation checks for zero headways and reporting on PT headway stats + many convenience methods #146</li> <li>Validation checks for isolated nodes and method to remove all isolated nodes #143</li> <li>Validation checks for infinite and negative values of attributes for a network #141</li> <li>Functionality to split a link at a point, creating two links which preserve original geometry #140</li> <li>Ability to use .tif files for elevation with any projection #139</li> <li>Summary statistics to summarise data stored for a network and schedule #136</li> <li>Script that adds elevation can also save node attributes #134</li> <li>Script to parse example jupyter notebook to genet wiki pages (useful if you contribute to the project) #129</li> </ul>"},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Schema breaking for nested lists (representing trips information, for example) when merging objects wholesale #173</li> <li>Schema breaking when generating trips from headways #159</li> <li>Small bugs in script that adds elevation #134 &amp; #170</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>GeNet Scripts got a re-vamp, making them more consistent in behaviour (output folder naming and minimal outputs (usually geojsons) tracking changes made by the scripts) #179</li> <li>Length attribute is calculated automatically, using nodes' spatial information, if not provided #161</li> <li>Elevation Script writes the MATSim slope file #158</li> <li>[Breaking change] Spatial information is now compulsory when adding new nodes #142</li> </ul>"},{"location":"CHANGELOG/#v300-2022-07-14","title":"[v3.0.0] - 2022-07-14","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Addition of elevation and slope data to networks using STRM files</li> <li>Vehicle capacity and pce scaling</li> <li>Conveniently save multiple <code>vehicle.xml</code> files for use with simulations at different scales: 1%, 5%, 10%, etc.</li> <li>Ability to read and write additional attributes for different network and schedule elements</li> <li>Allows you to pass any data to network links and nodes, PT schedule stops, routes and services and have it be   saved to the MATSim network</li> <li>Multimodal access/egress for PT stops</li> <li>Script to add attributes to PT stops of various PT modes that allow agents to   access via network or teleported modes</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>[Breaking change] New, default, representation of additional attributes     <pre><code>'attributes': {\n  'osm:way:highway': 'primary'\n}\n</code></pre>     Instead of:     <pre><code>'attributes': {\n  'osm:way:highway': {'name': 'osm:way:highway', 'class': 'java.lang.String', 'text': 'primary'}\n}\n</code></pre></li> <li>Crucially, this will affect methods that search for different values of OSM data, for example: find all links   of <code>highway</code> type <code>primary</code>, or links with particular OSM IDs.</li> <li>For backwards compatibility, use: <code>force_long_form_attributes=True</code> when reading the network and/or schedule   objects</li> <li>[Breaking change] folders renamed:</li> <li><code>inputs_handler</code> -&gt; <code>input</code></li> <li><code>outputs_handler</code> -&gt; <code>output</code></li> </ul>"},{"location":"CHANGELOG/#v201-snapshot-2022-04-08","title":"[v2.0.1-snapshot] - 2022-04-08","text":""},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Loosen version constraints for various pytest-related dependencies by @mfitz in https://github.com/arup-group/genet/pull/114</li> </ul> <p>Full Changelog: https://github.com/arup-group/genet/compare/v2.0.0-snapshot...v2.0.1-snapshot</p>"},{"location":"CHANGELOG/#v200-snapshot-2022-04-07","title":"[v2.0.0-snapshot] - 2022-04-07","text":"<p>Not production ready. No release notes other than the automated ones generated from commits.</p>"},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>update readme by @KasiaKoz in https://github.com/arup-group/genet/pull/53</li> <li>Fix simplifications script's help message (LAB-990) by @mfitz in https://github.com/arup-group/genet/pull/54</li> <li>Make link 'oneway' attribute optional when writing networks to disk by @mfitz in https://github.com/arup-group/genet/pull/56</li> <li>Schedule usage and modification by @KasiaKoz in https://github.com/arup-group/genet/pull/57</li> <li>Lab 1046 ValueError: cannot set a frame with no defined index and a scalar by @KasiaKoz in https://github.com/arup-group/genet/pull/63</li> <li>Lab 1045 speed up validation by @KasiaKoz in https://github.com/arup-group/genet/pull/64</li> <li>Lab 865 persistent benchmarks by @KasiaKoz in https://github.com/arup-group/genet/pull/59</li> <li>Lab 1014 NZ overflow by @KasiaKoz in https://github.com/arup-group/genet/pull/62</li> <li>add checks for zero value attributes on links to validation report by @KasiaKoz in https://github.com/arup-group/genet/pull/67</li> <li>Mf lab 1051 notebook smoketests by @mfitz in https://github.com/arup-group/genet/pull/68</li> <li>Lab 583 support vehicles by @KasiaKoz in https://github.com/arup-group/genet/pull/58</li> <li>Lab 1075 split service by direction by @KasiaKoz in https://github.com/arup-group/genet/pull/65</li> <li>Spatial methods to support snapping to links by @KasiaKoz in https://github.com/arup-group/genet/pull/66</li> <li>update google directions sending script by @KasiaKoz in https://github.com/arup-group/genet/pull/69</li> <li>use sets in route and service indexing on schedule graph by @KasiaKoz in https://github.com/arup-group/genet/pull/70</li> <li>Fix multi edge simplify bug by @KasiaKoz in https://github.com/arup-group/genet/pull/76</li> <li>add missing always_xy=True to a couple of transformers by @KasiaKoz in https://github.com/arup-group/genet/pull/78</li> <li>Support for new data types when reading/writing networks by @KasiaKoz in https://github.com/arup-group/genet/pull/73</li> <li>Bump pyyaml from 5.3.1 to 5.4 by @dependabot in https://github.com/arup-group/genet/pull/71</li> <li>Bump pygments from 2.6.1 to 2.7.4 by @dependabot in https://github.com/arup-group/genet/pull/72</li> <li>Fix network simplification script by @mfitz in https://github.com/arup-group/genet/pull/79</li> <li>Fix scripts by @KasiaKoz in https://github.com/arup-group/genet/pull/80</li> <li>add vehicles arg to readme by @gac55 in https://github.com/arup-group/genet/pull/83</li> <li>Add manifest by @mfitz in https://github.com/arup-group/genet/pull/85</li> <li>Update requirements by @KasiaKoz in https://github.com/arup-group/genet/pull/86</li> <li>Lab 1226 Refine Road Pricing by @KasiaKoz in https://github.com/arup-group/genet/pull/84</li> <li>import cordon class to be available at the highest genet level by @KasiaKoz in https://github.com/arup-group/genet/pull/87</li> <li>required python dependencies by @syhwawa in https://github.com/arup-group/genet/pull/88</li> <li>Make S3 code bucket a CI build variable by @mfitz in https://github.com/arup-group/genet/pull/92</li> <li>Parallel unit tests by @KasiaKoz in https://github.com/arup-group/genet/pull/89</li> <li>Connect disconnected subgraphs by @KasiaKoz in https://github.com/arup-group/genet/pull/91</li> <li>PT network route GeoDataFrame and geojson output by @KasiaKoz in https://github.com/arup-group/genet/pull/90</li> <li>add reprojection param to general standard network geojson outputs by @KasiaKoz in https://github.com/arup-group/genet/pull/95</li> <li>Fix runtime warnings by @mfitz in https://github.com/arup-group/genet/pull/94</li> <li>Lab 1315 kepler viz by @KasiaKoz in https://github.com/arup-group/genet/pull/97</li> <li>Vehicle checks by @ana-kop in https://github.com/arup-group/genet/pull/96</li> <li>Minor changes to the fixture names that weren't commited earlier by @ana-kop in https://github.com/arup-group/genet/pull/100</li> <li>Lab 1077 max stable set by @KasiaKoz in https://github.com/arup-group/genet/pull/98</li> <li>Lab 1378 iron out goog api by @ana-kop in https://github.com/arup-group/genet/pull/101</li> <li>Osm read fix by @KasiaKoz in https://github.com/arup-group/genet/pull/99</li> <li>PT headways by @KasiaKoz in https://github.com/arup-group/genet/pull/102</li> <li>Sub network/schedule by @KasiaKoz in https://github.com/arup-group/genet/pull/103</li> <li>Bump ipython from 7.14.0 to 7.16.3 by @dependabot in https://github.com/arup-group/genet/pull/105</li> <li>upgrade protobuf by @KasiaKoz in https://github.com/arup-group/genet/pull/106</li> <li>Allow set attribute values prior to simplification by @KasiaKoz in https://github.com/arup-group/genet/pull/108</li> <li>Fix loopy simplification by @KasiaKoz in https://github.com/arup-group/genet/pull/107</li> <li>Update CONTRIBUTING.md by @mfitz in https://github.com/arup-group/genet/pull/109</li> <li>Upgrade nbconvert dependency version by @mfitz in https://github.com/arup-group/genet/pull/111</li> <li>Generalise road pricing type by @KasiaKoz in https://github.com/arup-group/genet/pull/110</li> <li>Reduce Docker image size by @mfitz in https://github.com/arup-group/genet/pull/113</li> <li>Add/Remove Services and Routes in groups by @KasiaKoz in https://github.com/arup-group/genet/pull/112</li> </ul>"},{"location":"CHANGELOG/#new-contributors","title":"New Contributors","text":"<ul> <li>@syhwawa made their first contribution in https://github.com/arup-group/genet/pull/88</li> <li>@ana-kop made their first contribution in https://github.com/arup-group/genet/pull/96</li> </ul> <p>Full Changelog: https://github.com/arup-group/genet/compare/v1.0.0...v2.0.0-snapshot</p>"},{"location":"CHANGELOG/#v100-2021-02-01","title":"[v1.0.0] - 2021-02-01","text":""},{"location":"CHANGELOG/#initial-release","title":"Initial release","text":"<p>This is the first release, please check documentation/wiki for the usage guide</p>"},{"location":"reference/genet/auxiliary_files/","title":"genet.auxiliary_files","text":""},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile","title":"<code>AuxiliaryFile(path_to_file)</code>","text":"<p>Represents an auxiliary file of JSON or CSV format, can be 'attached' to a Network or Schedule object by sharing their IDs through the <code>attach</code> method. Does not require the file to follow a specific schema, it will search for an overlap in indices and record the path to that data within the file in the <code>attachments</code> attribute. It works under a few assumptions though:     - for CSV: table with single level indexing. The IDs can be nested in lists.     - for JSON: any level of nestedness is allowed, the IDs can live singularly or within lists. In both cases, the IDs of interest need to be stored as values and no other data using the same values is stored in the file. Can handle only one type of indices. So a file has to correspond to one set of indices, no mixing allowed.</p> Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def __init__(self, path_to_file: str):\n    self.path_to_file = path_to_file\n    self.filename = os.path.basename(path_to_file)\n    self.data = self.read_file()\n    self.attachments = []\n    self.map = {}\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.attachments","title":"<code>attachments = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.data","title":"<code>data = self.read_file()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.filename","title":"<code>filename = os.path.basename(path_to_file)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.map","title":"<code>map = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.path_to_file","title":"<code>path_to_file = path_to_file</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.apply_map","title":"<code>apply_map(id_map)</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def apply_map(self, id_map):\n    self.map = {**self.map, **id_map}\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.attach","title":"<code>attach(indices)</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def attach(self, indices: set):\n    if isinstance(self.data, dict):\n        self.attachments += dict_support.find_nested_paths_to_value(self.data, indices)\n    if isinstance(self.data, pd.DataFrame):\n        for col in self.data.columns:\n            if all([isinstance(x, (list, set)) for x in self.data[col]]):\n                if set(self.data[col].sum()) &amp; indices:\n                    self.attachments.append(col)\n            elif set(self.data[col]) &amp; indices:\n                self.attachments.append(col)\n    self.build_identity_map()\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.build_identity_map","title":"<code>build_identity_map()</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def build_identity_map(self):\n    ids = set()\n    if isinstance(self.data, dict):\n        for attachment in self.attachments:\n            attachment_data = dict_support.get_nested_value(self.data, attachment)\n            if isinstance(attachment_data, (list, set)):\n                ids |= set(attachment_data)\n            else:\n                ids.add(attachment_data)\n    else:\n        for attachment in self.attachments:\n            if all([isinstance(x, (list, set)) for x in self.data[attachment]]):\n                ids |= set(self.data[attachment].sum())\n            else:\n                ids |= set(self.data[attachment])\n    self.map = dict(zip(ids, ids))\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.has_updates","title":"<code>has_updates()</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def has_updates(self):\n    return any([k != v for k, v in self.map.items()])\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.is_attached","title":"<code>is_attached()</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def is_attached(self):\n    return self.attachments\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.read_file","title":"<code>read_file()</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def read_file(self):\n    if persistence.is_csv(self.path_to_file):\n        return self._read_csv()\n    elif persistence.is_json(self.path_to_file):\n        return self._read_json()\n    else:\n        raise NotImplementedError(\n            f\"File {self.path_to_file} is not currently supported as an auxiliary file.\"\n        )\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.update","title":"<code>update()</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def update(self):\n    if self.has_updates():\n        if isinstance(self.data, dict):\n            for attachment in self.attachments:\n                attachment_data = dict_support.get_nested_value(self.data, attachment)\n                if isinstance(attachment_data, (list, set)):\n                    value = attachment_data.__class__(map(self.map.get, attachment_data))\n                else:\n                    value = self.map[attachment_data]\n                self.data = dict_support.set_nested_value(\n                    self.data, dict_support.nest_at_leaf(deepcopy(attachment), value)\n                )\n        else:\n            for attachment in self.attachments:\n                if all([isinstance(x, (list, set)) for x in self.data[attachment]]):\n                    self.data[attachment] = self.data[attachment].apply(\n                        lambda x: x.__class__([self.map[i] for i in x])\n                    )\n                else:\n                    self.data[attachment] = self.data[attachment].replace(self.map)\n        self.build_identity_map()\n</code></pre>"},{"location":"reference/genet/auxiliary_files/#genet.auxiliary_files.AuxiliaryFile.write_to_file","title":"<code>write_to_file(output_dir)</code>","text":"Source code in <code>src/genet/auxiliary_files.py</code> <pre><code>def write_to_file(self, output_dir):\n    self.update()\n    persistence.ensure_dir(output_dir)\n    logging.info(f\"Saving auxiliary file {self.filename} in {output_dir}\")\n    if persistence.is_csv(self.filename):\n        return self._write_csv(output_dir)\n    elif persistence.is_json(self.filename):\n        return self._write_json(output_dir)\n    else:\n        raise NotImplementedError(\n            f\"File {self.filename} is not currently supported as an auxiliary file.\"\n        )\n</code></pre>"},{"location":"reference/genet/core/","title":"genet.core","text":""},{"location":"reference/genet/core/#genet.core.Network","title":"<code>Network(epsg, **kwargs)</code>","text":"<p>GeNet network class.</p> PARAMETER DESCRIPTION <code>epsg</code> <p>Coordinate reference system, e.g. \"EPSG:4326\".</p> <p> TYPE: <code>str</code> </p> <p>Keyword Args: will be added as attributes of the class.</p> Source code in <code>src/genet/core.py</code> <pre><code>def __init__(self, epsg: str, **kwargs):\n    \"\"\"GeNet network class.\n\n    Args:\n        epsg (str): Coordinate reference system, e.g. \"EPSG:4326\".\n\n    Keyword Args: will be added as attributes of the class.\n    \"\"\"\n    self.epsg = epsg\n    self.transformer = Transformer.from_crs(epsg, \"epsg:4326\", always_xy=True)\n    self.graph = nx.MultiDiGraph(name=\"Network graph\", crs=epsg)\n    self.attributes = {\"crs\": epsg}\n    self.schedule = schedule_elements.Schedule(epsg)\n    self.change_log = change_log.ChangeLog()\n    self.auxiliary_files = {\"node\": {}, \"link\": {}}\n    # link_id_mapping maps between (usually string literal) index per edge to the from and to nodes that are\n    # connected by the edge\n    self.link_id_mapping = {}\n    if kwargs:\n        self.add_additional_attributes(kwargs)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.attributes","title":"<code>attributes = {'crs': epsg}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.auxiliary_files","title":"<code>auxiliary_files = {'node': {}, 'link': {}}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.change_log","title":"<code>change_log = change_log.ChangeLog()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.epsg","title":"<code>epsg = epsg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.graph","title":"<code>graph = nx.MultiDiGraph(name='Network graph', crs=epsg)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.link_id_mapping","title":"<code>link_id_mapping = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.schedule","title":"<code>schedule = schedule_elements.Schedule(epsg)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.transformer","title":"<code>transformer = Transformer.from_crs(epsg, 'epsg:4326', always_xy=True)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/core/#genet.core.Network.add","title":"<code>add(other)</code>","text":"<p>This lets you add on <code>other</code> genet.Network to the network this method is called on.</p> <p>This is deliberately not a magic function to discourage <code>new_network = network_1 + network_2</code>, where memory goes out the window.</p> PARAMETER DESCRIPTION <code>other</code> <p>Network to add.</p> <p> TYPE: <code>Network</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Cannot add simplified and non-simplified networks together.</p> Source code in <code>src/genet/core.py</code> <pre><code>def add(self, other: \"Network\"):\n    \"\"\"This lets you add on `other` genet.Network to the network this method is called on.\n\n    This is deliberately not a magic function to discourage `new_network = network_1 + network_2`,\n    where memory goes out the window.\n\n    Args:\n        other (Network): Network to add.\n\n    Raises:\n        RuntimeError: Cannot add simplified and non-simplified networks together.\n    \"\"\"\n    if self.is_simplified() != other.is_simplified():\n        raise RuntimeError(\"You cannot add simplified and non-simplified networks together\")\n\n    # consolidate coordinate systems\n    if other.epsg != self.epsg:\n        logging.info(\n            f\"Attempting to merge two networks in different coordinate systems. \"\n            f\"Reprojecting from {other.epsg} to {self.epsg}\"\n        )\n        other.reproject(other.epsg)\n    # consolidate node ids\n    other = graph_operations.consolidate_node_indices(self, other)\n    # consolidate link ids\n    other = graph_operations.consolidate_link_indices(self, other)\n\n    # finally, once the node and link ids have been sorted, combine the graphs\n    # nx.compose(left, right) overwrites data in left with data in right under matching ids\n    self.graph = nx.compose(other.graph, self.graph)\n    # finally, combine link_id_mappings\n    self.link_id_mapping = {**other.link_id_mapping, **self.link_id_mapping}\n\n    # combine schedules\n    self.schedule.add(other.schedule)\n\n    # merge change_log DataFrames\n    self.change_log = self.change_log.merge_logs(other.change_log)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.add_additional_attributes","title":"<code>add_additional_attributes(attribs)</code>","text":"<p>Adds attributes defined by keys of the attribs dictionary with values of the corresponding values.</p> PARAMETER DESCRIPTION <code>attribs</code> <p>The additional attributes {attribute_name: attribute_value}</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def add_additional_attributes(self, attribs: dict):\n    \"\"\"Adds attributes defined by keys of the attribs dictionary with values of the corresponding values.\n\n    Args:\n        attribs (dict): The additional attributes {attribute_name: attribute_value}\n    \"\"\"\n    for k, v in attribs.items():\n        if k not in self.__dict__:\n            setattr(self, k, v)\n        else:\n            logging.warning(\n                f\"{self.__class__.__name__} already has an additional attribute: {k}. \"\n                \"Consider overwritting it instead.\"\n            )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.add_edge","title":"<code>add_edge(u, v, multi_edge_idx=None, attribs=None, silent=False)</code>","text":"<p>Adds an edge between u and v.</p> <p>If an edge between u and v already exists, adds an additional one. Generates a new link id. If you already have a link id, use the method to add_link.</p> PARAMETER DESCRIPTION <code>u</code> <p>node in the graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>v</code> <p>node in the graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>multi_edge_idx</code> <p>You can specify which multi index to use if there are other edges between u and v. Will generate new index if already used. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>attribs</code> <p>Attributes to add to generated link. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Generated link ID</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def add_edge(\n    self,\n    u: Union[str, int],\n    v: Union[str, int],\n    multi_edge_idx: Optional[int] = None,\n    attribs: Optional[dict] = None,\n    silent: bool = False,\n) -&gt; str:\n    \"\"\"Adds an edge between u and v.\n\n    If an edge between u and v already exists, adds an additional one.\n    Generates a new link id.\n    If you already have a link id, use the method to add_link.\n\n    Args:\n        u (Union[str, int]): node in the graph.\n        v (Union[str, int]): node in the graph.\n        multi_edge_idx (Optional[int], optional):\n            You can specify which multi index to use if there are other edges between u and v.\n            Will generate new index if already used.\n            Defaults to None.\n        attribs (Optional[dict], optional): Attributes to add to generated link. Defaults to None.\n        silent (bool, optional): Whether to mute stdout logging messages. Defaults to False.\n\n    Returns:\n        str: Generated link ID\n    \"\"\"\n    link_id = self.generate_index_for_edge(silent=silent)\n    self.add_link(link_id, u, v, multi_edge_idx, attribs, silent)\n    if not silent:\n        logging.info(f\"Added edge from `{u}` to `{v}` with link_id `{link_id}`\")\n    return link_id\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.add_edges","title":"<code>add_edges(edges_attributes, silent=False, ignore_change_log=False)</code>","text":"<p>Adds multiple edges, generates unique link ids for each.</p> PARAMETER DESCRIPTION <code>edges_attributes</code> <p>List of edges, each item in list is a dictionary defining the edge attributes. Contains at least <code>'from': node_id</code> and <code>'to': node_id</code> entries.</p> <p> TYPE: <code>list[dict]</code> </p> <code>silent</code> <p>whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ignore_change_log</code> <p>Whether to ignore logging changes to the network in the changelog. Not recommended. Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Edge <code>from</code> and <code>to</code> nodes must exist in the network.</p> RETURNS DESCRIPTION <code>tuple[dict, dict]</code> <p>tuple[dict, dict]: First dict is a mapping from input link IDs to internal link IDs (IDs reindexed if there is any name clashes with existing links). Second dict is <code>edge_attributes</code> with link IDs updated according to the mapping of the first dict.</p> Source code in <code>src/genet/core.py</code> <pre><code>def add_edges(\n    self, edges_attributes: list[dict], silent: bool = False, ignore_change_log: bool = False\n) -&gt; tuple[dict, dict]:\n    \"\"\"Adds multiple edges, generates unique link ids for each.\n\n    Args:\n        edges_attributes (list[dict]):\n            List of edges, each item in list is a dictionary defining the edge attributes.\n            Contains at least `'from': node_id` and `'to': node_id` entries.\n        silent (bool, optional):  whether to mute stdout logging messages. Defaults to False.\n        ignore_change_log (bool, optional):\n            Whether to ignore logging changes to the network in the changelog.\n            Not recommended.\n            Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat.\n            Defaults to False.\n\n    Raises:\n        RuntimeError: Edge `from` and `to` nodes must exist in the network.\n\n    Returns:\n        tuple[dict, dict]:\n            First dict is a mapping from input link IDs to internal link IDs (IDs reindexed if there is any name clashes with existing links).\n            Second dict is `edge_attributes` with link IDs updated according to the mapping of the first dict.\n    \"\"\"\n    # check for compulsory attribs\n    df_edges = pd.DataFrame(edges_attributes)\n    if (\"from\" not in df_edges.columns) or (df_edges[\"from\"].isnull().any()):\n        raise RuntimeError(\n            \"You are trying to add edges which are missing `from` (origin) nodes\"\n        )\n    if (\"to\" not in df_edges.columns) or (df_edges[\"to\"].isnull().any()):\n        raise RuntimeError(\n            \"You are trying to add edges which are missing `to` (destination) nodes\"\n        )\n\n    df_edges[\"id\"] = list(self.generate_indices_for_n_edges(len(df_edges)))\n    df_edges = df_edges.set_index(\"id\", drop=False)\n\n    return self.add_links(\n        df_edges.T.to_dict(), silent=silent, ignore_change_log=ignore_change_log\n    )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.add_link","title":"<code>add_link(link_id, u, v, multi_edge_idx=None, attribs=None, silent=False)</code>","text":"<p>Adds a link between u and v with id link_id, if available.</p> <p>If a link between u and v already exists, adds an additional one.</p> PARAMETER DESCRIPTION <code>link_id</code> <p> TYPE: <code>Union[str, int]</code> </p> <code>u</code> <p>node in the graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>v</code> <p>node in the graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>multi_edge_idx</code> <p>You can specify which multi index to use if there are other edges between u and v. Will generate new index if already used. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>attribs</code> <p>Attributes to add to generated link. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Generated link ID.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def add_link(\n    self,\n    link_id: Union[str, int],\n    u: Union[str, int],\n    v: Union[str, int],\n    multi_edge_idx: Optional[int] = None,\n    attribs: Optional[dict] = None,\n    silent: bool = False,\n) -&gt; str:\n    \"\"\"Adds a link between u and v with id link_id, if available.\n\n    If a link between u and v already exists, adds an additional one.\n\n    Args:\n        link_id Union[str, int]:\n        u (Union[str, int]): node in the graph.\n        v (Union[str, int]): node in the graph.\n        multi_edge_idx (Optional[int], optional):\n            You can specify which multi index to use if there are other edges between u and v.\n            Will generate new index if already used.\n            Defaults to None.\n        attribs (Optional[dict], optional): Attributes to add to generated link. Defaults to None.\n        silent (bool, optional): Whether to mute stdout logging messages. Defaults to False.\n\n    Returns:\n        str: Generated link ID.\n    \"\"\"\n    if link_id in self.link_id_mapping:\n        new_link_id = self.generate_index_for_edge(silent=silent)\n        logging.warning(\n            f\"`{link_id}` already exists. Generated a new unique_index: `{new_link_id}`\"\n        )\n        link_id = new_link_id\n\n    if multi_edge_idx is None:\n        multi_edge_idx = self.graph.new_edge_key(u, v)\n    if self.graph.has_edge(u, v, multi_edge_idx):\n        old_idx = multi_edge_idx\n        multi_edge_idx = self.graph.new_edge_key(u, v)\n        logging.warning(\n            f\"Changing passed multi_edge_idx: `{old_idx}` as there already exists an edge stored under\"\n            f\" that index. New multi_edge_idx: `{multi_edge_idx}`\"\n        )\n    if not isinstance(multi_edge_idx, int):\n        raise RuntimeError(\"Multi index key needs to be an integer\")\n\n    self.link_id_mapping[link_id] = {\"from\": u, \"to\": v, \"multi_edge_idx\": multi_edge_idx}\n\n    compulsory_attribs = {\"from\": u, \"to\": v, \"id\": link_id}\n\n    if attribs is None:\n        attribs = compulsory_attribs\n    else:\n        attribs = {**attribs, **compulsory_attribs}\n\n    if \"length\" not in attribs.keys():\n        length = self.link_length(u, v, geometry=attribs.get(\"geometry\"))\n        if length is not None:\n            attribs[\"length\"] = length\n\n    self.graph.add_edge(u, v, key=multi_edge_idx, **attribs)\n    self.change_log.add(object_type=\"link\", object_id=link_id, object_attributes=attribs)\n    if not silent:\n        logging.info(\n            f\"Added Link with index {link_id}, from node:{u} to node:{v}, under \"\n            f\"multi-index:{multi_edge_idx}, and data={attribs}\"\n        )\n    return link_id\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.add_links","title":"<code>add_links(links_and_attributes, silent=False, ignore_change_log=False)</code>","text":"<p>Adds multiple links.</p> PARAMETER DESCRIPTION <code>links_and_attributes</code> <p>List of links, each item in list is a dictionary defining the link ID and its attributes. Contains at least <code>'from': node_id</code> and <code>'to': node_id</code> entries.</p> <p> TYPE: <code>list[dict]</code> </p> <code>silent</code> <p>whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ignore_change_log</code> <p>Whether to ignore logging changes to the network in the changelog. Not recommended. Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Link <code>from</code> and <code>to</code> nodes must exist in the network.</p> RETURNS DESCRIPTION <code>tuple[dict, dict]</code> <p>tuple[dict, dict]: First dict is a mapping from input link IDs to internal link IDs (IDs reindexed if there is any name clashes with existing links). Second dict is <code>links_and_attributes</code> with link IDs updated according to the mapping of the first dict.</p> Source code in <code>src/genet/core.py</code> <pre><code>def add_links(\n    self,\n    links_and_attributes: dict[str, dict],\n    silent: bool = False,\n    ignore_change_log: bool = False,\n) -&gt; tuple[dict, dict]:\n    \"\"\"Adds multiple links.\n\n    Args:\n        links_and_attributes (list[dict]):\n            List of links, each item in list is a dictionary defining the link ID and its attributes.\n            Contains at least `'from': node_id` and `'to': node_id` entries.\n        silent (bool, optional):  whether to mute stdout logging messages. Defaults to False.\n        ignore_change_log (bool, optional):\n            Whether to ignore logging changes to the network in the changelog.\n            Not recommended.\n            Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat.\n            Defaults to False.\n\n    Raises:\n        RuntimeError: Link `from` and `to` nodes must exist in the network.\n\n    Returns:\n        tuple[dict, dict]:\n            First dict is a mapping from input link IDs to internal link IDs (IDs reindexed if there is any name clashes with existing links).\n            Second dict is `links_and_attributes` with link IDs updated according to the mapping of the first dict.\n    \"\"\"\n    # check for compulsory attribs\n    df_links = pd.DataFrame(links_and_attributes).T\n    if (\"from\" not in df_links.columns) or (df_links[\"from\"].isnull().any()):\n        raise RuntimeError(\n            \"You are trying to add links which are missing `from` (origin) nodes\"\n        )\n    if (\"to\" not in df_links.columns) or (df_links[\"to\"].isnull().any()):\n        raise RuntimeError(\n            \"You are trying to add links which are missing `to` (destination) nodes\"\n        )\n\n    if (\"id\" not in df_links.columns) or (df_links[\"id\"].isnull().any()):\n        df_links[\"id\"] = df_links.index\n    if \"length\" not in df_links.columns:\n        df_links[\"length\"] = float(\"nan\")\n    if df_links[\"length\"].isnull().any():\n        missing_length_mask = df_links[\"length\"].isnull()\n        logging.warning(\n            f\"The following links: {list(df_links[missing_length_mask].index)} are missing `length` attribute. \"\n            \"A straight line distance between from and to nodes will be computed.\"\n        )\n        s2_map = self.node_attribute_data_under_key(\"s2_id\").to_dict()\n        df_links[\"s2_from\"] = df_links[\"from\"].map(s2_map)\n        df_links[\"s2_to\"] = df_links[\"to\"].map(s2_map)\n        # TODO add length calculation based on complex geometry\n        missing_spatial_info_mask = df_links[\"s2_from\"].isnull() | df_links[\"s2_to\"].isnull()\n        df_links.loc[missing_length_mask &amp; ~missing_spatial_info_mask, \"length\"] = df_links.loc[\n            missing_length_mask &amp; ~missing_spatial_info_mask, :\n        ].apply(\n            lambda row: round(spatial.distance_between_s2cellids(row[\"s2_from\"], row[\"s2_to\"])),\n            axis=1,\n        )\n        cols_to_drop = [\"s2_from\", \"s2_to\"]\n        if df_links[\"length\"].isnull().all():\n            cols_to_drop.append(\"length\")\n        df_links.drop(cols_to_drop, axis=1, inplace=True)\n\n    # generate initial multi_edge_idxes for the links to be added\n    if \"multi_edge_idx\" not in df_links.columns:\n        df_links[\"multi_edge_idx\"] = df_links.apply(\n            lambda x: self.graph.new_edge_key(x[\"from\"], x[\"to\"]), axis=1\n        )\n        while df_links[[\"from\", \"to\", \"multi_edge_idx\"]].duplicated().any():\n            df_links.loc[\n                df_links[[\"from\", \"to\", \"multi_edge_idx\"]].duplicated(), \"multi_edge_idx\"\n            ] += 1\n\n    df_link_id_mapping = pd.DataFrame(self.link_id_mapping).T\n    df_link_id_mapping[\"id\"] = df_link_id_mapping.index\n    if not df_link_id_mapping.empty:\n        _df = pd.merge(\n            df_links,\n            df_link_id_mapping,\n            how=\"left\",\n            on=(\"from\", \"to\", \"multi_edge_idx\"),\n            suffixes=(\"_to_add\", \"_in_graph\"),\n        )\n\n        # generate new multi_edge_idx where it clashes with existing links\n        def generate_unique_multi_idx(group):\n            multi_idx_to_avoid = df_link_id_mapping[\n                (df_link_id_mapping[\"from\"] == group.name[0])\n                &amp; (df_link_id_mapping[\"to\"] == group.name[1])\n            ][\"multi_edge_idx\"]\n            while (\n                group[\"multi_edge_idx\"].isin(multi_idx_to_avoid).any()\n                | group[\"multi_edge_idx\"].duplicated().any()\n            ):\n                group.loc[\n                    (group[\"multi_edge_idx\"].isin(multi_idx_to_avoid))\n                    | (group[\"multi_edge_idx\"].duplicated()),\n                    \"multi_edge_idx\",\n                ] += 1\n            return group\n\n        clashing_multi_idxs = _df[_df[\"id_in_graph\"].notna()][\"id_to_add\"]\n        df_clashing_midx = _df[_df[\"id_to_add\"].isin(clashing_multi_idxs)]\n        clashing_multi_idxs = _df[\n            _df[\"from\"].isin(df_clashing_midx[\"from\"]) &amp; _df[\"to\"].isin(df_clashing_midx[\"to\"])\n        ][\"id_to_add\"]\n\n        df_links.loc[df_links[\"id\"].isin(clashing_multi_idxs)] = (\n            df_links[df_links[\"id\"].isin(clashing_multi_idxs)]\n            .groupby([\"from\", \"to\"])\n            .apply(generate_unique_multi_idx)\n            .set_index(\"id\", drop=False)\n        )\n\n        # generate unique indices if not\n        clashing_link_ids = set(self.link_id_mapping.keys()) &amp; set(links_and_attributes.keys())\n        reindexing_dict = dict(\n            zip(\n                clashing_link_ids,\n                self.generate_indices_for_n_edges(\n                    len(clashing_link_ids), avoid_keys=set(links_and_attributes.keys())\n                ),\n            )\n        )\n        clashing_mask = df_links[\"id\"].isin(reindexing_dict.keys())\n        df_links.loc[clashing_mask, \"id\"] = df_links.loc[clashing_mask, \"id\"].map(\n            reindexing_dict\n        )\n        df_links = df_links.set_index(\"id\", drop=False)\n    else:\n        reindexing_dict = {}\n\n    # end with updated links_and_attributes dict\n    add_to_link_id_mapping = df_links[[\"from\", \"to\", \"multi_edge_idx\"]].T.to_dict()\n    df_links = df_links.drop(\"multi_edge_idx\", axis=1)\n    links_and_attributes = {\n        _id: {k: v for k, v in m.items() if pd_helpers.notna(v)}\n        for _id, m in df_links.T.to_dict().items()\n    }\n\n    # update link_id_mapping\n    self.link_id_mapping = {**self.link_id_mapping, **add_to_link_id_mapping}\n\n    self.graph.add_edges_from(\n        [\n            (\n                attribs[\"from\"],\n                attribs[\"to\"],\n                add_to_link_id_mapping[link][\"multi_edge_idx\"],\n                attribs,\n            )\n            for link, attribs in links_and_attributes.items()\n        ]\n    )\n    if not ignore_change_log:\n        self.change_log = self.change_log.add_bunch(\n            object_type=\"link\",\n            id_bunch=list(links_and_attributes.keys()),\n            attributes_bunch=list(links_and_attributes.values()),\n        )\n    if not silent:\n        logging.info(f\"Added {len(links_and_attributes)} links\")\n    return reindexing_dict, links_and_attributes\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.add_node","title":"<code>add_node(node, attribs, silent=False)</code>","text":"<p>Adds a node.</p> PARAMETER DESCRIPTION <code>node</code> <p>Node ID to add.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>attribs</code> <p>Node attributes. Must include spatial information x,y in epsg consistent with the network, or lat lon in \"epsg:4326\".</p> <p> TYPE: <code>dict</code> </p> <code>silent</code> <p>Whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>If node ID clashes with existing ID, the mapping of input node ID with renamed node ID.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def add_node(self, node: Union[str, int], attribs: dict, silent: bool = False) -&gt; dict:\n    \"\"\"Adds a node.\n\n    Args:\n        node (Union[str, int]): Node ID to add.\n        attribs (dict):\n            Node attributes.\n            Must include spatial information x,y in epsg consistent with the network, or lat lon in \"epsg:4326\".\n        silent (bool, optional): Whether to mute stdout logging messages. Defaults to False.\n\n    Returns:\n        dict: If node ID clashes with existing ID, the mapping of input node ID with renamed node ID.\n    \"\"\"\n    return self.add_nodes({node: attribs}, silent=silent)[0]\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.add_nodes","title":"<code>add_nodes(nodes_and_attribs, silent=False, ignore_change_log=False)</code>","text":"<p>Adds nodes, reindexes if indices are clashing with nodes already in the network.</p> PARAMETER DESCRIPTION <code>nodes_and_attribs</code> <p><code>{index_for_node: {attribute dictionary for that node}}</code>.</p> <p> TYPE: <code>dict</code> </p> <code>silent</code> <p>Whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ignore_change_log</code> <p>Whether to ignore logging changes to the network in the changelog. Not recommended. Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Must include spatial information in node attribute dictionary.</p> RETURNS DESCRIPTION <code>tuple[dict, dict]</code> <p>tuple[dict, dict]: First dict is a mapping from input node IDs to internal node IDs (IDs reindexed if there is any name clashes with existing nodes). Second dict is <code>nodes_and_attribs</code> with node IDs updated according to the mapping of the first dict.</p> Source code in <code>src/genet/core.py</code> <pre><code>def add_nodes(\n    self, nodes_and_attribs: dict, silent: bool = False, ignore_change_log: bool = False\n) -&gt; tuple[dict, dict]:\n    \"\"\"Adds nodes, reindexes if indices are clashing with nodes already in the network.\n\n    Args:\n        nodes_and_attribs (dict): `{index_for_node: {attribute dictionary for that node}}`.\n        silent (bool, optional): Whether to mute stdout logging messages. Defaults to False.\n        ignore_change_log (bool, optional):\n            Whether to ignore logging changes to the network in the changelog.\n            Not recommended.\n            Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat.\n            Defaults to False.\n\n    Raises:\n        RuntimeError: Must include spatial information in node attribute dictionary.\n\n    Returns:\n        tuple[dict, dict]:\n            First dict is a mapping from input node IDs to internal node IDs (IDs reindexed if there is any name clashes with existing nodes).\n            Second dict is `nodes_and_attribs` with node IDs updated according to the mapping of the first dict.\n    \"\"\"\n\n    # check for spatial info\n    for node_id, attribs in nodes_and_attribs.items():\n        keys = set(attribs.keys())\n        if not ({\"lat\", \"lon\"}.issubset(keys) or {\"x\", \"y\"}.issubset(keys)):\n            raise RuntimeError(\n                f\"Cannot add Node `{node_id}` without spatial information. \"\n                f\"Given attributes: `{keys}` are not sufficient. This method requires lat, lon \"\n                f\"attributes in epsg:4326 or x, y in epsg of the network: {self.epsg}\"\n            )\n\n    # check for clashing node IDs\n    clashing_node_ids = set(dict(self.nodes()).keys()) &amp; set(nodes_and_attribs.keys())\n\n    df_nodes = pd.DataFrame(nodes_and_attribs).T\n    reindexing_dict = {}\n    if (\"id\" not in df_nodes.columns) or (df_nodes[\"id\"].isnull().any()):\n        df_nodes[\"id\"] = df_nodes.index\n    if not {\"lat\", \"lon\"}.issubset(set(df_nodes.columns)):\n        df_nodes[[\"lon\", \"lat\"]] = float(\"nan\")\n    if not {\"x\", \"y\"}.issubset(set(df_nodes.columns)):\n        df_nodes[[\"x\", \"y\"]] = float(\"nan\")\n    if df_nodes[[\"lon\", \"lat\"]].isnull().any().any():\n        missing_lat_lon = df_nodes[[\"lon\", \"lat\"]].isnull().T.any()\n        df_nodes.loc[missing_lat_lon, [\"lon\", \"lat\"]] = pd.DataFrame(\n            list(\n                df_nodes.loc[missing_lat_lon].apply(\n                    lambda row: spatial.change_proj(row[\"x\"], row[\"y\"], self.transformer),\n                    axis=1,\n                )\n            ),\n            columns=[\"lon\", \"lat\"],\n            index=df_nodes.loc[missing_lat_lon].index,\n        )\n    if df_nodes[[\"x\", \"y\"]].isnull().any().any():\n        missing_x_y = df_nodes[[\"x\", \"y\"]].isnull().T.any()\n        transformer = Transformer.from_crs(\"epsg:4326\", self.epsg, always_xy=True)\n        df_nodes.loc[missing_x_y, [\"x\", \"y\"]] = pd.DataFrame(\n            list(\n                df_nodes.loc[missing_x_y].apply(\n                    lambda row: spatial.change_proj(row[\"lon\"], row[\"lat\"], transformer), axis=1\n                )\n            ),\n            columns=[\"x\", \"y\"],\n            index=df_nodes.loc[missing_x_y].index,\n        )\n\n    nodes_and_attribs_to_add = dict_support.merge_complex_dictionaries(\n        df_nodes[[\"x\", \"y\", \"lon\", \"lat\", \"id\"]].T.to_dict(), nodes_and_attribs\n    )\n\n    # pandas is terrible with large numbers so we update them/generate them here\n    for node, attribs in nodes_and_attribs_to_add.items():\n        if \"s2_id\" not in nodes_and_attribs[node]:\n            attribs[\"s2_id\"] = spatial.generate_index_s2(attribs[\"lat\"], attribs[\"lon\"])\n    if clashing_node_ids:\n        logging.warning(\n            \"Some proposed IDs for nodes are already being used. New, unique IDs will be found.\"\n        )\n        reindexing_dict = dict(\n            zip(\n                clashing_node_ids,\n                self.generate_indices_for_n_nodes(\n                    len(nodes_and_attribs), avoid_keys=set(nodes_and_attribs.keys())\n                ),\n            )\n        )\n        for old_id, new_id in reindexing_dict.items():\n            nodes_and_attribs_to_add[new_id] = nodes_and_attribs_to_add[old_id]\n            nodes_and_attribs_to_add[new_id][\"id\"] = new_id\n            del nodes_and_attribs_to_add[old_id]\n\n    self.graph.add_nodes_from(\n        [(node_id, attribs) for node_id, attribs in nodes_and_attribs_to_add.items()]\n    )\n    if not ignore_change_log:\n        self.change_log = self.change_log.add_bunch(\n            object_type=\"node\",\n            id_bunch=list(nodes_and_attribs_to_add.keys()),\n            attributes_bunch=list(nodes_and_attribs_to_add.values()),\n        )\n    if not silent:\n        logging.info(f\"Added {len(nodes_and_attribs)} nodes\")\n    return reindexing_dict, nodes_and_attribs_to_add\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_attributes_to_edge","title":"<code>apply_attributes_to_edge(u, v, new_attributes, conditions=None, how=any, silent=False)</code>","text":"<p>Applies attributes to edges (which optionally match certain criteria).</p> PARAMETER DESCRIPTION <code>u</code> <p>from node.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>v</code> <p>to node.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>new_attributes</code> <p>attributes data to be applied.</p> <p> TYPE: <code>dict</code> </p> <code>conditions</code> <p><code>graph_operations.Filter</code> conditions. Defaults to None.</p> <p> TYPE: <code>Optional[Union[dict, list]]</code> DEFAULT: <code>None</code> </p> <code>how</code> <p><code>graph_operations.Filter</code> how. Defaults to any.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>silent</code> <p>whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_attributes_to_edge(\n    self,\n    u: Union[str, int],\n    v: Union[str, int],\n    new_attributes: dict,\n    conditions: Optional[Union[dict, list]] = None,\n    how: Callable = any,\n    silent: bool = False,\n):\n    \"\"\"Applies attributes to edges (which optionally match certain criteria).\n\n    Args:\n        u (Union[str, int]): from node.\n        v (Union[str, int]): to node.\n        new_attributes (dict): attributes data to be applied.\n        conditions (Optional[Union[dict, list]], optional): `graph_operations.Filter` conditions. Defaults to None.\n        how (Callable, optional): `graph_operations.Filter` how. Defaults to any.\n        silent (bool, optional): whether to mute stdout logging messages. Defaults to False.\n    \"\"\"\n    filter = graph_operations.Filter(conditions=conditions, how=how)\n\n    for multi_idx, edge_attribs in self.edge(u, v).items():\n        if filter.satisfies_conditions(edge_attribs):\n            old_attributes = deepcopy(edge_attribs)\n\n            # check if change is to nested part of node data\n            if any(isinstance(v, dict) for v in new_attributes.values()):\n                new_attribs = dict_support.set_nested_value(old_attributes, new_attributes)\n            else:\n                new_attribs = {**old_attributes, **new_attributes}\n\n            edge = f\"({u}, {v}, {multi_idx})\"\n\n            self.change_log.modify(\n                object_type=\"edge\",\n                old_id=edge,\n                new_id=edge,\n                old_attributes=edge_attribs,\n                new_attributes=new_attribs,\n            )\n\n            nx.set_edge_attributes(self.graph, {(u, v, multi_idx): new_attribs})\n            if not silent:\n                logging.info(f\"Changed Edge attributes under index: {edge}\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_attributes_to_edges","title":"<code>apply_attributes_to_edges(new_attributes, conditions=None, how=any)</code>","text":"<p>Applies new attributes for edges (optionally satisfying certain criteria).</p> PARAMETER DESCRIPTION <code>new_attributes</code> <p>Dictionary where keys are two tuples (u, v) where u is the from node and v is the to node. The value at the key are the new attributes to be applied to links on edge (u,v).</p> <p> TYPE: <code>dict</code> </p> <code>conditions</code> <p><code>graph_operations.Filter</code> conditions. Defaults to None.</p> <p> TYPE: <code>Optional[Union[dict, list]]</code> DEFAULT: <code>None</code> </p> <code>how</code> <p><code>graph_operations.Filter</code> how. Defaults to any.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_attributes_to_edges(\n    self,\n    new_attributes: dict,\n    conditions: Optional[Union[dict, list]] = None,\n    how: Callable = any,\n):\n    \"\"\"Applies new attributes for edges (optionally satisfying certain criteria).\n\n    Args:\n        new_attributes (dict):\n            Dictionary where keys are two tuples (u, v) where u is the from node and v is the to node.\n            The value at the key are the new attributes to be applied to links on edge (u,v).\n        conditions (Optional[Union[dict, list]], optional): `graph_operations.Filter` conditions. Defaults to None.\n        how (Callable, optional): `graph_operations.Filter` how. Defaults to any.\n    \"\"\"\n    filter = graph_operations.Filter(conditions=conditions, how=how)\n\n    old_attribs = []\n    new_attribs = []\n    edge_tuples = []\n\n    for (u, v), attribs_to_set in new_attributes.items():\n        for multi_idx, edge_attribs in self.edge(u, v).items():\n            if filter.satisfies_conditions(edge_attribs):\n                old_attribs.append(deepcopy(edge_attribs))\n                new_attribs.append(dict_support.set_nested_value(edge_attribs, attribs_to_set))\n                edge_tuples.append((u, v, multi_idx))\n\n    edge_ids = list(map(str, edge_tuples))\n    self.change_log = self.change_log.modify_bunch(\n        object_type=\"edge\",\n        old_id_bunch=edge_ids,\n        old_attributes=old_attribs,\n        new_id_bunch=edge_ids,\n        new_attributes=new_attribs,\n    )\n    nx.set_edge_attributes(self.graph, dict(zip(edge_tuples, new_attribs)))\n\n    logging.info(f\"Changed Edge attributes for {len(edge_tuples)} edges\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_attributes_to_link","title":"<code>apply_attributes_to_link(link_id, new_attributes, silent=False)</code>","text":"<p>Adds, or changes if already present, the attributes in <code>new_attributes</code> in-place.</p> <p>Doesn't replace the dictionary stored at the link currently so no data is lost, unless it is being overwritten.</p> PARAMETER DESCRIPTION <code>link_id</code> <p>link id to perform the change to.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>new_attributes</code> <p>dictionary of data to add/replace if present.</p> <p> TYPE: <code>dict</code> </p> <code>silent</code> <p>whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_attributes_to_link(\n    self, link_id: Union[str, int], new_attributes: dict, silent: bool = False\n):\n    \"\"\"Adds, or changes if already present, the attributes in `new_attributes` in-place.\n\n    Doesn't replace the dictionary stored at the link currently so no data is lost, unless it is being overwritten.\n\n    Args:\n        link_id (Union[str, int]): link id to perform the change to.\n        new_attributes (dict): dictionary of data to add/replace if present.\n        silent (bool, optional): whether to mute stdout logging messages. Defaults to False.\n    \"\"\"\n    u, v = self.link_id_mapping[link_id][\"from\"], self.link_id_mapping[link_id][\"to\"]\n    multi_idx = self.link_id_mapping[link_id][\"multi_edge_idx\"]\n    old_attributes = deepcopy(self.link(link_id))\n\n    # check if change is to nested part of node data\n    if any(isinstance(v, dict) for v in new_attributes.values()):\n        new_attributes = dict_support.set_nested_value(old_attributes, new_attributes)\n    else:\n        new_attributes = {**old_attributes, **new_attributes}\n\n    self.change_log.modify(\n        object_type=\"link\",\n        old_id=link_id,\n        new_id=link_id,\n        old_attributes=self.link(link_id),\n        new_attributes=new_attributes,\n    )\n\n    nx.set_edge_attributes(self.graph, {(u, v, multi_idx): new_attributes})\n    if not silent:\n        logging.info(f\"Changed Link attributes under index: {link_id}\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_attributes_to_links","title":"<code>apply_attributes_to_links(new_attributes)</code>","text":"<p>Adds, or changes if already present, the attributes in <code>new_attributes</code> in-place.</p> <p>Doesn't replace the dictionary stored at the link currently so no data is lost, unless it is being overwritten.</p> PARAMETER DESCRIPTION <code>new_attributes</code> <p>keys are link ids and values are dictionaries of data to add/replace if present.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_attributes_to_links(self, new_attributes: dict):\n    \"\"\"Adds, or changes if already present, the attributes in `new_attributes` in-place.\n\n    Doesn't replace the dictionary stored at the link currently so no data is lost, unless it is being overwritten.\n\n    Args:\n        new_attributes (dict): keys are link ids and values are dictionaries of data to add/replace if present.\n    \"\"\"\n    links = list(new_attributes.keys())\n    old_attribs = [deepcopy(self.link(link)) for link in links]\n    new_attribs = [\n        dict_support.set_nested_value(self.link(link), new_attributes[link]) for link in links\n    ]\n    edge_tuples = [self.edge_tuple_from_link_id(link) for link in links]\n\n    self.change_log = self.change_log.modify_bunch(\n        \"link\", links, old_attribs, links, new_attribs\n    )\n    nx.set_edge_attributes(self.graph, dict(zip(edge_tuples, new_attribs)))\n    logging.info(f\"Changed Link attributes for {len(links)} links\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_attributes_to_node","title":"<code>apply_attributes_to_node(node_id, new_attributes, silent=False)</code>","text":"<p>Adds, or changes if already present, the attributes in <code>new_attributes</code> in-place.</p> <p>Doesn't replace the dictionary stored at the node currently so no data is lost, unless it is being overwritten.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>node id to perform the change to.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>new_attributes</code> <p>dictionary of data to add/replace if present.</p> <p> TYPE: <code>dict</code> </p> <code>silent</code> <p>whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_attributes_to_node(\n    self, node_id: Union[str, int], new_attributes: dict, silent: bool = False\n):\n    \"\"\"Adds, or changes if already present, the attributes in `new_attributes` in-place.\n\n    Doesn't replace the dictionary stored at the node currently so no data is lost, unless it is being overwritten.\n\n    Args:\n        node_id (Union[str, int]): node id to perform the change to.\n        new_attributes (dict): dictionary of data to add/replace if present.\n        silent (bool, optional): whether to mute stdout logging messages. Defaults to False.\n    \"\"\"\n    old_attributes = deepcopy(self.node(node_id))\n\n    # check if change is to nested part of node data\n    if any(isinstance(v, dict) for v in new_attributes.values()):\n        new_attributes = dict_support.set_nested_value(old_attributes, new_attributes)\n    else:\n        new_attributes = {**old_attributes, **new_attributes}\n\n    self.change_log.modify(\n        object_type=\"node\",\n        old_id=node_id,\n        new_id=node_id,\n        old_attributes=self.node(node_id),\n        new_attributes=new_attributes,\n    )\n    nx.set_node_attributes(self.graph, {node_id: new_attributes})\n    if not silent:\n        logging.info(f\"Changed Node attributes under index: {node_id}\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_attributes_to_nodes","title":"<code>apply_attributes_to_nodes(new_attributes)</code>","text":"<p>Adds, or changes if already present, the attributes in <code>new_attributes</code> in-place.</p> <p>Doesn't replace the dictionary stored at the node currently so no data is lost, unless it is being overwritten.</p> PARAMETER DESCRIPTION <code>new_attributes</code> <p>keys are node ids and values are dictionaries of data to add/replace if present.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_attributes_to_nodes(self, new_attributes: dict):\n    \"\"\"Adds, or changes if already present, the attributes in `new_attributes` in-place.\n\n    Doesn't replace the dictionary stored at the node currently so no data is lost, unless it is being overwritten.\n\n    Args:\n        new_attributes (dict): keys are node ids and values are dictionaries of data to add/replace if present.\n    \"\"\"\n    nodes = list(new_attributes.keys())\n    old_attribs = [deepcopy(self.node(node)) for node in nodes]\n    new_attribs = [{**self.node(node), **new_attributes[node]} for node in nodes]\n\n    self.change_log = self.change_log.modify_bunch(\n        \"node\", nodes, old_attribs, nodes, new_attribs\n    )\n\n    nx.set_node_attributes(self.graph, dict(zip(nodes, new_attribs)))\n    logging.info(f\"Changed Node attributes for {len(nodes)} nodes\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_function_to_links","title":"<code>apply_function_to_links(function, location)</code>","text":"<p>Applies function to link attributes dictionary.</p> PARAMETER DESCRIPTION <code>function</code> <p>Function of link attributes dictionary returning a value that should be stored under <code>location</code>.</p> <p> TYPE: <code>Callable</code> </p> <code>location</code> <p>Where to save the results: string defining the key in the nodes attributes dictionary.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_function_to_links(self, function: Callable, location: str):\n    \"\"\"Applies function to link attributes dictionary.\n\n    Args:\n        function (Callable): Function of link attributes dictionary returning a value that should be stored under `location`.\n        location (str): Where to save the results: string defining the key in the nodes attributes dictionary.\n    \"\"\"\n    new_link_attribs = {}\n    for link_id, link_attribs in self.links():\n        try:\n            new_link_attribs[link_id] = {location: function(link_attribs)}\n        except KeyError:\n            # Not all nodes/edges are required to have all the same attributes stored. Fail silently and only apply\n            # to relevant nodes/edges\n            pass\n    number_of_links_not_affected = len(self.link_id_mapping) - len(new_link_attribs)\n    if number_of_links_not_affected != 0:\n        logging.info(\n            f\"{number_of_links_not_affected} out of {len(self.link_id_mapping)} links have not been \"\n            f\"affected by the function. Links affected: {list(new_link_attribs.keys())}\"\n        )\n    self.apply_attributes_to_links(new_link_attribs)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.apply_function_to_nodes","title":"<code>apply_function_to_nodes(function, location)</code>","text":"<p>Applies function to node attributes dictionary.</p> PARAMETER DESCRIPTION <code>function</code> <p>Function of node attributes dictionary returning a value that should be stored under <code>location</code>.</p> <p> TYPE: <code>Callable</code> </p> <code>location</code> <p>Where to save the results: string defining the key in the nodes attributes dictionary.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def apply_function_to_nodes(self, function: Callable, location: str):\n    \"\"\"Applies function to node attributes dictionary.\n\n    Args:\n        function (Callable): Function of node attributes dictionary returning a value that should be stored under `location`.\n        location (str): Where to save the results: string defining the key in the nodes attributes dictionary.\n    \"\"\"\n    new_node_attribs = {}\n    for node, node_attribs in self.nodes():\n        try:\n            new_node_attribs[node] = {location: function(node_attribs)}\n        except KeyError:\n            # Not all nodes/edges are required to have all the same attributes stored. Fail silently and only apply\n            # to relevant nodes/edges\n            pass\n    self.apply_attributes_to_nodes(new_node_attribs)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.calculate_route_to_crow_fly_ratio","title":"<code>calculate_route_to_crow_fly_ratio(route)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def calculate_route_to_crow_fly_ratio(self, route: schedule_elements.Route):\n    route_dist = self.route_distance(route.network_links)\n    crowfly_dist = route.crowfly_distance()\n    if crowfly_dist:\n        return route_dist / crowfly_dist\n    else:\n        return \"Division by zero\"\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.check_connectivity_for_mode","title":"<code>check_connectivity_for_mode(mode)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def check_connectivity_for_mode(self, mode):\n    logging.info(f\"Checking network connectivity for mode: {mode}\")\n    G_mode = self.modal_subgraph(mode)\n    con_desc = network_validation.describe_graph_connectivity(G_mode)\n    no_of_components = con_desc[\"number_of_connected_subgraphs\"]\n    logging.info(\n        f\"The graph for mode: {mode} has: \"\n        f\"{no_of_components} connected components, \"\n        f'{len(con_desc[\"problem_nodes\"][\"dead_ends\"])} sinks/dead_ends and '\n        f'{len(con_desc[\"problem_nodes\"][\"unreachable_node\"])} sources/unreachable nodes.'\n    )\n    if no_of_components &gt; 1:\n        logging.warning(\n            f\"The graph has more than one connected component for mode {mode}! \"\n            \"If this is not expected, consider using the `connect_components` method to connect the \"\n            \"components, or `retain_n_connected_subgraphs` with `n=1` to extract the largest component\"\n        )\n    return con_desc\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.connect_components","title":"<code>connect_components(modes=None, weight=1.0)</code>","text":"<p>Connect disconnected subgraphs in the Network graph.</p> <p>Use modes variable to consider a modal subgraph. For a strongly connected MATSim network use only a single (routable) mode at a time.</p> PARAMETER DESCRIPTION <code>modes</code> <p>Single mode or iterable of modes to use for computing strongly connected subgraphs. Defaults to None.</p> <p> TYPE: <code>Optional[Union[list, str, set]]</code> DEFAULT: <code>None</code> </p> <code>weight</code> <p>weight to apply to <code>freespeed</code> and <code>capacity</code> for scaling. Defaults to 1.0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>Optional[dict]</code> <p>Optional[dict]: None, or links and their details if they were added to the Network.</p> Source code in <code>src/genet/core.py</code> <pre><code>def connect_components(\n    self, modes: Optional[Union[list, str, set]] = None, weight: float = 1.0\n) -&gt; Optional[dict]:\n    \"\"\"Connect disconnected subgraphs in the Network graph.\n\n    Use modes variable to consider a modal subgraph.\n    For a strongly connected MATSim network use only a single (routable) mode at a time.\n\n    Args:\n        modes (Optional[Union[list, str, set]], optional): Single mode or iterable of modes to use for computing strongly connected subgraphs. Defaults to None.\n        weight (float, optional): weight to apply to `freespeed` and `capacity` for scaling. Defaults to 1.0.\n\n    Returns:\n        Optional[dict]: None, or links and their details if they were added to the Network.\n    \"\"\"\n    if modes is None:\n        g = self.graph\n    else:\n        g = self.modal_subgraph(modes)\n        if isinstance(modes, str):\n            modes = {modes}\n        else:\n            modes = set(modes)\n    components = network_validation.find_connected_subgraphs(g)\n\n    if len(components) == 1:\n        logging.warning(\n            \"This Graph has only one strongly connected component. No links will be added.\"\n        )\n    else:\n        gdfs = self.to_geodataframe()\n        gdf = gdfs[\"nodes\"].to_crs(\"epsg:4326\")\n        components_gdfs = [\n            gdf[gdf[\"id\"].isin(component_nodes)] for component_nodes, len in components\n        ]\n\n        closest_nodes = [\n            spatial.nearest_neighbor(components_gdfs[i], components_gdfs[j], return_dist=True)\n            for i, j in itertools.combinations(range(len(components_gdfs)), 2)\n        ]\n        closest_nodes_idx = [df[\"distance\"].idxmin() for df in closest_nodes]\n        closest_nodes = [\n            (idx, df.loc[idx, \"id\"], df.loc[idx, \"distance\"])\n            for idx, df in zip(closest_nodes_idx, closest_nodes)\n        ]\n\n        # TODO instead of deleting the last largest distance connection, check that it isnt too far off the others\n        # some graphs may not be arranged in line or they could overlap\n        closest_nodes = sorted(closest_nodes, key=lambda tup: tup[2])[:-1]\n\n        # add links\n        gdf_links = gdfs[\"links\"]\n        links_to_add = []\n        for u, v, dist in closest_nodes:\n            links_df = gdf_links.loc[\n                (gdf_links[\"from\"].isin({u, v}) | gdf_links[\"to\"].isin({u, v})),\n                gdf_links.columns.intersection({\"freespeed\", \"capacity\", \"modes\"}),\n            ]\n            links_data = links_df.drop(\"modes\", axis=1).mean()\n            links_data = links_data * weight\n            if modes is None:\n                links_data[\"modes\"] = set().union(*links_df[\"modes\"].tolist())\n            else:\n                links_data[\"modes\"] = modes\n            links_data[\"permlanes\"] = 1\n            links_data[\"length\"] = dist\n            links_data[\"from\"] = u\n            links_data[\"to\"] = v\n\n            links_to_add.append(links_data.to_dict())\n\n            links_data[\"from\"] = v\n            links_data[\"to\"] = u\n\n            links_to_add.append(links_data.to_dict())\n\n        if links_to_add:\n            links_to_add = dict(\n                zip(self.generate_indices_for_n_edges(len(links_to_add)), links_to_add)\n            )\n            self.add_links(links_to_add)\n            return links_to_add\n        else:\n            logging.warning(\"No links are being added\")\n    return None\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.edge","title":"<code>edge(u, v)</code>","text":"<p>Get edge attributes.</p> PARAMETER DESCRIPTION <code>u</code> <p>From node of <code>self.graph</code>.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>v</code> <p>To node of <code>self.graph</code>.</p> <p> TYPE: <code>Union[str, int]</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Attributes of the edge from u to  v.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def edge(self, u: Union[str, int], v: Union[str, int]) -&gt; dict:\n    \"\"\"Get edge attributes.\n\n    Args:\n        u (Union[str, int]): From node of `self.graph`.\n        v (Union[str, int]): To node of `self.graph`.\n\n    Returns:\n        dict: Attributes of the edge from u to  v.\n    \"\"\"\n    return dict(self.graph[u][v])\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.edge_tuple_from_link_id","title":"<code>edge_tuple_from_link_id(link)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def edge_tuple_from_link_id(self, link):\n    u, v = self.link_id_mapping[link][\"from\"], self.link_id_mapping[link][\"to\"]\n    multi_idx = self.link_id_mapping[link][\"multi_edge_idx\"]\n    return u, v, multi_idx\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.edges","title":"<code>edges()</code>","text":"YIELDS DESCRIPTION <code>tuple[Union[str, int], Union[str, int], Any]</code> <p>Iterator through each edge's from, to nodes and its attrib (three-tuple).</p> Source code in <code>src/genet/core.py</code> <pre><code>def edges(self) -&gt; Iterator[tuple[Union[str, int], Union[str, int], Any]]:\n    \"\"\"\n    Yields:\n        Iterator through each edge's from, to nodes and its attrib (three-tuple).\n    \"\"\"\n    for u, v in self.graph.edges():\n        yield u, v, self.edge(u, v)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.extract_links_on_edge_attributes","title":"<code>extract_links_on_edge_attributes(conditions, how=any, mixed_dtypes=True)</code>","text":"<p>Extracts graph link IDs based on values of attributes saved on the links.</p> <p>Fails silently, assumes not all links have all of the attributes.</p> <p>In the case where the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered. It is deemed successful by default. To disable this behaviour set <code>mixed_dtypes</code> to False.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: Graph link IDs where attribute values match <code>conditions</code>.</p> Source code in <code>src/genet/core.py</code> <pre><code>def extract_links_on_edge_attributes(\n    self, conditions: Union[list, dict], how: Callable = any, mixed_dtypes: bool = True\n) -&gt; list[str]:\n    \"\"\"Extracts graph link IDs based on values of attributes saved on the links.\n\n    Fails silently, assumes not all links have all of the attributes.\n\n    In the case where the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered.\n    It is deemed successful by default.\n    To disable this behaviour set `mixed_dtypes` to False.\n\n    Args:\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n\n    Returns:\n        list[str]: Graph link IDs where attribute values match `conditions`.\n    \"\"\"\n    return graph_operations.extract_on_attributes(\n        self.links(), conditions=conditions, how=how, mixed_dtypes=mixed_dtypes\n    )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.extract_nodes_on_node_attributes","title":"<code>extract_nodes_on_node_attributes(conditions, how=any, mixed_dtypes=True)</code>","text":"<p>Extracts graph node IDs based on values of attributes saved on the nodes.</p> <p>Fails silently, assumes not all nodes have all of the attributes.</p> <p>In the case where the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered. It is deemed successful by default. To disable this behaviour set <code>mixed_dtypes</code> to False.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: Graph node IDs where attribute values match <code>conditions</code>.</p> Source code in <code>src/genet/core.py</code> <pre><code>def extract_nodes_on_node_attributes(\n    self, conditions: Union[list, dict], how: Callable = any, mixed_dtypes: bool = True\n) -&gt; list[str]:\n    \"\"\"Extracts graph node IDs based on values of attributes saved on the nodes.\n\n    Fails silently, assumes not all nodes have all of the attributes.\n\n    In the case where the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered.\n    It is deemed successful by default.\n    To disable this behaviour set `mixed_dtypes` to False.\n\n    Args:\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n\n    Returns:\n        list[str]: Graph node IDs where attribute values match `conditions`.\n    \"\"\"\n    return graph_operations.extract_on_attributes(\n        self.nodes(), conditions=conditions, how=how, mixed_dtypes=mixed_dtypes\n    )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.find_shortest_path","title":"<code>find_shortest_path(from_node, to_node, modes=None, subgraph=None, return_nodes=False)</code>","text":"<p>Finds shortest path between from and to nodes in the graph.</p> <p>If modes specified, finds shortest path in the modal subgraph (using links which have given modes stored under 'modes' key in link attributes). If computing a large number of routes on the same modal subgraph, it is best to find the subgraph using the <code>modal_subgraph</code> method and pass it under subgraph to avoid re-computing the subgraph every time.</p> PARAMETER DESCRIPTION <code>from_node</code> <p>node id in the graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>to_node</code> <p>node id in the graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>modes</code> <p>String e.g. 'car' or list ['car', 'bike']. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, list, set]]</code> DEFAULT: <code>None</code> </p> <code>subgraph</code> <p>Preferably the result of <code>Network.modal_subgraph</code>. Defaults to None.</p> <p> TYPE: <code>Optional[MultiDiGraph]</code> DEFAULT: <code>None</code> </p> <code>return_nodes</code> <p>If True, returns list of node ids defining a route (reminder: there can be more than one link between two nodes, by default this method will return a list of link ids that results in shortest journey). Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[Union[str, int]]</code> <p>list[Union[str, int]]: List of link IDs defining a route.</p> Source code in <code>src/genet/core.py</code> <pre><code>def find_shortest_path(\n    self,\n    from_node: Union[str, int],\n    to_node: Union[str, int],\n    modes: Optional[Union[str, list, set]] = None,\n    subgraph: Optional[nx.MultiDiGraph] = None,\n    return_nodes: bool = False,\n) -&gt; list[Union[str, int]]:\n    \"\"\"Finds shortest path between from and to nodes in the graph.\n\n    If modes specified, finds shortest path in the modal subgraph (using links which have given modes stored under 'modes' key in link attributes).\n    If computing a large number of routes on the same modal subgraph, it is best to find the subgraph using the `modal_subgraph` method and pass it under subgraph to avoid re-computing the subgraph every time.\n\n    Args:\n        from_node (Union[str, int]):  node id in the graph.\n        to_node (Union[str, int]): node id in the graph.\n        modes (Optional[Union[str, list, set]], optional): String e.g. 'car' or list ['car', 'bike']. Defaults to None.\n        subgraph (Optional[nx.MultiDiGraph], optional): Preferably the result of `Network.modal_subgraph`. Defaults to None.\n        return_nodes (bool, optional):\n            If True, returns list of node ids defining a route\n            (reminder: there can be more than one link between two nodes, by default this method will return a list of link ids that results in shortest journey).\n            Defaults to False.\n\n    Returns:\n        list[Union[str, int]]: List of link IDs defining a route.\n    \"\"\"\n    if subgraph is not None:\n        g = subgraph\n    elif modes:\n        g = self.modal_subgraph(modes)\n    else:\n        g = self.graph\n    route = nx.shortest_path(g, source=from_node, target=to_node, weight=\"length\")\n\n    if return_nodes:\n        return route\n    else:\n        return [\n            graph_operations.find_shortest_path_link(dict(g[u][v]), modes=modes)\n            for u, v in zip(route[:-1], route[1:])\n        ]\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.generate_index_for_edge","title":"<code>generate_index_for_edge(avoid_keys=None, silent=False)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def generate_index_for_edge(\n    self, avoid_keys: Optional[Union[list, set]] = None, silent: bool = False\n) -&gt; str:\n    _id = list(self.generate_indices_for_n_edges(n=1, avoid_keys=avoid_keys))[0]\n    if not silent:\n        logging.info(f\"Generated link id {_id}.\")\n    return str(_id)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.generate_index_for_node","title":"<code>generate_index_for_node(avoid_keys=None, silent=False)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def generate_index_for_node(\n    self, avoid_keys: Optional[Union[list, set]] = None, silent: bool = False\n) -&gt; str:\n    existing_keys = set([i for i, attribs in self.nodes()])\n    if avoid_keys:\n        existing_keys = existing_keys | set(avoid_keys)\n    try:\n        id = max([int(i) for i in existing_keys]) + 1\n    except ValueError:\n        id = len(existing_keys) + 1\n    if (id in existing_keys) or (str(id) in existing_keys):\n        id = uuid.uuid4()\n    if not silent:\n        logging.info(f\"Generated node id {id}.\")\n    return str(id)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.generate_indices_for_n_edges","title":"<code>generate_indices_for_n_edges(n, avoid_keys=None)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def generate_indices_for_n_edges(\n    self, n: int, avoid_keys: Optional[Union[list, set]] = None\n) -&gt; set:\n    existing_keys = set(self.link_id_mapping.keys())\n    if avoid_keys:\n        existing_keys = existing_keys | set(avoid_keys)\n    id_set = set(map(str, range(n))) - existing_keys\n    _max = 0\n    loop_no = 0\n\n    while len(id_set) != n:\n        if loop_no &gt; 0:\n            if not _max:\n                _max = n\n            else:\n                _max += n\n        missing_ns = n - len(id_set)\n        id_set |= set(map(str, range(_max + 1, _max + missing_ns + 1))) - existing_keys\n        loop_no += 1\n\n    logging.info(f\"Generated {len(id_set)} link ids.\")\n    return id_set\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.generate_indices_for_n_nodes","title":"<code>generate_indices_for_n_nodes(n, avoid_keys=None)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def generate_indices_for_n_nodes(\n    self, n: int, avoid_keys: Optional[Union[list, set]] = None\n) -&gt; set:\n    existing_keys = set([i for i, attribs in self.nodes()])\n    if avoid_keys:\n        existing_keys = existing_keys | set(avoid_keys)\n    try:\n        id_set = set([str(max([int(i) for i in existing_keys]) + j) for j in range(1, n + 1)])\n    except ValueError:\n        id_set = set([str(len(existing_keys) + j) for j in range(1, n + 1)])\n    if id_set &amp; existing_keys:\n        id_set = id_set - existing_keys\n        id_set = id_set | set([str(uuid.uuid4()) for i in range(n - len(id_set))])\n    logging.info(f\"Generated {len(id_set)} node ids.\")\n    return id_set\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.generate_standard_outputs","title":"<code>generate_standard_outputs(output_dir, gtfs_day='19700101', filetype='parquet')</code>","text":"<p>Generates geojsons that can be used for generating standard kepler visualisations.</p> <p>These can also be used for validating network for example inspecting link capacity, freespeed, number of lanes, the shape of modal subgraphs.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>path to folder where to save resulting geojsons.</p> <p> TYPE: <code>str</code> </p> <code>gtfs_day</code> <p>Day in format YYYYMMDD for the network's schedule for consistency in visualisations, Defaults to \"19700101\" (1970-01-01).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> <code>filetype</code> <p>The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported. Defaults to parquet format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parquet'</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def generate_standard_outputs(\n    self, output_dir: str, gtfs_day: str = \"19700101\", filetype: str = \"parquet\"\n):\n    \"\"\"Generates geojsons that can be used for generating standard kepler visualisations.\n\n    These can also be used for validating network for example inspecting link capacity, freespeed, number of lanes, the shape of modal subgraphs.\n\n    Args:\n        output_dir (str): path to folder where to save resulting geojsons.\n        gtfs_day (str, optional):\n            Day in format YYYYMMDD for the network's schedule for consistency in visualisations,\n            Defaults to \"19700101\" (1970-01-01).\n        filetype (str, optional):\n            The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported.\n            Defaults to parquet format.\n    \"\"\"\n    spatial_output.generate_standard_outputs(\n        self, output_dir, gtfs_day=gtfs_day, filetype=filetype\n    )\n    logging.info(\"Finished generating standard outputs. Zipping folder.\")\n    persistence.zip_folder(output_dir)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.generate_validation_report","title":"<code>generate_validation_report(modes_for_strong_connectivity=None, link_metre_length_threshold=1000)</code>","text":"<p>Generates validation report.</p> <p>Generates a dictionary with keys: 'graph', 'schedule' and 'routing' describing validity of the Network's underlying graph, the schedule services and then the intersection of the two which is the routing of schedule services onto the graph.</p> PARAMETER DESCRIPTION <code>modes_for_strong_connectivity</code> <p>List of modes in the network that need to be checked for strong connectivity. Defaults to None (['car', 'walk', 'bike']).</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>link_metre_length_threshold</code> <p>In meters defaults to 1000, i.e. 1km. Defaults to 1000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Validation report</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def generate_validation_report(\n    self,\n    modes_for_strong_connectivity: Optional[list] = None,\n    link_metre_length_threshold: int = 1000,\n) -&gt; dict:\n    \"\"\"Generates validation report.\n\n    Generates a dictionary with keys: 'graph', 'schedule' and 'routing' describing validity of the Network's\n    underlying graph, the schedule services and then the intersection of the two which is the routing of schedule\n    services onto the graph.\n\n    Args:\n        modes_for_strong_connectivity (Optional[list], optional):\n            List of modes in the network that need to be checked for strong connectivity.\n            Defaults to None (['car', 'walk', 'bike']).\n        link_metre_length_threshold (int, optional): In meters defaults to 1000, i.e. 1km. Defaults to 1000.\n\n    Returns:\n        dict: Validation report\n    \"\"\"\n    logging.info(\"Checking validity of the Network\")\n    logging.info(\"Checking validity of the Network graph\")\n    report = {}\n    is_valid_network = True\n\n    # describe network connectivity\n    if modes_for_strong_connectivity is None:\n        modes_for_strong_connectivity = [\"car\", \"walk\", \"bike\"]\n        logging.info(\n            f\"Defaulting to checking graph connectivity for modes: {modes_for_strong_connectivity}. \"\n            \"You can change this by passing a `modes_for_strong_connectivity` param\"\n        )\n    graph_connectivity = {}\n    for mode in modes_for_strong_connectivity:\n        graph_connectivity[mode] = self.check_connectivity_for_mode(mode)\n        if graph_connectivity[mode][\"number_of_connected_subgraphs\"] not in {0, 1}:\n            is_valid_network = False\n    report[\"graph\"] = {\"graph_connectivity\": graph_connectivity}\n\n    isolated_nodes = self.isolated_nodes()\n    report[\"graph\"][\"isolated_nodes\"] = {\n        \"number_of_nodes\": len(isolated_nodes),\n        \"nodes\": isolated_nodes,\n    }\n    if self.has_isolated_nodes():\n        logging.warning(\n            \"This Network has isolated nodes! Consider cleaning it up with `remove_isolated_nodes`\"\n        )\n        is_valid_network = False\n\n    # attribute checks\n    conditions_toolbox = network_validation.ConditionsToolbox()\n    report[\"graph\"][\"link_attributes\"] = {\n        f\"{k}_attributes\": {} for k in conditions_toolbox.condition_names()\n    }\n\n    # checks on length attribute specifically\n    def links_over_threshold_length(value):\n        return value &gt;= link_metre_length_threshold\n\n    report[\"graph\"][\"link_attributes\"][\"links_over_1000_length\"] = (\n        self.report_on_link_attribute_condition(\"length\", links_over_threshold_length)\n    )\n\n    # more general attribute value checks\n    non_testable = [\"id\", \"from\", \"to\", \"s2_to\", \"s2_from\", \"geometry\"]\n    link_attributes = [\n        graph_operations.parse_leaf(leaf)\n        for leaf in graph_operations.get_attribute_schema(self.links()).leaves\n    ]\n    link_attributes = [attrib for attrib in link_attributes if attrib not in non_testable]\n    for attrib in link_attributes:\n        logging.info(f\"Checking link values for `{attrib}`\")\n        for condition_name in conditions_toolbox.condition_names():\n            links_satifying_condition = self.report_on_link_attribute_condition(\n                attrib, conditions_toolbox.get_condition_evaluator(condition_name)\n            )\n            if links_satifying_condition[\"number_of\"]:\n                logging.warning(\n                    f'{links_satifying_condition[\"number_of\"]} of links have '\n                    f\"{condition_name} values for `{attrib}`\"\n                )\n                if isinstance(attrib, dict):\n                    attrib = dict_support.dict_to_string(attrib)\n                report[\"graph\"][\"link_attributes\"][f\"{condition_name}_attributes\"][\n                    attrib\n                ] = links_satifying_condition\n\n    if self.schedule:\n        report[\"schedule\"] = self.schedule.generate_validation_report()\n\n        route_to_crow_fly_ratio = {}\n        for service_id, route_ids in self.schedule.service_to_route_map().items():\n            route_to_crow_fly_ratio[service_id] = {}\n            for route_id in route_ids:\n                route_to_crow_fly_ratio[service_id][route_id] = (\n                    self.calculate_route_to_crow_fly_ratio(self.schedule.route(route_id))\n                )\n\n        report[\"routing\"] = {\n            \"services_have_routes_in_the_graph\": self.has_schedule_with_valid_network_routes(),\n            \"service_routes_with_invalid_network_route\": self.invalid_network_routes(),\n            \"route_to_crow_fly_ratio\": route_to_crow_fly_ratio,\n        }\n        if not (report[\"routing\"][\"services_have_routes_in_the_graph\"]):\n            is_valid_network = False\n\n        report[\"intermodal_access_egress\"] = {\n            \"has_valid_intermodal_connections\": self.has_valid_intermodal_access_egress_connections(),\n            \"invalid_intermodal_connections\": self.invalid_intermodal_access_egress_connections(),\n        }\n        if not (\n            report[\"schedule\"][\"schedule_level\"][\"is_valid_schedule\"]\n            and report[\"intermodal_access_egress\"][\"has_valid_intermodal_connections\"]\n        ):\n            is_valid_network = False\n    report[\"is_valid_network\"] = is_valid_network\n    return report\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.get_link_slope_dictionary","title":"<code>get_link_slope_dictionary(elevation_dict)</code>","text":"<p>Takes a dictionary of z-value for each network node (as created by get_node_elevation_dictionary() function, calculates link slope and returns a dictionary of link IDs and their slopes.</p> <p>Can then use self.apply_attributes_to_links() function to add slope as a link attribute to the network.</p> PARAMETER DESCRIPTION <code>elevation_dict</code> <p>dict in format <code>{node_id : {'z': z}}</code></p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>dict in format <code>{link_id : {'slope': slope}}</code>, where slope is a float.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def get_link_slope_dictionary(self, elevation_dict: dict) -&gt; dict:\n    \"\"\"Takes a dictionary of z-value for each network node (as created by get_node_elevation_dictionary() function,\n    calculates link slope and returns a dictionary of link IDs and their slopes.\n\n    Can then use self.apply_attributes_to_links() function to add slope as a link attribute to the network.\n\n    Args:\n        elevation_dict (dict): dict in format `{node_id : {'z': z}}`\n\n    Returns:\n        dict: dict in format `{link_id : {'slope': slope}}`, where slope is a float.\n    \"\"\"\n    slope_dict = {}\n\n    for link in self.links():\n        link_id = link[0]\n        node_1 = self.link(link_id)[\"from\"]\n        node_2 = self.link(link_id)[\"to\"]\n        z_1 = elevation_dict[node_1][\"z\"]\n        z_2 = elevation_dict[node_2][\"z\"]\n\n        # TO-DO: calculate crow-fly distance between the 2 nodes instead of using routed distance\n        length = self.link(link_id)[\"length\"]\n\n        if length == 0:\n            link_slope = 0\n        else:\n            # calculate slope by dividing the difference between elevations of two nodes by distance between them\n            link_slope = (z_2 - z_1) / length\n\n        slope_dict[link_id] = {\"slope\": link_slope}\n\n    return slope_dict\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.get_node_elevation_dictionary","title":"<code>get_node_elevation_dictionary(elevation_tif_file_path, null_value, run_validation=False)</code>","text":"<p>Takes an elevation raster file in .tif format, and creates a dictionary with z-value for each network node.</p> <p>Can then use self.apply_attributes_to_nodes() function to add elevation as a node attribute to the network.</p> PARAMETER DESCRIPTION <code>elevation_tif_file_path</code> <p>path to the elevation raster file in .tif format.</p> <p> TYPE: <code>str</code> </p> <code>null_value</code> <p>value that represents null in the elevation raster file</p> <p> TYPE: <code>float</code> </p> <code>run_validation</code> <p>If True, create a validation report and send to logging INFO level. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Elevation dictionary in format <code>{node_id : {'z': z}}</code>.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def get_node_elevation_dictionary(\n    self, elevation_tif_file_path: str, null_value: float, run_validation: bool = False\n) -&gt; dict:\n    \"\"\"Takes an elevation raster file in .tif format, and creates a dictionary with z-value for each network node.\n\n    Can then use self.apply_attributes_to_nodes() function to add elevation as a node attribute to the network.\n\n    Args:\n        elevation_tif_file_path (str): path to the elevation raster file in .tif format.\n        null_value (float): value that represents null in the elevation raster file\n        run_validation (bool, optional): If True, create a validation report and send to logging INFO level. Defaults to False.\n\n    Returns:\n        dict: Elevation dictionary in format `{node_id : {'z': z}}`.\n    \"\"\"\n    img = elevation.get_elevation_image(elevation_tif_file_path)\n    elevation_dict = {}\n\n    for node_id, node_attribs in self.nodes():\n        z = elevation.get_elevation_data(img, lat=node_attribs[\"lat\"], lon=node_attribs[\"lon\"])\n\n        # zero values handling - may wish to add infilling based on nearby values later\n        if z == null_value:\n            z = 0\n        elevation_dict[node_id] = {\"z\": z}\n\n    if run_validation is True:\n        report = elevation.validation_report_for_node_elevation(elevation_dict)\n        logging.info(report[\"summary\"])\n\n    return elevation_dict\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_attrib","title":"<code>has_attrib(attrib_name)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_attrib(self, attrib_name):\n    return attrib_name in self.__dict__\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_edge","title":"<code>has_edge(u, v)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_edge(self, u, v):\n    return self.graph.has_edge(u, v)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_intermodal_access_egress_connections","title":"<code>has_intermodal_access_egress_connections()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_intermodal_access_egress_connections(self):\n    if self.schedule:\n        return self.schedule.has_intermodal_access_egress_connections()\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_isolated_nodes","title":"<code>has_isolated_nodes()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_isolated_nodes(self) -&gt; bool:\n    return bool(self.isolated_nodes())\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_link","title":"<code>has_link(link_id)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_link(self, link_id: str):\n    if link_id in self.link_id_mapping:\n        link_edge = self.link_id_mapping[link_id]\n        u, v, multi_idx = link_edge[\"from\"], link_edge[\"to\"], link_edge[\"multi_edge_idx\"]\n        if self.graph.has_edge(u, v, multi_idx):\n            return True\n        else:\n            logging.info(\n                f\"Link with id {link_id} is declared in the network with from_node: {u}, to_node: {v} \"\n                f\"and multi_index: {multi_idx} but this edge is not in the graph.\"\n            )\n            return False\n    else:\n        logging.info(f\"Link with id {link_id} is not in the network.\")\n        return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_links","title":"<code>has_links(link_ids, conditions=None, mixed_dtypes=True)</code>","text":"<p>Whether the Network contains the links given in the link_ids list.</p> <p>If conditions is specified, checks whether the Network contains the links specified and those links match the attributes in the conditions dict.</p> PARAMETER DESCRIPTION <code>link_ids</code> <p>List of link ids e.g. ['1', '102'].</p> <p> TYPE: <code>list[Union[str, int]]</code> </p> <code>conditions</code> <p>Confer <code>graph_operations.Filter</code> conditions. Defaults to None.</p> <p> TYPE: <code>Optional[Union[list, dict]]</code> DEFAULT: <code>None</code> </p> <code>mixed_dtypes</code> <p>Confer <code>graph_operations.Filter</code> mixed_dtypes. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>If True, network contains links given in link_ids list.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def has_links(\n    self,\n    link_ids: list[Union[str, int]],\n    conditions: Optional[Union[list, dict]] = None,\n    mixed_dtypes: bool = True,\n) -&gt; bool:\n    \"\"\"Whether the Network contains the links given in the link_ids list.\n\n    If conditions is specified, checks whether the Network contains the links specified and those links match the attributes in the conditions dict.\n\n    Args:\n        link_ids (list[Union[str, int]]): List of link ids e.g. ['1', '102'].\n        conditions (Optional[Union[list, dict]], optional): Confer `graph_operations.Filter` conditions. Defaults to None.\n        mixed_dtypes (bool, optional): Confer `graph_operations.Filter` mixed_dtypes. Defaults to True.\n\n    Returns:\n        bool: If True, network contains links given in link_ids list.\n    \"\"\"\n    has_all_links = all([self.has_link(link_id) for link_id in link_ids])\n    if not conditions:\n        return has_all_links\n    elif has_all_links:\n        filter = graph_operations.Filter(conditions, how=any, mixed_dtypes=mixed_dtypes)\n        links_satisfy = [\n            link_id for link_id in link_ids if filter.satisfies_conditions(self.link(link_id))\n        ]\n        return set(links_satisfy) == set(link_ids)\n    else:\n        return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_node","title":"<code>has_node(node_id)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_node(self, node_id):\n    return self.graph.has_node(node_id)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_nodes","title":"<code>has_nodes(node_id)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_nodes(self, node_id: list):\n    return all([self.has_node(node_id) for node_id in node_id])\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_schedule_with_valid_network_routes","title":"<code>has_schedule_with_valid_network_routes()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_schedule_with_valid_network_routes(self):\n    routes = [route for route in self.schedule_routes()]\n    if all([route.has_network_links() for route in routes]):\n        return all([self.is_valid_network_route(route) for route in routes])\n    return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_valid_intermodal_access_egress_connections","title":"<code>has_valid_intermodal_access_egress_connections()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_valid_intermodal_access_egress_connections(self):\n    if self.has_intermodal_access_egress_connections():\n        return any(\n            [\n                not (\n                    bool(content[\"stops_with_links_not_in_network\"])\n                    or bool(content[\"stops_with_links_with_wrong_modes\"])\n                )\n                for mode, content in self.invalid_intermodal_access_egress_connections().items()\n            ]\n        )\n    else:\n        logging.warning(\"Network does not have intermodal access/egress connections\")\n        return True\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.has_valid_link_chain","title":"<code>has_valid_link_chain(link_ids)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def has_valid_link_chain(self, link_ids: list[str]) -&gt; bool:\n    for prev_link_id, next_link_id in zip(link_ids[:-1], link_ids[1:]):\n        prev_link_id_to_node = self.link_id_mapping[prev_link_id][\"to\"]\n        next_link_id_from_node = self.link_id_mapping[next_link_id][\"from\"]\n        if prev_link_id_to_node != next_link_id_from_node:\n            logging.info(f\"Links {prev_link_id} and {next_link_id} are not connected\")\n            return False\n    if not link_ids:\n        logging.info(\"Links chain is empty\")\n        return False\n    return True\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.index_graph_edges","title":"<code>index_graph_edges()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def index_graph_edges(self):\n    logging.warning(\"This method clears the existing link_id indexing\")\n    self.link_id_mapping = {}\n    i = 0\n    for u, v, multi_edge_idx in self.graph.edges:\n        self.link_id_mapping[str(i)] = {\"from\": u, \"to\": v, \"multi_edge_idx\": multi_edge_idx}\n        i += 1\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.info","title":"<code>info()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def info(self):\n    return f\"Graph info: {str(self.graph)} \\nSchedule info: {self.schedule.info()}\"\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.initiate_crs_transformer","title":"<code>initiate_crs_transformer(epsg)</code>","text":"<p>Set the networks projection transformer to <code>epsg</code>.</p> PARAMETER DESCRIPTION <code>epsg</code> <p>Projection, e.g., 'epsg:1234'.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def initiate_crs_transformer(self, epsg: str):\n    \"\"\"Set the networks projection transformer to `epsg`.\n\n    Args:\n        epsg (str): Projection, e.g., 'epsg:1234'.\n    \"\"\"\n    self.epsg = epsg\n    if epsg != \"epsg:4326\":\n        self.transformer = Transformer.from_crs(epsg, \"epsg:4326\", always_xy=True)\n    else:\n        self.transformer = None\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.intermodal_access_egress_connections","title":"<code>intermodal_access_egress_connections()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def intermodal_access_egress_connections(self):\n    if self.has_intermodal_access_egress_connections():\n        return self.schedule.intermodal_access_egress_connections()\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.invalid_intermodal_access_egress_connections","title":"<code>invalid_intermodal_access_egress_connections()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def invalid_intermodal_access_egress_connections(self):\n    report = {}\n    if self.has_intermodal_access_egress_connections():\n        df = self.intermodal_access_egress_connections()\n        attribute_keys = self.schedule.intermodal_access_egress_attribute_keys()\n        cols_to_mode_map = {\n            f\"attributes::{key}\": key.replace(\"accessLinkId_\", \"\") for key in attribute_keys\n        }\n        for col, mode in cols_to_mode_map.items():\n            df.loc[:, \"link_in_network\"] = df[col].apply(lambda x: self.has_link(x))\n            df.loc[~df[\"link_in_network\"], \"mode_allowed_on_link\"] = False\n            df.loc[df[\"link_in_network\"], \"mode__allowed_on_link\"] = df.loc[\n                df[\"link_in_network\"], col\n            ].apply(lambda x: mode in self.link(x)[\"modes\"])\n            report[mode] = {\n                \"stops_with_links_not_in_network\": set(df[~df[\"link_in_network\"]].index),\n                \"stops_with_links_with_wrong_modes\": set(\n                    df[~df[\"mode__allowed_on_link\"].astype(bool)].index\n                )\n                - set(df[~df[\"link_in_network\"]].index),\n            }\n    return report\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.invalid_network_routes","title":"<code>invalid_network_routes()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def invalid_network_routes(self):\n    return [\n        route.id\n        for route in self.schedule.routes()\n        if not route.has_network_links() or not self.is_valid_network_route(route)\n    ]\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.is_simplified","title":"<code>is_simplified()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def is_simplified(self):\n    if \"simplified\" in self.attributes:\n        # range of values for backwards compatibility\n        return self.attributes[\"simplified\"] in {\"true\", \"True\", True}\n    return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.is_strongly_connected","title":"<code>is_strongly_connected(modes=None)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def is_strongly_connected(self, modes: Optional[Union[list, str, set]] = None):\n    if modes is None:\n        g = self.graph\n    else:\n        g = self.modal_subgraph(modes)\n\n    components = network_validation.find_connected_subgraphs(g)\n\n    if len(components) == 1:\n        return True\n    elif len(components) == 0:\n        logging.warning(\n            f\"The graph for modes: {modes} does not have any connected components.\"\n            \" This method returns True because if the graph is empty for this mode there is no reason to fail\"\n            \" this check.\"\n        )\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.is_valid_network_route","title":"<code>is_valid_network_route(route)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def is_valid_network_route(self, route: schedule_elements.Route):\n    if self.has_links(route.network_links):\n        valid_link_chain = self.has_valid_link_chain(route.network_links)\n        links_have_correct_modes = self.has_links(\n            route.network_links, {\"modes\": route.mode}, mixed_dtypes=True\n        )\n        if not links_have_correct_modes:\n            logging.info(\n                f\"Some link ids in Route: {route.id} don't accept the route's mode: {route.mode}\"\n            )\n        return valid_link_chain and links_have_correct_modes\n    logging.info(f\"Not all link ids in Route: {route.id} are in the graph.\")\n    return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.isolated_nodes","title":"<code>isolated_nodes()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def isolated_nodes(self) -&gt; list:\n    return list(nx.isolates(self.graph))\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.link","title":"<code>link(link_id)</code>","text":"<p>Get Link attributes.</p> PARAMETER DESCRIPTION <code>link_id</code> <p>Link ID.</p> <p> TYPE: <code>Union[str, int]</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Link attributes.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def link(self, link_id: Union[str, int]) -&gt; dict:\n    \"\"\"Get Link attributes.\n\n    Args:\n        link_id (Union[str, int]): Link ID.\n\n    Returns:\n        dict: Link attributes.\n    \"\"\"\n    u, v, multi_idx = self.edge_tuple_from_link_id(link_id)\n    return dict(self.graph[u][v][multi_idx])\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.link_attribute_data_under_key","title":"<code>link_attribute_data_under_key(key)</code>","text":"<p>Generates a pandas.Series object indexed by link ids, with data stored on the nodes under <code>key</code>.</p> PARAMETER DESCRIPTION <code>key</code> <p>Either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.</p> <p> TYPE: <code>Union[str, dict]</code> </p> RETURNS DESCRIPTION <code>Series</code> <p>pd.Series: Link ID attribute data as a pandas Series.</p> Source code in <code>src/genet/core.py</code> <pre><code>def link_attribute_data_under_key(self, key: Union[str, dict]) -&gt; pd.Series:\n    \"\"\"Generates a pandas.Series object indexed by link ids, with data stored on the nodes under `key`.\n\n    Args:\n        key (Union[str, dict]):\n            Either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.\n\n    Returns:\n        pd.Series: Link ID attribute data as a pandas Series.\n    \"\"\"\n    return pd.Series(graph_operations.get_attribute_data_under_key(self.links(), key))\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.link_attribute_data_under_keys","title":"<code>link_attribute_data_under_keys(keys, index_name=None)</code>","text":"<p>Generates a pandas.DataFrame object indexed by link ids, with columns containing data stored on the links under each of <code>keys</code>.</p> PARAMETER DESCRIPTION <code>keys</code> <p>An iterable of either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.</p> <p> TYPE: <code>Union[list, set]</code> </p> <code>index_name</code> <p>If given, is used to set the dataframe index name. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Link ID attributes.</p> Source code in <code>src/genet/core.py</code> <pre><code>def link_attribute_data_under_keys(\n    self, keys: Union[list, set], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"Generates a pandas.DataFrame object indexed by link ids, with columns containing data stored on the links under each of `keys`.\n\n    Args:\n        keys (Union[list, set]): An iterable of either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.\n        index_name (Optional[str], optional): If given, is used to set the dataframe index name. Defaults to None.\n\n    Returns:\n        pd.DataFrame: Link ID attributes.\n    \"\"\"\n    return graph_operations.build_attribute_dataframe(\n        self.links(), keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.link_attribute_summary","title":"<code>link_attribute_summary(data=False)</code>","text":"<p>Parses through data stored on links and prints a summary tree of the data stored on the links.</p> PARAMETER DESCRIPTION <code>data</code> <p>If True, shows also up to 5 unique values stored under such keys. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def link_attribute_summary(self, data: bool = False):\n    \"\"\"Parses through data stored on links and prints a summary tree of the data stored on the links.\n\n    Args:\n        data (bool, optional): If True, shows also up to 5 unique values stored under such keys. Defaults to False.\n    \"\"\"\n    root = graph_operations.get_attribute_schema(self.links(), data=data)\n    graph_operations.render_tree(root, data)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.link_id_exists","title":"<code>link_id_exists(link_id)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def link_id_exists(self, link_id: Union[str, int]) -&gt; bool:\n    if link_id in self.link_id_mapping:\n        logging.warning(f\"{link_id} already exists.\")\n        return True\n    return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.link_length","title":"<code>link_length(from_node, to_node, geometry=None)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def link_length(self, from_node, to_node, geometry: LineString = None):\n    logging.warning(\n        \"Length for the link was not provided. An attempt will be made to calculate it.\"\n    )\n    if geometry is not None:\n        # TODO add length calculation based on complex geometry\n        logging.warning(\n            \"Link has a geometry, but its length will be calculated using straight line distance \"\n            \"between from and to nodes.\"\n        )\n    if (self.has_node(from_node) and self.has_node(to_node)) and (\n        (\"s2_id\" in self.node(from_node)) and (\"s2_id\" in self.node(to_node))\n    ):\n        # default to straight line distance\n        u_s2_id = self.node(from_node)[\"s2_id\"]\n        v_s2_id = self.node(to_node)[\"s2_id\"]\n        return round(spatial.distance_between_s2cellids(u_s2_id, v_s2_id))\n    else:\n        logging.warning(\n            \"Spatial information is not contained in the nodes. Length calculation failed.\"\n        )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.links","title":"<code>links()</code>","text":"YIELDS DESCRIPTION <code>tuple[Union[str, int], Any]</code> <p>Iterator through each link id its attrib (two-tuple).</p> Source code in <code>src/genet/core.py</code> <pre><code>def links(self) -&gt; Iterator[tuple[Union[str, int], Any]]:\n    \"\"\"\n    Yields:\n        Iterator through each link id its attrib (two-tuple).\n    \"\"\"\n    for link_id in self.link_id_mapping.keys():\n        yield link_id, self.link(link_id)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.links_on_modal_condition","title":"<code>links_on_modal_condition(modes)</code>","text":"<p>Finds link IDs with modes or singular mode given in <code>modes</code>.</p> PARAMETER DESCRIPTION <code>modes</code> <p>string mode e.g. 'car' or a list of such modes e.g. ['car', 'walk'].</p> <p> TYPE: <code>Union[str, list]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: list of link IDs.</p> Source code in <code>src/genet/core.py</code> <pre><code>def links_on_modal_condition(self, modes: Union[str, list]) -&gt; list[str]:\n    \"\"\"Finds link IDs with modes or singular mode given in `modes`.\n\n    Args:\n        modes (Union[str, list]): string mode e.g. 'car' or a list of such modes e.g. ['car', 'walk'].\n\n    Returns:\n        list[str]: list of link IDs.\n    \"\"\"\n    return self.extract_links_on_edge_attributes(conditions={\"modes\": modes}, mixed_dtypes=True)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.links_on_spatial_condition","title":"<code>links_on_spatial_condition(region_input, how='intersect')</code>","text":"<p>Returns link IDs which intersect <code>region_input</code>.</p> PARAMETER DESCRIPTION <code>region_input</code> <ul> <li>path to a geojson file, can have multiple features.</li> <li>string with comma separated hex tokens of Google's S2 geometry. A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/. E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.</li> <li>shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.</li> </ul> <p> TYPE: <code>Union[str, BaseGeometry]</code> </p> <code>how</code> <p>Defaults to \"intersect\". - 'intersect' will return IDs of the Services whose at least one Stop intersects the <code>region_input</code>. - 'within' will return IDs of the Services whose all of the Stops are contained within the <code>region_input</code>.</p> <p> TYPE: <code>Literal[intersect, within]</code> DEFAULT: <code>'intersect'</code> </p> <p>Returns:     list[str]: Link IDs.</p> Source code in <code>src/genet/core.py</code> <pre><code>def links_on_spatial_condition(\n    self,\n    region_input: Union[str, BaseGeometry],\n    how: Literal[\"intersect\", \"within\"] = \"intersect\",\n) -&gt; list[str]:\n    \"\"\"Returns link IDs which intersect `region_input`.\n\n    Args:\n        region_input (Union[str, BaseGeometry]):\n            - path to a geojson file, can have multiple features.\n            - string with comma separated hex tokens of Google's S2 geometry.\n            A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/.\n            E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.\n            - shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.\n        how (Literal[intersect, within], optional):\n            Defaults to \"intersect\".\n            - 'intersect' will return IDs of the Services whose at least one Stop intersects the `region_input`.\n            - 'within' will return IDs of the Services whose all of the Stops are contained within the `region_input`.\n    Returns:\n        list[str]: Link IDs.\n    \"\"\"\n    gdf = self.to_geodataframe()[\"links\"].to_crs(\"epsg:4326\")\n    if not isinstance(region_input, str):\n        # assumed to be a shapely.geometry input\n        return self._find_ids_on_shapely_geometry(gdf, how, region_input)\n    elif persistence.is_geojson(region_input):\n        return self._find_ids_on_geojson(gdf, how, region_input)\n    else:\n        # is assumed to be hex\n        return self._find_link_ids_on_s2_geometry(gdf, how, region_input)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.modal_subgraph","title":"<code>modal_subgraph(modes)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def modal_subgraph(self, modes: Union[str, set, list]) -&gt; nx.MultiDiGraph:\n    return self.subgraph_on_link_conditions(conditions={\"modes\": modes}, mixed_dtypes=True)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.modes","title":"<code>modes()</code>","text":"<p>Scans network for 'modes' attribute and returns list of all modes present in the network.</p> RETURNS DESCRIPTION <code>set</code> <p>Modes present in the network.</p> <p> TYPE: <code>set</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def modes(self) -&gt; set:\n    \"\"\"Scans network for 'modes' attribute and returns list of all modes present in the network.\n\n    Returns:\n        set: Modes present in the network.\n    \"\"\"\n    modes = set()\n    for link, link_attribs in self.links():\n        try:\n            modes |= set(link_attribs[\"modes\"])\n        except KeyError:\n            pass\n    return modes\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.node","title":"<code>node(node_id)</code>","text":"RETURNS DESCRIPTION <code>dict</code> <p>Attributes of the 'node_id'</p> Source code in <code>src/genet/core.py</code> <pre><code>def node(self, node_id: Union[str, int]) -&gt; dict:\n    \"\"\"\n    Returns:\n        Attributes of the 'node_id'\n    \"\"\"\n    return self.graph.nodes[node_id]\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.node_attribute_data_under_key","title":"<code>node_attribute_data_under_key(key)</code>","text":"<p>Generates a pandas.Series object indexed by node ids, with data stored on the nodes under <code>key</code>.</p> PARAMETER DESCRIPTION <code>key</code> <p>Either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.</p> <p> TYPE: <code>Union[str, dict]</code> </p> RETURNS DESCRIPTION <code>Series</code> <p>pd.Series: Node attribute data as a pandas Series.</p> Source code in <code>src/genet/core.py</code> <pre><code>def node_attribute_data_under_key(self, key: Union[str, dict]) -&gt; pd.Series:\n    \"\"\"Generates a pandas.Series object indexed by node ids, with data stored on the nodes under `key`.\n\n    Args:\n        key (Union[str, dict]):\n            Either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.\n\n    Returns:\n        pd.Series: Node attribute data as a pandas Series.\n    \"\"\"\n    data = graph_operations.get_attribute_data_under_key(self.nodes(), key)\n    return pd.Series(data, dtype=pd_helpers.get_pandas_dtype(data))\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.node_attribute_data_under_keys","title":"<code>node_attribute_data_under_keys(keys, index_name=None)</code>","text":"<p>Generates a pandas.DataFrame object indexed by node ids, with columns containing data stored on the nodes under each of <code>keys</code>.</p> PARAMETER DESCRIPTION <code>keys</code> <p>An iterable of either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.</p> <p> TYPE: <code>Union[list, set]</code> </p> <code>index_name</code> <p>If given, is used to set the dataframe index name. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Node attributes.</p> Source code in <code>src/genet/core.py</code> <pre><code>def node_attribute_data_under_keys(\n    self, keys: Union[list, set], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"Generates a pandas.DataFrame object indexed by node ids, with columns containing data stored on the nodes under each of `keys`.\n\n    Args:\n        keys (Union[list, set]): An iterable of either a string e.g. 'x', or if accessing nested information, a dictionary e.g. {'attributes': {'osm:way:name': 'text'}}.\n        index_name (Optional[str], optional): If given, is used to set the dataframe index name. Defaults to None.\n\n    Returns:\n        pd.DataFrame: Node attributes.\n    \"\"\"\n    return graph_operations.build_attribute_dataframe(\n        self.nodes(), keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.node_attribute_summary","title":"<code>node_attribute_summary(data=False)</code>","text":"<p>Parses through data stored on nodes and gives a summary tree of the data stored on the nodes.</p> PARAMETER DESCRIPTION <code>data</code> <p>If True, shows also up to 5 unique values stored under such keys. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def node_attribute_summary(self, data: bool = False):\n    \"\"\"Parses through data stored on nodes and gives a summary tree of the data stored on the nodes.\n\n    Args:\n        data (bool, optional):\n            If True, shows also up to 5 unique values stored under such keys.\n            Defaults to False.\n    \"\"\"\n    root = graph_operations.get_attribute_schema(self.nodes(), data=data)\n    graph_operations.render_tree(root, data)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.node_id_exists","title":"<code>node_id_exists(node_id)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def node_id_exists(self, node_id):\n    if node_id in [i for i, attribs in self.nodes()]:\n        logging.warning(f\"{node_id} already exists.\")\n        return True\n    return False\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.nodes","title":"<code>nodes()</code>","text":"YIELDS DESCRIPTION <code>tuple[Union[str, int], Any]</code> <p>Iterator through each node and its attrib (two-tuple)</p> Source code in <code>src/genet/core.py</code> <pre><code>def nodes(self) -&gt; Iterator[tuple[Union[str, int], Any]]:\n    \"\"\"\n    Yields:\n        Iterator through each node and its attrib (two-tuple)\n    \"\"\"\n    for id, attrib in self.graph.nodes(data=True):\n        yield id, attrib\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.nodes_on_modal_condition","title":"<code>nodes_on_modal_condition(modes)</code>","text":"<p>Finds node IDs with modes or singular mode given in <code>modes</code>.</p> PARAMETER DESCRIPTION <code>modes</code> <p>string mode e.g. 'car' or a list of such modes e.g. ['car', 'walk'].</p> <p> TYPE: <code>Union[str, list]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: list of node IDs.</p> Source code in <code>src/genet/core.py</code> <pre><code>def nodes_on_modal_condition(self, modes: Union[str, list]) -&gt; list[str]:\n    \"\"\"Finds node IDs with modes or singular mode given in `modes`.\n\n    Args:\n        modes (Union[str, list]): string mode e.g. 'car' or a list of such modes e.g. ['car', 'walk'].\n\n    Returns:\n        list[str]: list of node IDs.\n    \"\"\"\n    links = self.links_on_modal_condition(modes)\n    nodes = {self.link(link)[\"from\"] for link in links} | {\n        self.link(link)[\"to\"] for link in links\n    }\n    return list(nodes)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.nodes_on_spatial_condition","title":"<code>nodes_on_spatial_condition(region_input)</code>","text":"<p>Returns node IDs which intersect <code>region_input</code>.</p> PARAMETER DESCRIPTION <code>region_input</code> <ul> <li>path to a geojson file, can have multiple features.</li> <li>string with comma separated hex tokens of Google's S2 geometry. A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/. E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.</li> <li>shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.</li> </ul> <p> TYPE: <code>Union[str, BaseGeometry]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: Node IDs</p> Source code in <code>src/genet/core.py</code> <pre><code>def nodes_on_spatial_condition(self, region_input: Union[str, BaseGeometry]) -&gt; list[str]:\n    \"\"\"Returns node IDs which intersect `region_input`.\n\n    Args:\n        region_input (Union[str, BaseGeometry]):\n            - path to a geojson file, can have multiple features.\n            - string with comma separated hex tokens of Google's S2 geometry.\n            A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/.\n            E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.\n            - shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.\n\n    Returns:\n        list[str]: Node IDs\n    \"\"\"\n    if not isinstance(region_input, str):\n        # assumed to be a shapely.geometry input\n        gdf = self.to_geodataframe()[\"nodes\"].to_crs(\"epsg:4326\")\n        return self._find_ids_on_shapely_geometry(\n            gdf, how=\"intersect\", shapely_input=region_input\n        )\n    elif persistence.is_geojson(region_input):\n        gdf = self.to_geodataframe()[\"nodes\"].to_crs(\"epsg:4326\")\n        return self._find_ids_on_geojson(gdf, how=\"intersect\", geojson_input=region_input)\n    else:\n        # is assumed to be hex\n        return self._find_node_ids_on_s2_geometry(region_input)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.number_of_multi_edges","title":"<code>number_of_multi_edges(u, v)</code>","text":"<p>Number of multi edges on edge from u to v.</p> PARAMETER DESCRIPTION <code>u</code> <p>From node.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>v</code> <p>To node.</p> <p> TYPE: <code>Union[str, int]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of edges between <code>u</code> and <code>v</code>.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def number_of_multi_edges(self, u: Union[str, int], v: Union[str, int]) -&gt; int:\n    \"\"\"Number of multi edges on edge from u to v.\n\n    Args:\n        u (Union[str, int]): From node.\n        v (Union[str, int]): To node.\n\n    Returns:\n        int: Number of edges between `u` and `v`.\n    \"\"\"\n    if self.graph.has_edge(u, v):\n        return len(self.graph.edges(u, v))\n    else:\n        return 0\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.plot","title":"<code>plot(output_dir='', data=False)</code>","text":"<p>Plots the network graph and schedule on kepler map.</p> <p>Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Output directory for the image, if passed, will save plot to html. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>data</code> <p>If False, only the geometry and ID will be visible. If True, all data will be visible on the map (not suitable for large networks) If a set of keys, e.g. {'freespeed', 'capacity'}, only that data will be visible. Defaults to False.</p> <p> TYPE: <code>bool | set</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>KeplerGl</code> <p>Kepler plot object.</p> <p> TYPE: <code>KeplerGl</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def plot(self, output_dir: str = \"\", data: Union[bool, set] = False) -&gt; KeplerGl:\n    \"\"\"Plots the network graph and schedule on kepler map.\n\n    Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.\n\n    Args:\n        output_dir (str, optional): Output directory for the image, if passed, will save plot to html. Defaults to \"\".\n        data (bool | set, optional):\n            If False, only the geometry and ID will be visible.\n            If True, all data will be visible on the map (not suitable for large networks)\n            If a set of keys, e.g. {'freespeed', 'capacity'}, only that data will be visible.\n            Defaults to False.\n\n    Returns:\n        KeplerGl: Kepler plot object.\n    \"\"\"\n    if not self.schedule:\n        logging.warning(\n            \"This Network does not have a PT schedule. Only the graph will be visualised.\"\n        )\n        return self.plot_graph(output_dir=output_dir)\n    network_links = self.to_geodataframe()[\"links\"]\n    schedule_routes = self.schedule_network_routes_geodataframe()\n\n    if data is not True:\n        network_links = sanitiser._subset_plot_gdf(\n            data, network_links, base_keys={\"id\", \"geometry\"}\n        )\n        schedule_routes = sanitiser._subset_plot_gdf(\n            data, schedule_routes, base_keys={\"route_id\", \"geometry\"}\n        )\n\n    m = plot.plot_geodataframes_on_kepler_map(\n        {\n            \"network_links\": sanitiser.sanitise_geodataframe(network_links),\n            \"schedule_routes\": sanitiser.sanitise_geodataframe(schedule_routes),\n        },\n        kepler_config=\"network_with_pt\",\n    )\n    if output_dir:\n        persistence.ensure_dir(output_dir)\n        m.save_to_html(file_name=os.path.join(output_dir, \"network_with_pt_routes.html\"))\n    return m\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.plot_graph","title":"<code>plot_graph(output_dir='', data=False)</code>","text":"<p>Plots the network graph only on kepler map.</p> <p>Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Output directory for the image, if passed, will save plot to html. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>data</code> <p>If False, only the geometry and ID will be visible. If True, all data will be visible on the map (not suitable for large networks) If a set of keys, e.g. {'freespeed', 'capacity'}, only that data will be visible. Defaults to False.</p> <p> TYPE: <code>bool | set</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>KeplerGl</code> <p>Kepler plot object.</p> <p> TYPE: <code>KeplerGl</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def plot_graph(self, output_dir: str = \"\", data: Union[bool, set] = False) -&gt; KeplerGl:\n    \"\"\"Plots the network graph only on kepler map.\n\n    Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.\n\n    Args:\n        output_dir (str, optional): Output directory for the image, if passed, will save plot to html. Defaults to \"\".\n        data (bool | set, optional):\n            If False, only the geometry and ID will be visible.\n            If True, all data will be visible on the map (not suitable for large networks)\n            If a set of keys, e.g. {'freespeed', 'capacity'}, only that data will be visible.\n            Defaults to False.\n\n    Returns:\n        KeplerGl:  Kepler plot object.\n    \"\"\"\n    network_links = self.to_geodataframe()[\"links\"]\n\n    if data is not True:\n        network_links = sanitiser._subset_plot_gdf(\n            data, network_links, base_keys={\"id\", \"geometry\"}\n        )\n\n    m = plot.plot_geodataframes_on_kepler_map(\n        {\"network_links\": sanitiser.sanitise_geodataframe(network_links)},\n        kepler_config=\"network_with_pt\",\n    )\n    if output_dir:\n        persistence.ensure_dir(output_dir)\n        m.save_to_html(file_name=os.path.join(output_dir, \"network_graph.html\"))\n    return m\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.plot_schedule","title":"<code>plot_schedule(output_dir='', data=False)</code>","text":"<p>Plots original stop connections in the network's schedule over the network graph on kepler map.</p> <p>Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Output directory for the image, if passed, will save plot to html. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>data</code> <p>If False, only the geometry and ID will be visible. If True, all data will be visible on the map (not suitable for large networks) If a set of keys, e.g. {'freespeed', 'capacity'}, only that data will be visible. Defaults to False.</p> <p> TYPE: <code>bool | set</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>KeplerGl</code> <p>Kepler plot object.</p> <p> TYPE: <code>KeplerGl</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def plot_schedule(self, output_dir: str = \"\", data: Union[bool, set] = False) -&gt; KeplerGl:\n    \"\"\"Plots original stop connections in the network's schedule over the network graph on kepler map.\n\n    Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.\n\n    Args:\n        output_dir (str, optional): Output directory for the image, if passed, will save plot to html. Defaults to \"\".\n        data (bool | set, optional):\n            If False, only the geometry and ID will be visible.\n            If True, all data will be visible on the map (not suitable for large networks)\n            If a set of keys, e.g. {'freespeed', 'capacity'}, only that data will be visible.\n            Defaults to False.\n\n    Returns:\n        KeplerGl:  Kepler plot object.\n    \"\"\"\n    network_links = self.to_geodataframe()[\"links\"]\n    schedule_gdf = self.schedule.to_geodataframe()\n\n    if data is not True:\n        network_links = sanitiser._subset_plot_gdf(\n            data, network_links, base_keys={\"id\", \"geometry\"}\n        )\n        schedule_gdf[\"links\"] = sanitiser._subset_plot_gdf(\n            data, schedule_gdf[\"links\"], base_keys={\"route_id\", \"geometry\"}\n        )\n        schedule_gdf[\"nodes\"] = sanitiser._subset_plot_gdf(\n            data, schedule_gdf[\"nodes\"], base_keys={\"id\", \"geometry\"}\n        )\n\n    m = plot.plot_geodataframes_on_kepler_map(\n        {\n            \"network_links\": sanitiser.sanitise_geodataframe(network_links),\n            \"schedule_links\": sanitiser.sanitise_geodataframe(schedule_gdf[\"links\"]),\n            \"schedule_stops\": sanitiser.sanitise_geodataframe(schedule_gdf[\"nodes\"]),\n        },\n        kepler_config=\"network_and_schedule\",\n    )\n    if output_dir:\n        persistence.ensure_dir(output_dir)\n        m.save_to_html(file_name=os.path.join(output_dir, \"network_and_schedule.html\"))\n    return m\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.print","title":"<code>print()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def print(self):\n    print(self.info())\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.read_auxiliary_link_file","title":"<code>read_auxiliary_link_file(file_path)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def read_auxiliary_link_file(self, file_path):\n    aux_file = auxiliary_files.AuxiliaryFile(file_path)\n    aux_file.attach({link_id for link_id, dat in self.links()})\n    if aux_file.is_attached():\n        self.auxiliary_files[\"link\"][aux_file.filename] = aux_file\n    else:\n        logging.warning(f\"Auxiliary file {file_path} failed to attach to {self.__name__} links\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.read_auxiliary_node_file","title":"<code>read_auxiliary_node_file(file_path)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def read_auxiliary_node_file(self, file_path):\n    aux_file = auxiliary_files.AuxiliaryFile(file_path)\n    aux_file.attach({node_id for node_id, dat in self.nodes()})\n    if aux_file.is_attached():\n        self.auxiliary_files[\"node\"][aux_file.filename] = aux_file\n    else:\n        logging.warning(f\"Auxiliary file {file_path} failed to attach to {self.__name__} nodes\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.reindex_link","title":"<code>reindex_link(link_id, new_link_id, silent=False)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def reindex_link(self, link_id, new_link_id, silent: bool = False):\n    # check if new id is already occupied\n    if self.link_id_exists(new_link_id):\n        new_link_id = self.generate_index_for_edge()\n    new_attribs = deepcopy(self.link(link_id))\n    new_attribs[\"id\"] = new_link_id\n    self.change_log.modify(\n        object_type=\"link\",\n        old_id=link_id,\n        new_id=new_link_id,\n        old_attributes=self.link(link_id),\n        new_attributes=new_attribs,\n    )\n    self.apply_attributes_to_link(link_id, new_attribs)\n    self.link_id_mapping[new_link_id] = self.link_id_mapping[link_id]\n    del self.link_id_mapping[link_id]\n    self.update_link_auxiliary_files({link_id: new_link_id})\n    if not silent:\n        logging.info(f\"Changed Link index from {link_id} to {new_link_id}\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.reindex_node","title":"<code>reindex_node(node_id, new_node_id, silent=False)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def reindex_node(self, node_id, new_node_id, silent: bool = False):\n    # check if new id is already occupied\n    if self.node_id_exists(new_node_id):\n        new_node_id = self.generate_index_for_node()\n    # extract link ids which will be affected byt the node relabel and change the from anf to attributes\n    from_links = self.extract_links_on_edge_attributes(conditions={\"from\": node_id})\n    self.apply_attributes_to_links({link: {\"from\": new_node_id} for link in from_links})\n    to_links = self.extract_links_on_edge_attributes(conditions={\"to\": node_id})\n    self.apply_attributes_to_links({link: {\"to\": new_node_id} for link in to_links})\n    # update link_id_mapping\n    for k in from_links:\n        self.link_id_mapping[k][\"from\"] = new_node_id\n    for k in to_links:\n        self.link_id_mapping[k][\"to\"] = new_node_id\n\n    new_attribs = deepcopy(self.node(node_id))\n    new_attribs[\"id\"] = new_node_id\n    self.change_log.modify(\n        object_type=\"node\",\n        old_id=node_id,\n        new_id=new_node_id,\n        old_attributes=self.node(node_id),\n        new_attributes=new_attribs,\n    )\n    self.apply_attributes_to_node(node_id, new_attribs)\n    self.graph = nx.relabel_nodes(self.graph, {node_id: new_node_id})\n    self.update_node_auxiliary_files({node_id: new_node_id})\n    if not silent:\n        logging.info(f\"Changed Node index from {node_id} to {new_node_id}\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.remove_isolated_nodes","title":"<code>remove_isolated_nodes()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def remove_isolated_nodes(self) -&gt; None:\n    if self.has_isolated_nodes():\n        nodes_to_remove = self.isolated_nodes()\n        logging.info(f\"Found {len(nodes_to_remove)} isolated nodes to remove\")\n        self.remove_nodes(nodes_to_remove)\n    else:\n        logging.warning(\"This Network has no isolated nodes to remove\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.remove_link","title":"<code>remove_link(link_id, silent=False)</code>","text":"<p>Removes the multi edge pertaining to link given.</p> PARAMETER DESCRIPTION <code>link_id</code> <p>Edge to remove.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>silent</code> <p>Whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def remove_link(self, link_id: Union[str, int], silent: bool = False):\n    \"\"\"Removes the multi edge pertaining to link given.\n\n    Args:\n        link_id (Union[str, int]): Edge to remove.\n        silent (bool, optional): Whether to mute stdout logging messages. Defaults to False.\n    \"\"\"\n    self.change_log.remove(\n        object_type=\"link\", object_id=link_id, object_attributes=self.link(link_id)\n    )\n    u, v, multi_idx = self.edge_tuple_from_link_id(link_id)\n    self.graph.remove_edge(u, v, multi_idx)\n    del self.link_id_mapping[link_id]\n    self.update_link_auxiliary_files({link_id: None})\n    if not silent:\n        logging.info(f\"Removed link under index: {link_id}\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.remove_links","title":"<code>remove_links(links, ignore_change_log=False, silent=False)</code>","text":"<p>Removes several edges according to their link IDs</p> PARAMETER DESCRIPTION <code>links</code> <p>list of links to remove.</p> <p> TYPE: <code>list[Union[str, int]]</code> </p> <code>ignore_change_log</code> <p>Whether to ignore logging changes to the network in the changelog. Not recommended. Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>silent</code> <p>Whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def remove_links(\n    self, links: list[Union[str, int]], ignore_change_log: bool = False, silent: bool = False\n):\n    \"\"\"Removes several edges according to their link IDs\n\n    Args:\n        links (list[Union[str, int]]): list of links to remove.\n        ignore_change_log (bool, optional):\n            Whether to ignore logging changes to the network in the changelog.\n            Not recommended.\n            Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat.\n            Defaults to False.\n        silent (bool, optional): Whether to mute stdout logging messages. Defaults to False.\n    \"\"\"\n    links = list(links)\n    if not ignore_change_log:\n        self.change_log = self.change_log.remove_bunch(\n            object_type=\"link\",\n            id_bunch=links,\n            attributes_bunch=[self.link(link_id) for link_id in links],\n        )\n    self.graph.remove_edges_from([self.edge_tuple_from_link_id(link_id) for link_id in links])\n    for link_id in links:\n        del self.link_id_mapping[link_id]\n    self.update_link_auxiliary_files(dict(zip(links, [None] * len(links))))\n    if not silent:\n        logging.info(f\"Removed {len(links)} links\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.remove_mode_from_all_links","title":"<code>remove_mode_from_all_links(mode)</code>","text":"<p>Method to remove modes from links in-place.</p> PARAMETER DESCRIPTION <code>mode</code> <p>Which mode to remove.</p> <p> TYPE: <code>Union[set, list, str]</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def remove_mode_from_all_links(self, mode: Union[set, list, str]):\n    \"\"\"Method to remove modes from links in-place.\n\n    Args:\n        mode (Union[set, list, str]): Which mode to remove.\n    \"\"\"\n    self.remove_mode_from_links(set(self.link_id_mapping.keys()), mode)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.remove_mode_from_links","title":"<code>remove_mode_from_links(links, mode)</code>","text":"<p>Method to remove modes from links in-place.</p> PARAMETER DESCRIPTION <code>links</code> <p>Collection of link IDs to remove the mode from.</p> <p> TYPE: <code>Union[set, list]</code> </p> <code>mode</code> <p>Which mode to remove.</p> <p> TYPE: <code>Union[set, list, str]</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def remove_mode_from_links(self, links: Union[set, list], mode: Union[set, list, str]):\n    \"\"\"Method to remove modes from links in-place.\n\n    Args:\n        links (Union[set, list]): Collection of link IDs to remove the mode from.\n        mode (Union[set, list, str]): Which mode to remove.\n    \"\"\"\n\n    def empty_modes(mode_attrib):\n        if not mode_attrib:\n            return True\n        return False\n\n    links = persistence.setify(links)\n    mode = persistence.setify(mode)\n\n    df = self.link_attribute_data_under_keys([\"modes\"])\n    extra = links - set(df.index)\n    if extra:\n        logging.warning(f\"The following links are not present: {extra}\")\n\n    df[\"modes\"] = df[\"modes\"].apply(lambda x: persistence.setify(x))\n\n    df = df.loc[df.index.intersection(links)][df[\"modes\"].apply(lambda x: bool(mode &amp; x))]\n    df[\"modes\"] = df[\"modes\"].apply(lambda x: x - mode)\n    self.apply_attributes_to_links(df.T.to_dict())\n\n    # remove links without modes\n    no_mode_links = graph_operations.extract_on_attributes(\n        self.links(), {\"modes\": empty_modes}, mixed_dtypes=False\n    )\n    self.remove_links(no_mode_links)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.remove_node","title":"<code>remove_node(node_id, silent=False)</code>","text":"<p>Removes the node n and all adjacent edges</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Node ID to remove</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>silent</code> <p>whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def remove_node(self, node_id: Union[str, int], silent: bool = False):\n    \"\"\"Removes the node n and all adjacent edges\n\n    Args:\n        node_id (Union[str, int]): Node ID to remove\n        silent (bool, optional): whether to mute stdout logging messages. Defaults to False.\n    \"\"\"\n    self.change_log.remove(\n        object_type=\"node\", object_id=node_id, object_attributes=self.node(node_id)\n    )\n    self.graph.remove_node(node_id)\n    self.update_node_auxiliary_files({node_id: None})\n    if not silent:\n        logging.info(f\"Removed Node under index: {node_id}\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.remove_nodes","title":"<code>remove_nodes(nodes, ignore_change_log=False, silent=False)</code>","text":"<p>Removes several nodes and all adjacent edges.</p> PARAMETER DESCRIPTION <code>nodes</code> <p>list of nodes to remove.</p> <p> TYPE: <code>list[Union[str, int]]</code> </p> <code>ignore_change_log</code> <p>Whether to ignore logging changes to the network in the changelog. Not recommended. Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>silent</code> <p>Whether to mute stdout logging messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def remove_nodes(\n    self, nodes: list[Union[str, int]], ignore_change_log: bool = False, silent: bool = False\n):\n    \"\"\"Removes several nodes and all adjacent edges.\n\n    Args:\n        nodes (list[Union[str, int]]): list of nodes to remove.\n        ignore_change_log (bool, optional):\n            Whether to ignore logging changes to the network in the changelog.\n            Not recommended.\n            Only used when an alternative changelog event is being produced (e.g. simplification) to reduce changelog bloat.\n            Defaults to False.\n        silent (bool, optional): Whether to mute stdout logging messages. Defaults to False.\n    \"\"\"\n    if not ignore_change_log:\n        self.change_log = self.change_log.remove_bunch(\n            object_type=\"node\",\n            id_bunch=nodes,\n            attributes_bunch=[self.node(node_id) for node_id in nodes],\n        )\n    self.graph.remove_nodes_from(nodes)\n    self.update_node_auxiliary_files(dict(zip(nodes, [None] * len(nodes))))\n    if not silent:\n        logging.info(f\"Removed {len(nodes)} nodes.\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.report_on_link_attribute_condition","title":"<code>report_on_link_attribute_condition(attribute, condition)</code>","text":"PARAMETER DESCRIPTION <code>attribute</code> <p>One of the link attributes, e.g. 'length'.</p> <p> TYPE: <code>str</code> </p> <code>condition</code> <p>Condition for link[attribute] to satisfy.</p> <p> TYPE: <code>Callable</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Report.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def report_on_link_attribute_condition(self, attribute: str, condition: Callable) -&gt; dict:\n    \"\"\"\n    Args:\n        attribute (str): One of the link attributes, e.g. 'length'.\n        condition (Callable): Condition for link[attribute] to satisfy.\n\n    Returns:\n        dict: Report.\n    \"\"\"\n    if isinstance(attribute, dict):\n        conditions = dict_support.nest_at_leaf(deepcopy(attribute), condition)\n    else:\n        conditions = {attribute: condition}\n\n    links_satifying_condition = self.extract_links_on_edge_attributes(conditions=conditions)\n    return {\n        \"number_of\": len(links_satifying_condition),\n        \"percentage\": len(links_satifying_condition) / self.graph.number_of_edges(),\n        \"link_ids\": links_satifying_condition,\n    }\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.reproject","title":"<code>reproject(new_epsg, processes=1)</code>","text":"<p>Changes projection of the network to <code>new_epsg</code>.</p> PARAMETER DESCRIPTION <code>new_epsg</code> <p>New network projection, e.g., 'epsg:1234'.</p> <p> TYPE: <code>str</code> </p> <code>processes</code> <p>max number of process to split computation across. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def reproject(self, new_epsg: str, processes: int = 1):\n    \"\"\"Changes projection of the network to `new_epsg`.\n\n    Args:\n        new_epsg (str): New network projection, e.g., 'epsg:1234'.\n        processes (int, optional): max number of process to split computation across. Defaults to 1.\n    \"\"\"\n    # reproject nodes\n    nodes_attribs = dict(self.nodes())\n    new_nodes_attribs = parallel.multiprocess_wrap(\n        data=nodes_attribs,\n        split=parallel.split_dict,\n        apply=modify_graph.reproj,\n        combine=parallel.combine_dict,\n        processes=processes,\n        from_proj=self.epsg,\n        to_proj=new_epsg,\n    )\n    self.apply_attributes_to_nodes(new_nodes_attribs)\n\n    # reproject geometries\n    gdf_geometries = gpd.GeoDataFrame(\n        self.link_attribute_data_under_keys([\"geometry\"]), crs=self.epsg\n    )\n    gdf_geometries = gdf_geometries.to_crs(new_epsg)\n    new_link_attribs = gdf_geometries.T.to_dict()\n    self.apply_attributes_to_links(new_link_attribs)\n\n    if self.schedule:\n        self.schedule.reproject(new_epsg, processes)\n    self.initiate_crs_transformer(new_epsg)\n    self.graph.graph[\"crs\"] = self.epsg\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.reroute","title":"<code>reroute(_id, additional_modes=None)</code>","text":"<p>Finds network route for a Service of ID=_id or Route of ID=_id, if the Stops for that Route or Service are already snapped to the network (have linkRefId attributes).</p> <p>Checks that those linkRefIds are still in the network, logs a warning if not.</p> <p>Updates Route/Service object in-place.</p> PARAMETER DESCRIPTION <code>_id</code> <p>ID of Route or Service object. If Service, updated route attribute of all Routes contained within the Service object.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>additional_modes</code> <p>By default the network subgraph considered for snapping and routing will be matching the service modes exactly e.g. just 'bus' mode. You can relax it by adding extra modes e.g. 'car' or {'car', 'rail'}. Referencing modes present under 'modes' attribute of Network links. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, set, list]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>ID must be a route or service.</p> Source code in <code>src/genet/core.py</code> <pre><code>def reroute(\n    self, _id: Union[str, int], additional_modes: Optional[Union[str, set, list]] = None\n):\n    \"\"\"Finds network route for a Service of ID=_id or Route of ID=_id, if the Stops for that Route or Service are already snapped to the network (have linkRefId attributes).\n\n    Checks that those linkRefIds are still in the network, logs a warning if not.\n\n    Updates Route/Service object in-place.\n\n    Args:\n        _id (Union[str, int]):\n            ID of Route or Service object.\n            If Service, updated route attribute of all Routes contained within the Service object.\n        additional_modes (Optional[Union[str, set, list]], optional):\n            By default the network subgraph considered for snapping and routing will be matching the service modes exactly e.g. just 'bus' mode.\n            You can relax it by adding extra modes e.g. 'car' or {'car', 'rail'}.\n            Referencing modes present under 'modes' attribute of Network links.\n            Defaults to None.\n\n    Raises:\n        IndexError: ID must be a route or service.\n    \"\"\"\n    try:\n        self._reroute_service(_id, additional_modes)\n    except exceptions.ServiceIndexError:\n        try:\n            self._reroute_route(_id, additional_modes)\n        except exceptions.RouteIndexError:\n            logging.warning(\n                f\"Object of ID: `{_id}` was not found as a Route or Service in the Schedule\"\n            )\n            raise IndexError(f\"Unrecognised Index `{_id}` in this context.\")\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.retain_n_connected_subgraphs","title":"<code>retain_n_connected_subgraphs(n, mode)</code>","text":"<p>Method to remove modes in-place from link which do not belong to largest connected n components.</p> <p>Deletes links which have no mode left after the process.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of components to retain.</p> <p> TYPE: <code>int</code> </p> <code>mode</code> <p>Which mode to consider.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def retain_n_connected_subgraphs(self, n: int, mode: str):\n    \"\"\"Method to remove modes in-place from link which do not belong to largest connected n components.\n\n    Deletes links which have no mode left after the process.\n\n    Args:\n        n (int): Number of components to retain.\n        mode (str): Which mode to consider.\n    \"\"\"\n    modal_subgraph = self.modal_subgraph(mode)\n    # calculate how many connected subgraphs there are\n    connected_components = network_validation.find_connected_subgraphs(modal_subgraph)\n    connected_components_nodes = []\n    for i in range(0, n):\n        connected_components_nodes += connected_components[i][0]\n    connected_subgraphs_to_extract = (\n        modal_subgraph.subgraph(connected_components_nodes).copy().edges.data(\"id\")\n    )\n    diff_links = set([e[2] for e in modal_subgraph.edges.data(\"id\")]) - set(\n        [e[2] for e in connected_subgraphs_to_extract]\n    )\n    logging.info(\n        f\"Extracting largest connected components resulted in mode: {mode} being deleted from \"\n        f\"{len(diff_links)} edges\"\n    )\n    self.remove_mode_from_links(diff_links, mode)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.route_distance","title":"<code>route_distance(link_ids)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def route_distance(self, link_ids: Union[set, list]) -&gt; int:\n    if self.has_valid_link_chain(link_ids):\n        distance = 0\n        for link_id in link_ids:\n            link_attribs = self.link(link_id)\n            if \"length\" in link_attribs:\n                distance += link_attribs[\"length\"]\n            else:\n                length = self.link_length(\n                    link_attribs[\"from\"],\n                    link_attribs[\"to\"],\n                    geometry=link_attribs.get(\"geometry\"),\n                )\n                link_attribs[\"length\"] = length\n                distance += length\n        return distance\n    else:\n        logging.warning(f\"This route is invalid: {link_ids}\")\n        return 0\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.route_schedule","title":"<code>route_schedule(services=None, solver='cbc', allow_partial=True, distance_threshold=30, step_size=10, additional_modes=None, allow_directional_split=False)</code>","text":"<p>Method to find relationship between all Services in Schedule and the Network.</p> <p>It finds closest links in the Network for all stops and finds a network route (ordered list of links in the network) for all Route objects within each Service.</p> <p>It creates new stops: 'old_idlink_id' for an 'old_stop' which snapped to 'link_id'. It does not delete old stops.</p> <p>If there isn't a link available for snapping within threshold and under modal conditions, an artificial self-loop link will be created as well as any connecting links to that unsnapped stop. This can be switched off by setting allow_partial=False. It will raise PartialMaxStableSetProblem error instead.</p> PARAMETER DESCRIPTION <code>services</code> <p>You can specify a list of services within the schedule to be snapped. Defaults to None (i.e., all services).</p> <p> TYPE: <code>Optional[Union[list, set]]</code> DEFAULT: <code>None</code> </p> <code>solver</code> <p>You can specify different mathematical solvers. Defaults to CBC, open source solver which can be found here: https://projects.coin-or.org/Cbc. Another good open source choice is GLPK: https://www.gnu.org/software/glpk/. You specify it as a string e.g. 'glpk', 'cbc', 'gurobi'. The solver needs to support MILP - mixed integer linear programming.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cbc'</code> </p> <code>allow_partial</code> <p>If there isn't a link available for snapping within threshold and, under modal conditions, an artificial self-loop link will be created as well as any connecting links to that unsnapped stop. If set to False and the problem is partial, it will raise PartialMaxStableSetProblem error instead. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>distance_threshold</code> <p>In metres, upper bound for how far too look for links to snap to stops. Defaults to 30.</p> <p> TYPE: <code>int</code> DEFAULT: <code>30</code> </p> <code>step_size</code> <p>In metres, how much to increase search area for links (making this smaller than the distance threshold makes the problem less computationally heavy). Defaults to 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>additional_modes</code> <p>By default the network subgraph considered for snapping and routing will be matching the service modes exactly e.g. just 'bus' mode. You can relax it by adding extra modes e.g. {'tram': {'car', 'rail'}, 'bus': 'car'} - either a set, list of just a single additional mode for a mode in the Schedule. This dictionary need not be exhaustive. Any other modes will be handled in the default way. Referencing modes present under 'modes' attribute of Network links. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>allow_directional_split</code> <p>Defaults to False i.e. one link will be related to a stop in each Service. For some modes, e.g. rail, it may be beneficial to split this problem based on direction of travel. This usually results in stops snapping to multiple links. Routes' stops and their network routes are updated based on direction too. You may like to investigate directional split for different services using a Service object method: <code>split_graph</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[set]</code> <p>Optional[set]: Set of unsnapped services, empty if all snapped, updates Network object and the Schedule object within.</p> Source code in <code>src/genet/core.py</code> <pre><code>def route_schedule(\n    self,\n    services: Optional[Union[list, set]] = None,\n    solver: str = \"cbc\",\n    allow_partial: bool = True,\n    distance_threshold: int = 30,\n    step_size: int = 10,\n    additional_modes: Optional[dict] = None,\n    allow_directional_split: bool = False,\n) -&gt; Optional[set]:\n    \"\"\"Method to find relationship between all Services in Schedule and the Network.\n\n    It finds closest links in the Network for all stops and finds a network route (ordered list of links in the network) for all Route objects within each Service.\n\n    It creates new stops: 'old_id:link:link_id' for an 'old_stop' which snapped to 'link_id'.\n    It does not delete old stops.\n\n    If there isn't a link available for snapping within threshold and under modal conditions,\n    an artificial self-loop link will be created as well as any connecting links to that unsnapped stop.\n    This can be switched off by setting allow_partial=False.\n    It will raise PartialMaxStableSetProblem error instead.\n\n    Args:\n        services (Optional[Union[list, set]], optional):\n            You can specify a list of services within the schedule to be snapped.\n            Defaults to None (i.e., all services).\n        solver (str, optional):\n            You can specify different mathematical solvers.\n            Defaults to CBC, open source solver which can be found here: https://projects.coin-or.org/Cbc.\n            Another good open source choice is GLPK: https://www.gnu.org/software/glpk/.\n            You specify it as a string e.g. 'glpk', 'cbc', 'gurobi'.\n            The solver needs to support MILP - mixed integer linear programming.\n        allow_partial (bool, optional):\n            If there isn't a link available for snapping within threshold and, under modal conditions,\n            an artificial self-loop link will be created as well as any connecting links to that unsnapped stop.\n            If set to False and the problem is partial, it will raise PartialMaxStableSetProblem error instead.\n            Defaults to True.\n        distance_threshold (int, optional):\n            In metres, upper bound for how far too look for links to snap to stops. Defaults to 30.\n        step_size (int, optional):\n            In metres, how much to increase search area for links\n            (making this smaller than the distance threshold makes the problem less computationally heavy).\n            Defaults to 10.\n        additional_modes (Optional[dict], optional):\n            By default the network subgraph considered for snapping and routing will be matching the service modes exactly e.g. just 'bus' mode.\n            You can relax it by adding extra modes e.g. {'tram': {'car', 'rail'}, 'bus': 'car'} - either a set, list of just a single additional mode for a mode in the Schedule.\n            This dictionary need not be exhaustive.\n            Any other modes will be handled in the default way.\n            Referencing modes present under 'modes' attribute of Network links.\n            Defaults to None.\n        allow_directional_split (bool, optional):\n            Defaults to False i.e. one link will be related to a stop in each Service.\n            For some modes, e.g. rail, it may be beneficial to split this problem based on direction of travel.\n            This usually results in stops snapping to multiple links.\n            Routes' stops and their network routes are updated based on direction too.\n            You may like to investigate directional split for different services using a Service object method: `split_graph`.\n\n    Returns:\n        Optional[set]: Set of unsnapped services, empty if all snapped, updates Network object and the Schedule object within.\n    \"\"\"\n    if self.schedule:\n        logging.info(\"Building Spatial Tree\")\n        spatial_tree = spatial.SpatialTree(self)\n        if additional_modes is None:\n            additional_modes = {}\n        else:\n            for k, v in additional_modes.items():\n                additional_modes[k] = persistence.setify(v)\n\n        changeset = None\n        route_data = self.schedule.route_attribute_data(keys=[\"ordered_stops\"])\n        service_modes = self.schedule.route_attribute_data(\n            keys=[\"mode\"], index_name=\"route_id\"\n        ).reset_index()\n        service_modes[\"service_id\"] = service_modes[\"route_id\"].map(\n            self.schedule.graph().graph[\"route_to_service_map\"]\n        )\n        if services is not None:\n            service_modes = service_modes.loc[service_modes[\"service_id\"].isin(services), :]\n        service_modes = (\n            service_modes.groupby(\"service_id\")[\"mode\"].apply(set).apply(list).reset_index()\n        )\n        service_modes[\"mode\"] = service_modes[\"mode\"].apply(lambda x: tuple(sorted(x)))\n        service_modes = service_modes.groupby(\"mode\")[\"service_id\"].apply(set).T.to_dict()\n\n        unsnapped_services = set()\n        for modes, service_ids in service_modes.items():\n            modes = set(modes)\n            buffed_modes = modes.copy()\n            for m in modes &amp; set(additional_modes.keys()):\n                buffed_modes |= additional_modes[m]\n\n            try:\n                logging.info(f\"Extracting Modal SubTree for modes: {modes}\")\n                sub_tree = spatial_tree.modal_subtree(buffed_modes)\n            except exceptions.EmptySpatialTree:\n                sub_tree = None\n                logging.warning(\n                    f\"Services {service_ids} cannot be snapped to the Network with modes = {modes}. \"\n                    \"The modal graph is empty for those modes. Consider teleporting.\"\n                )\n                unsnapped_services |= service_ids\n\n            if sub_tree is not None:\n                for service_id in service_ids:\n                    service = self.schedule[service_id]\n                    logging.info(f\"Routing Service {service.id} with modes = {modes}\")\n                    if allow_directional_split:\n                        logging.info(\"Splitting Service graph\")\n                        routes, graph_groups = service.split_graph()\n                        logging.info(f\"Split Problem into {len(routes)}\")\n                    else:\n                        routes = [set(service.route_ids())]\n                        graph_groups = [service.reference_edges()]\n                    service_g = service.graph()\n\n                    for route_group, graph_group in zip(routes, graph_groups):\n                        route_group = list(route_group)\n                        try:\n                            mss = modify_schedule.route_pt_graph(\n                                pt_graph=nx.edge_subgraph(service_g, graph_group),\n                                network_spatial_tree=sub_tree,\n                                modes=modes,\n                                solver=solver,\n                                allow_partial=allow_partial,\n                                distance_threshold=distance_threshold,\n                                step_size=step_size,\n                            )\n                            if changeset is None:\n                                changeset = mss.to_changeset(route_data.loc[route_group, :])\n                            else:\n                                changeset += mss.to_changeset(route_data.loc[route_group, :])\n                        except Exception:\n                            logging.error(\n                                f\"\\nRouting Service: `{service_id}` resulted in the following Exception:\"\n                                f\"\\n{traceback.format_exc()}\"\n                            )\n                            unsnapped_services.add(service_id)\n        if changeset is not None:\n            self._apply_max_stable_changes(changeset)\n        return unsnapped_services\n    else:\n        logging.warning(\"Schedule object not found\")\n        return None\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.route_service","title":"<code>route_service(service_id, spatial_tree=None, solver='cbc', allow_partial=True, distance_threshold=30, step_size=10, additional_modes=None, allow_directional_split=False)</code>","text":"<p>Method to find relationship between the Service with ID 'service_id' in the Schedule and the Network.</p> <p>It finds closest links in the Network for all stops and finds a network route (ordered list of links in the network) for all Route objects within this Service.</p> <p>It creates new stops: 'old_idlink_id' for an 'old_stop' which snapped to 'link_id'. It does not delete old stops.</p> <p>If there isn't a link available for snapping within threshold and under modal conditions, an artificial self-loop link will be created as well as any connecting links to that unsnapped stop. This can be switched off by setting allow_partial=False. It will raise PartialMaxStableSetProblem error instead.</p> PARAMETER DESCRIPTION <code>service_id</code> <p>ID of the Service object to snap and route</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>spatial_tree</code> <p>If snapping more than one Service, it may be beneficcial to build the spatial tree which is used for snapping separately and pass it here. This is done simply by importing genet and passing the network object in the following way: genet.utils.spatial.SpatialTree(network_object). Defaults to None.</p> <p> TYPE: <code>Optional[SpatialTree]</code> DEFAULT: <code>None</code> </p> <code>solver</code> <p>You can specify different mathematical solvers. Defaults to CBC, open source solver which can be found here: https://projects.coin-or.org/Cbc. Another good open source choice is GLPK: https://www.gnu.org/software/glpk/. You specify it as a string e.g. 'glpk', 'cbc', 'gurobi'. The solver needs to support MILP - mixed integer linear programming.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cbc'</code> </p> <code>allow_partial</code> <p>If there isn't a link available for snapping within threshold and, under modal conditions, an artificial self-loop link will be created as well as any connecting links to that unsnapped stop. If set to False and the problem is partial, it will raise PartialMaxStableSetProblem error instead. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>distance_threshold</code> <p>In metres, upper bound for how far too look for links to snap to stops. Defaults to 30.</p> <p> TYPE: <code>int</code> DEFAULT: <code>30</code> </p> <code>step_size</code> <p>In metres, how much to increase search area for links (making this smaller than the distance threshold makes the problem less computationally heavy). Defaults to 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>additional_modes</code> <p>By default the network subgraph considered for snapping and routing will be matching the service modes exactly e.g. just 'bus' mode. You can relax it by adding extra modes e.g. {'tram': {'car', 'rail'}, 'bus': 'car'} - either a set, list of just a single additional mode for a mode in the Schedule. This dictionary need not be exhaustive. Any other modes will be handled in the default way. Referencing modes present under 'modes' attribute of Network links. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>allow_directional_split</code> <p>Defaults to False i.e. one link will be related to a stop in each Service. For some modes, e.g. rail, it may be beneficial to split this problem based on direction of travel. This usually results in stops snapping to multiple links. Routes' stops and their network routes are updated based on direction too. You may like to investigate directional split for different services using a Service object method: <code>split_graph</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Union[str, int]]</code> <p>Optional[Union[str, int]]: None if successful, updates Network object and the Schedule object within. Returns service ID if unsuccessful.</p> Source code in <code>src/genet/core.py</code> <pre><code>def route_service(\n    self,\n    service_id: Union[str, int],\n    spatial_tree: Optional[spatial.SpatialTree] = None,\n    solver: str = \"cbc\",\n    allow_partial: bool = True,\n    distance_threshold: int = 30,\n    step_size: int = 10,\n    additional_modes: Optional[dict] = None,\n    allow_directional_split: bool = False,\n) -&gt; Optional[Union[str, int]]:\n    \"\"\"Method to find relationship between the Service with ID 'service_id' in the Schedule and the Network.\n\n    It finds closest links in the Network for all stops and finds a network route (ordered list of links in the\n    network) for all Route objects within this Service.\n\n    It creates new stops: 'old_id:link:link_id' for an 'old_stop' which snapped to 'link_id'.\n    It does not delete old stops.\n\n    If there isn't a link available for snapping within threshold and under modal conditions, an artificial\n    self-loop link will be created as well as any connecting links to that unsnapped stop. This can be switched off\n    by setting allow_partial=False. It will raise PartialMaxStableSetProblem error instead.\n\n    Args:\n        service_id (Union[str, int]): ID of the Service object to snap and route\n        spatial_tree (Optional[spatial.SpatialTree], optional):\n            If snapping more than one Service, it may be beneficcial to build the spatial tree which is used for snapping separately and pass it here.\n            This is done simply by importing genet and passing the network object in the following way: genet.utils.spatial.SpatialTree(network_object).\n            Defaults to None.\n        solver (str, optional):\n            You can specify different mathematical solvers.\n            Defaults to CBC, open source solver which can be found here: https://projects.coin-or.org/Cbc.\n            Another good open source choice is GLPK: https://www.gnu.org/software/glpk/.\n            You specify it as a string e.g. 'glpk', 'cbc', 'gurobi'.\n            The solver needs to support MILP - mixed integer linear programming.\n        allow_partial (bool, optional):\n            If there isn't a link available for snapping within threshold and, under modal conditions,\n            an artificial self-loop link will be created as well as any connecting links to that unsnapped stop.\n            If set to False and the problem is partial, it will raise PartialMaxStableSetProblem error instead.\n            Defaults to True.\n        distance_threshold (int, optional):\n            In metres, upper bound for how far too look for links to snap to stops. Defaults to 30.\n        step_size (int, optional):\n            In metres, how much to increase search area for links\n            (making this smaller than the distance threshold makes the problem less computationally heavy).\n            Defaults to 10.\n        additional_modes (Optional[dict], optional):\n            By default the network subgraph considered for snapping and routing will be matching the service modes exactly e.g. just 'bus' mode.\n            You can relax it by adding extra modes e.g. {'tram': {'car', 'rail'}, 'bus': 'car'} - either a set, list of just a single additional mode for a mode in the Schedule.\n            This dictionary need not be exhaustive.\n            Any other modes will be handled in the default way.\n            Referencing modes present under 'modes' attribute of Network links.\n            Defaults to None.\n        allow_directional_split (bool, optional):\n            Defaults to False i.e. one link will be related to a stop in each Service.\n            For some modes, e.g. rail, it may be beneficial to split this problem based on direction of travel.\n            This usually results in stops snapping to multiple links.\n            Routes' stops and their network routes are updated based on direction too.\n            You may like to investigate directional split for different services using a Service object method: `split_graph`.\n\n\n    Returns:\n        Optional[Union[str, int]]:\n            None if successful, updates Network object and the Schedule object within.\n            Returns service ID if unsuccessful.\n    \"\"\"\n    if spatial_tree is None:\n        spatial_tree = spatial.SpatialTree(self)\n    additional_modes = persistence.setify(additional_modes)\n\n    service = self.schedule[service_id]\n    if allow_directional_split:\n        routes, graph_groups = service.split_graph()\n        logging.info(f\"Splitting Problem into {len(routes)}\")\n    else:\n        routes = [set(service.route_ids())]\n        graph_groups = [service.reference_edges()]\n    service_g = service.graph()\n    changeset = None\n    route_data = self.schedule.route_attribute_data(keys=[\"ordered_stops\"])\n\n    modes = service.modes()\n    logging.info(f\"Routing Service {service.id} with modes = {modes}\")\n    try:\n        sub_tree = spatial_tree.modal_subtree(modes | additional_modes)\n        for route_group, graph_group in zip(routes, graph_groups):\n            route_group = list(route_group)\n            mss = modify_schedule.route_pt_graph(\n                pt_graph=nx.edge_subgraph(service_g, graph_group),\n                network_spatial_tree=sub_tree,\n                modes=modes,\n                solver=solver,\n                allow_partial=allow_partial,\n                distance_threshold=distance_threshold,\n                step_size=step_size,\n            )\n            if changeset is None:\n                changeset = mss.to_changeset(route_data.loc[route_group, :])\n            else:\n                changeset += mss.to_changeset(route_data.loc[route_group, :])\n        self._apply_max_stable_changes(changeset)\n    except exceptions.EmptySpatialTree:\n        logging.warning(\n            f\"Service {service.id} cannot be snapped to the Network with modes = {modes}. The \"\n            f\"modal graph is empty for those modes. Consider teleporting.\"\n        )\n        return service.id\n    else:\n        return None\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.schedule_network_routes_geodataframe","title":"<code>schedule_network_routes_geodataframe()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def schedule_network_routes_geodataframe(self):\n    if not self.schedule:\n        logging.warning(\"Schedule in this Network is empty\")\n        return gpd.GeoDataFrame().set_crs(self.epsg)\n\n    def combine_geometry(group):\n        group = group.sort_values(by=\"route_sequence\")\n        geom = spatial.merge_linestrings(list(group[\"geometry\"]))\n        group = group.iloc[0, :][[\"route_id\", \"route_short_name\", \"mode\", \"service_id\"]]\n        group[\"geometry\"] = geom\n        return group\n\n    gdf_links = self.to_geodataframe()[\"links\"]\n    routes = self.schedule.route_attribute_data(\n        keys=[\"id\", \"route_short_name\", \"mode\", \"network_links\"]\n    )\n    routes = routes.rename(columns={\"id\": \"route_id\"})\n    routes[\"route_sequence\"] = routes[\"network_links\"].apply(lambda x: list(range(len(x))))\n\n    # expand on network route link sequence\n    routes = pd.DataFrame(\n        {\n            col: np.repeat(routes[col].values, routes[\"network_links\"].str.len())\n            for col in {\"route_id\", \"route_short_name\", \"mode\"}\n        }\n    ).assign(\n        network_links=np.concatenate(routes[\"network_links\"].values),\n        route_sequence=np.concatenate(routes[\"route_sequence\"].values),\n    )\n    routes[\"service_id\"] = routes[\"route_id\"].apply(\n        lambda x: self.schedule.graph().graph[\"route_to_service_map\"][x]\n    )\n\n    # get geometry for link IDs\n    routes = pd.merge(\n        routes, gdf_links[[\"id\", \"geometry\"]], left_on=\"network_links\", right_on=\"id\"\n    )\n    routes = routes.groupby(\"route_id\").apply(combine_geometry).reset_index(drop=True)\n    return gpd.GeoDataFrame(routes).set_crs(self.epsg)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.schedule_routes","title":"<code>schedule_routes()</code>","text":"YIELDS DESCRIPTION <code>Route</code> <p>Iterator returning Route objects within the Schedule</p> Source code in <code>src/genet/core.py</code> <pre><code>def schedule_routes(self) -&gt; Iterator[schedule_elements.Route]:\n    \"\"\"\n    Yields:\n        Iterator returning Route objects within the Schedule\n    \"\"\"\n    for route in self.schedule.routes():\n        yield route\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.schedule_routes_links","title":"<code>schedule_routes_links()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def schedule_routes_links(self):\n    routes = []\n    for service_id, _route in self.schedule_routes():\n        if _route.network_links:\n            routes.append(_route.network_links)\n    return routes\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.schedule_routes_nodes","title":"<code>schedule_routes_nodes()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def schedule_routes_nodes(self):\n    routes = []\n    for _route in self.schedule_routes():\n        if _route.network_links:\n            route_nodes = graph_operations.convert_list_of_link_ids_to_network_nodes(\n                self, _route.network_links\n            )\n            if len(route_nodes) != 1:\n                logging.warning(\n                    f\"The route: {_route.id} is disconnected. Consists of {len(route_nodes)} chunks.\"\n                )\n                routes.extend(route_nodes)\n            else:\n                routes.append(route_nodes[0])\n    return routes\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.services","title":"<code>services()</code>","text":"YIELDS DESCRIPTION <code>Service</code> <p>Iterator returning Service objects</p> Source code in <code>src/genet/core.py</code> <pre><code>def services(self) -&gt; Iterator[schedule_elements.Service]:\n    \"\"\"\n    Yields:\n        Iterator returning Service objects\n    \"\"\"\n    for service in self.schedule.services():\n        yield service\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.simplify","title":"<code>simplify(no_processes=1, keep_loops=False)</code>","text":"<p>Simplifies network graph in-place, retaining only nodes that are junctions.</p> PARAMETER DESCRIPTION <code>no_processes</code> <p>Number of processes to split some computation across. The method is pretty fast though and 1 process is often preferable --- there is overhead for splitting and joining the data. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>keep_loops</code> <p>Simplification often leads to self-loops. These will be removed unless keep_loops=<code>True</code>. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Can only simply the network once.</p> Source code in <code>src/genet/core.py</code> <pre><code>def simplify(self, no_processes: int = 1, keep_loops: bool = False):\n    \"\"\"Simplifies network graph in-place, retaining only nodes that are junctions.\n\n    Args:\n        no_processes (int, optional):\n            Number of processes to split some computation across.\n            The method is pretty fast though and 1 process is often preferable --- there is overhead for splitting and joining the data.\n            Defaults to 1.\n        keep_loops (bool, optional):\n            Simplification often leads to self-loops.\n            These will be removed unless keep_loops=`True`.\n            Defaults to False.\n\n    Raises:\n        RuntimeError: Can only simply the network once.\n    \"\"\"\n    if self.is_simplified():\n        raise RuntimeError(\n            \"This network has already been simplified. You cannot simplify the graph twice.\"\n        )\n    simplification.simplify_graph(self, no_processes)\n\n    df = self.link_attribute_data_under_keys(keys=[\"from\", \"to\"])\n    df = df[df[\"from\"] == df[\"to\"]]\n    loops = set(df.index)\n    # pt stops can be loops\n    pt_stop_loops = set(self.schedule.stop_attribute_data(keys=[\"linkRefId\"])[\"linkRefId\"])\n    useless_self_loops = loops - pt_stop_loops\n    if useless_self_loops:\n        logging.warning(\n            f\"Simplification led to {len(loops)} self-loop links in the network. \"\n            f\"{len(useless_self_loops)} are not connected to the PT stops.\"\n        )\n        if not keep_loops:\n            logging.info(\n                \"The self-loops with no reference to PT stops will now be removed. \"\n                \"To disable this behaviour, use `keep_loops=True`. \"\n                \"Investigate the change log for more information about these links.\"\n            )\n            self.remove_links(useless_self_loops)\n            # delete removed links from the simplification map\n            self.link_simplification_map = {\n                k: v\n                for k, v in self.link_simplification_map.items()\n                if v not in useless_self_loops\n            }\n\n    # mark graph as having been simplified\n    self._mark_as_simplified()\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.split_link_at_node","title":"<code>split_link_at_node(link_id, node_id, distance_threshold=1)</code>","text":"<p>Takes a link and node, and splits the link at the point to create 2 new links.</p> <p>The old link is then deleted.</p> <p>Unlike <code>split_link_at_point</code> this allows multiple links being split using the same mode - meaning they are connected and using the same junction, e.g. two links going in opposite directions. However, the node has to be situated on the geometry of the links involved so it's recommended you use <code>genet.spatial.snap_point_to_line</code> to align the node before adding it.</p> PARAMETER DESCRIPTION <code>link_id</code> <p>ID of the link to split.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>node_id</code> <p>ID of the node in the graph to split at.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>distance_threshold</code> <p>How close the node needs to be to the link to be allowed to split it. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RAISES DESCRIPTION <code>MisalignedNodeError</code> <p>node must be close enough to the link to split it.</p> RETURNS DESCRIPTION <code>dict</code> <p>updated node attributes and links.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def split_link_at_node(\n    self, link_id: Union[str, int], node_id: Union[str, int], distance_threshold: int = 1\n) -&gt; dict:\n    \"\"\"Takes a link and node, and splits the link at the point to create 2 new links.\n\n    The old link is then deleted.\n\n    Unlike `split_link_at_point` this allows multiple links being split using the same mode -\n    meaning they are connected and using the same junction, e.g. two links going in opposite directions.\n    However, the node has to be situated on the geometry of the links involved so it's recommended you use `genet.spatial.snap_point_to_line` to align the node before adding it.\n\n    Args:\n        link_id (Union[str, int]): ID of the link to split.\n        node_id (Union[str, int]): ID of the node in the graph to split at.\n        distance_threshold (int, optional): How close the node needs to be to the link to be allowed to split it. Defaults to 1.\n\n    Raises:\n        exceptions.MisalignedNodeError: node must be close enough to the link to split it.\n\n    Returns:\n        dict: updated node attributes and links.\n    \"\"\"\n    # check if point is on the link LineString\n    node_attribs = self.node(node_id)\n    point = Point(node_attribs[\"x\"], node_attribs[\"y\"])\n    link_attribs = self.link(link_id)\n    from_node = self.node(link_attribs[\"from\"])\n    to_node = self.node(link_attribs[\"to\"])\n    if \"geometry\" in link_attribs:\n        line = link_attribs[\"geometry\"]\n    else:\n        line = LineString(\n            [\n                (float(from_node[\"x\"]), float(from_node[\"y\"])),\n                (float(to_node[\"x\"]), float(to_node[\"y\"])),\n            ]\n        )\n\n    if (\n        point.distance(spatial.snap_point_to_line(point, line, distance_threshold=0))\n        &gt; distance_threshold\n    ):\n        raise exceptions.MisalignedNodeError(\n            f\"Node: {node_id} does not lie close enough to the geometry of the link: {link_id} consider using the \"\n            f\"`genet.spatial.snap_point_to_line` method to align the node before adding it, or using \"\n            f\"`split_link_at_point` which adds a node for you. You can also relax the `distance_threshold` of \"\n            f\"this method. The unit of distance will depend on the projection the network is in.\"\n        )\n    if distance_threshold &gt; 1:\n        logging.warning(\n            \"This method does not move the given node closer to the link being split. Setting the \"\n            \"distance threshold too high will result in a network that looks disconnected when \"\n            \"plotted on a map. We advise moving the node closer, rather than increasing the threshold, \"\n            \"or using the `split_link_at_point` method, which will move and add the node instead.\"\n        )\n\n    # create 2 new links: from_node -&gt; new_node ; new_node -&gt; to_node\n    new_link_1, new_link_2 = self.generate_indices_for_n_edges(2)\n\n    # split geometry\n    new_link_1_geom, new_link_2_geom = spatial.split_line_at_point(point, line)\n\n    # apply attributes from the old link to the 2 new links\n    old_link_attributes = deepcopy(self.link(link_id))\n    links = {\n        new_link_1: {\n            **old_link_attributes,\n            **{\n                \"id\": new_link_1,\n                \"from\": from_node[\"id\"],\n                \"to\": node_id,\n                \"geometry\": new_link_1_geom,\n                \"s2_from\": from_node[\"s2_id\"],\n                \"s2_to\": node_attribs[\"s2_id\"],\n                \"length\": (new_link_1_geom.length / line.length)\n                * old_link_attributes[\"length\"],\n            },\n        },\n        new_link_2: {\n            **old_link_attributes,\n            **{\n                \"id\": new_link_2,\n                \"from\": node_id,\n                \"to\": to_node[\"id\"],\n                \"geometry\": new_link_2_geom,\n                \"s2_from\": node_attribs[\"s2_id\"],\n                \"s2_to\": to_node[\"s2_id\"],\n                \"length\": (new_link_2_geom.length / line.length)\n                * old_link_attributes[\"length\"],\n            },\n        },\n    }\n    self.add_links(links)\n    self.remove_link(link_id)\n\n    # update network routes in the schedule\n    if self.schedule:\n        logging.info(\"Updating network routes in the PT schedule.\")\n        # update schedule routes\n        df_routes = self.schedule.route_attribute_data(keys=[\"network_links\"])\n        df_routes = df_routes[df_routes[\"network_links\"].apply(lambda x: link_id in x)]\n        if not df_routes.empty:\n            df_routes[\"network_links\"] = df_routes[\"network_links\"].apply(\n                lambda x: replace_link_on_pt_route(x, {link_id: [new_link_1, new_link_2]})\n            )\n            self.schedule.apply_attributes_to_routes(df_routes.T.to_dict())\n        else:\n            logging.info(\"No PT routes were affected by this change\")\n\n    return {\"node_attributes\": node_attribs, \"links\": links}\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.split_link_at_point","title":"<code>split_link_at_point(link_id, x, y, node_id=None)</code>","text":"<p>Takes a link and point coordinates, and splits the link at the point to create 2 new links.</p> <p>the old link is then deleted. A new node is added too.</p> PARAMETER DESCRIPTION <code>link_id</code> <p>ID of the link to split</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>x</code> <p>x-coordinates of the point to split at.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>y</code> <p>y-coordinates of the point to split at.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>node_id</code> <p>Suggested ID for the resulting node in the graph. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>updates the graph, returns data for node and links that were added.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def split_link_at_point(\n    self,\n    link_id: Union[str, int],\n    x: Union[str, int],\n    y: Union[str, int],\n    node_id: Optional[Union[str, int]] = None,\n) -&gt; dict:\n    \"\"\"Takes a link and point coordinates, and splits the link at the point to create 2 new links.\n\n    the old link is then deleted.\n    A new node is added too.\n\n    Args:\n        link_id (Union[str, int]): ID of the link to split\n        x (Union[str, int]): x-coordinates of the point to split at.\n        y (Union[str, int]): y-coordinates of the point to split at.\n        node_id (Optional[Union[str, int]], optional): Suggested ID for the resulting node in the graph. Defaults to None.\n\n    Returns:\n        dict: updates the graph, returns data for node and links that were added.\n    \"\"\"\n    if node_id is None:\n        node_id = self.generate_index_for_node()\n    elif self.has_node(node_id):\n        logging.warning(f\"Node with ID {node_id} already exists. Generating new index.\")\n        node_id = self.generate_index_for_node()\n\n    # align the point if not on the link LineString\n    point = Point(x, y)\n    link_attribs = self.link(link_id)\n    from_node = self.node(link_attribs[\"from\"])\n    to_node = self.node(link_attribs[\"to\"])\n    if \"geometry\" in link_attribs:\n        line = link_attribs[\"geometry\"]\n    else:\n        line = LineString(\n            [\n                (float(from_node[\"x\"]), float(from_node[\"y\"])),\n                (float(to_node[\"x\"]), float(to_node[\"y\"])),\n            ]\n        )\n\n    # find nearest point on the link line - for geometry splitting, the point should be on the line\n    point = spatial.snap_point_to_line(point, line)\n\n    node_attributes = {\"id\": node_id, \"x\": point.x, \"y\": point.y}\n    self.add_node(node_id, node_attributes)\n\n    return self.split_link_at_node(link_id, node_id)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.split_links_on_mode","title":"<code>split_links_on_mode(mode, link_id_prefix=None)</code>","text":"<p>Method to split links depending on mode. Existing links with mode <code>mode</code> will have that mode removed. New links will be added with only the mode <code>mode</code> and inheriting data from the link they originated from. The IDs of new link IDs will by default identify the mode, but can be changed with <code>link_id_prefix</code>.</p> <p>Examples:</p> <pre><code>[1] network.link(\"LINK_ID\")\n[out] {\"id\": \"LINK_ID\", \"modes\": {\"car\", \"bike\"}, \"freespeed\": 5, ...}\n</code></pre> <pre><code>[2] network.split_links_on_mode(\"bike\")\n[out] {\"bike---LINK_ID\"}\n</code></pre> <p>The new bike link will assume all the same attributes apart from the \"modes\": <pre><code>[3] network.link(\"bike---LINK_ID\")`\n[out] {\"id\": \"bike---LINK_ID\", \"modes\": {\"bike\"}, \"freespeed\": 5, ...}\n</code></pre></p> <p>The old link will have the <code>bike</code> mode removed <pre><code>[4] network.link(\"LINK_ID\")\n[out] {\"id\": \"LINK_ID\", \"modes\": {\"car\"}, \"freespeed\": 5, ...}\n</code></pre></p> PARAMETER DESCRIPTION <code>mode</code> <p>Mode to split from the links.</p> <p> TYPE: <code>str</code> </p> <code>link_id_prefix</code> <p>Optional, you can request what the</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Set[str]</code> <p>Set of link IDs of the new links</p> Source code in <code>src/genet/core.py</code> <pre><code>def split_links_on_mode(self, mode: str, link_id_prefix: Optional[str] = None) -&gt; Set[str]:\n    \"\"\"Method to split links depending on mode.\n    Existing links with mode `mode` will have that mode removed.\n    New links will be added with only the mode `mode` and inheriting data from the link they originated from.\n    The IDs of new link IDs will by default identify the mode, but can be changed with `link_id_prefix`.\n\n    Examples:\n        ```python\n        [1] network.link(\"LINK_ID\")\n        [out] {\"id\": \"LINK_ID\", \"modes\": {\"car\", \"bike\"}, \"freespeed\": 5, ...}\n        ```\n\n        ```python\n        [2] network.split_links_on_mode(\"bike\")\n        [out] {\"bike---LINK_ID\"}\n        ```\n\n        The new bike link will assume all the same attributes apart from the \"modes\":\n        ```python\n        [3] network.link(\"bike---LINK_ID\")`\n        [out] {\"id\": \"bike---LINK_ID\", \"modes\": {\"bike\"}, \"freespeed\": 5, ...}\n        ```\n\n        The old link will have the `bike` mode removed\n        ```python\n        [4] network.link(\"LINK_ID\")\n        [out] {\"id\": \"LINK_ID\", \"modes\": {\"car\"}, \"freespeed\": 5, ...}\n        ```\n\n    Args:\n        mode (str): Mode to split from the links.\n        link_id_prefix (str): Optional, you can request what the\n\n    Returns:\n        Set of link IDs of the new links\n    \"\"\"\n    modal_links = self.links_on_modal_condition({mode})\n    modal_links = list(modal_links)\n\n    if link_id_prefix == \"\":\n        logging.warning(\"Empty string was set as prefix, the IDs will be randomly assigned\")\n        new_link_ids = self.generate_indices_for_n_edges(len(modal_links))\n    else:\n        if link_id_prefix is None:\n            link_id_prefix = f\"{mode}---\"\n        new_link_ids = [f\"{link_id_prefix}{link_id}\" for link_id in modal_links]\n    new_links = {\n        new_link_id: {**self.link(old_link_id), **{\"modes\": {mode}, \"id\": new_link_id}}\n        for new_link_id, old_link_id in zip(new_link_ids, modal_links)\n    }\n\n    self.remove_mode_from_links(modal_links, mode)\n    self.add_links(new_links)\n    return set(new_links.keys())\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.subgraph_on_link_conditions","title":"<code>subgraph_on_link_conditions(conditions, how=any, mixed_dtypes=True)</code>","text":"<p>Gives a subgraph of network.graph based on matching conditions defined in conditions.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <p>Returns:     nx.MultiDiGraph: Sub-graph of edges where attribute values match <code>conditions</code>.</p> Source code in <code>src/genet/core.py</code> <pre><code>def subgraph_on_link_conditions(\n    self, conditions: Union[list, dict], how: Callable = any, mixed_dtypes: bool = True\n) -&gt; nx.MultiDiGraph:\n    \"\"\"Gives a subgraph of network.graph based on matching conditions defined in conditions.\n\n    Args:\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n    Returns:\n        nx.MultiDiGraph: Sub-graph of edges where attribute values match `conditions`.\n    \"\"\"\n    links = self.extract_links_on_edge_attributes(\n        conditions=conditions, how=how, mixed_dtypes=mixed_dtypes\n    )\n    edges_for_sub = [\n        (\n            self.link_id_mapping[link][\"from\"],\n            self.link_id_mapping[link][\"to\"],\n            self.link_id_mapping[link][\"multi_edge_idx\"],\n        )\n        for link in links\n    ]\n    return nx.MultiDiGraph(nx.edge_subgraph(self.graph, edges_for_sub))\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.subnetwork","title":"<code>subnetwork(links, services=None, strongly_connected_modes=None, n_connected_components=1)</code>","text":"<p>Subset a Network object using a collection of link IDs and (optionally) service IDs.</p> PARAMETER DESCRIPTION <code>links</code> <p>Link IDs to be retained in the new Network.</p> <p> TYPE: <code>Union[list, set]</code> </p> <code>services</code> <p>Collection of service IDs in the Schedule for subsetting. Defaults to None.</p> <p> TYPE: <code>Optional[Union[list, set]]</code> DEFAULT: <code>None</code> </p> <code>strongly_connected_modes</code> <p>Modes in the network that need to be strongly connected. For MATSim those  are modes that agents are allowed to route on. Defaults to {'car', 'walk', 'bike'}. Defaults to None.</p> <p> TYPE: <code>Optional[Union[list, set]]</code> DEFAULT: <code>None</code> </p> <code>n_connected_components</code> <p>Number of expected strongly connected components for <code>the strongly_connected_modes</code>. Defaults to 1, as that is what MATSim expects. Other number may be used if disconnected islands are expected, and then connected up using the <code>connect_components</code> method.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>A new Network object that is a subset of the original</p> <p> TYPE: <code>Network</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def subnetwork(\n    self,\n    links: Union[list, set],\n    services: Optional[Union[list, set]] = None,\n    strongly_connected_modes: Optional[Union[list, set]] = None,\n    n_connected_components: int = 1,\n) -&gt; \"Network\":\n    \"\"\"Subset a Network object using a collection of link IDs and (optionally) service IDs.\n\n    Args:\n        links (Union[list, set]): Link IDs to be retained in the new Network.\n        services (Optional[Union[list, set]], optional): Collection of service IDs in the Schedule for subsetting. Defaults to None.\n        strongly_connected_modes (Optional[Union[list, set]], optional):\n            Modes in the network that need to be strongly connected.\n            For MATSim those  are modes that agents are allowed to route on. Defaults to {'car', 'walk', 'bike'}.\n            Defaults to None.\n        n_connected_components (int, optional):\n            Number of expected strongly connected components for `the strongly_connected_modes`.\n            Defaults to 1, as that is what MATSim expects.\n            Other number may be used if disconnected islands are expected, and then connected up using the `connect_components` method.\n\n    Returns:\n        Network: A new Network object that is a subset of the original\n    \"\"\"\n    logging.info(\n        \"Subsetting a Network will likely result in a disconnected network graph. A cleaner will be ran \"\n        \"that will remove links to make the resulting Network strongly connected for modes: \"\n        \"car, walk, bike.\"\n    )\n    subnetwork = Network(epsg=self.epsg)\n    links = set(links)\n    if self.schedule:\n        if services:\n            logging.info(\n                f\"Schedule will be subsetted using given services: {services}. Links pertaining to their \"\n                \"network routes will also be retained.\"\n            )\n            subschedule = self.schedule.subschedule(services)\n            routes = subschedule.route_attribute_data(keys=[\"network_links\"])\n            links = links | set(np.concatenate(routes[\"network_links\"].values))\n            subnetwork.schedule = subschedule\n    subnetwork.graph = self.subgraph_on_link_conditions(conditions={\"id\": links})\n    subnetwork.link_id_mapping = {k: v for k, v in self.link_id_mapping.items() if k in links}\n\n    if strongly_connected_modes is None:\n        logging.info(\n            \"Param: strongly_connected_modes is defaulting to `{'car', 'walk', 'bike'}` \"\n            \"You can change this behaviour by passing the parameter.\"\n        )\n        strongly_connected_modes = {\"car\", \"walk\", \"bike\"}\n    for mode in strongly_connected_modes:\n        if not subnetwork.is_strongly_connected(modes=mode):\n            logging.warning(\n                f\"The graph for mode {mode} is not strongly connected. \"\n                f\"The largest {n_connected_components} connected components will be extracted.\"\n            )\n            if n_connected_components &gt; 1:\n                logging.info(\n                    \"Number of requested connected components is larger than 1. Consider using \"\n                    \"`connect_components` method to create modal graphs that are strongly connected.\"\n                )\n            subnetwork.retain_n_connected_subgraphs(n=n_connected_components, mode=mode)\n\n    # TODO Inherit and subset Auxiliary files\n\n    logging.info(\n        \"Subsetted Network is ready - do not forget to validate and visualise your subset!\"\n    )\n    return subnetwork\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.subnetwork_on_spatial_condition","title":"<code>subnetwork_on_spatial_condition(region_input, how='intersect', strongly_connected_modes=None, n_connected_components=1)</code>","text":"<p>Subset a Network object using a spatial bound.</p> PARAMETER DESCRIPTION <code>region_input</code> <ul> <li>path to a geojson file, can have multiple features.</li> <li>string with comma separated hex tokens of Google's S2 geometry. A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/. E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.</li> <li>shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.</li> </ul> <p> TYPE: <code>Union[str, BaseGeometry]</code> </p> <code>how</code> <p>Defaults to \"intersect\". - 'intersect' will return IDs of the Services whose at least one Stop intersects the <code>region_input</code>. - 'within' will return IDs of the Services whose all of the Stops are contained within the <code>region_input</code>.</p> <p> TYPE: <code>Literal[intersect, within]</code> DEFAULT: <code>'intersect'</code> </p> <code>strongly_connected_modes</code> <p>Modes in the network that need to be strongly connected. For MATSim those  are modes that agents are allowed to route on. Defaults to {'car', 'walk', 'bike'}. Defaults to None.</p> <p> TYPE: <code>Optional[Union[list, set]]</code> DEFAULT: <code>None</code> </p> <code>n_connected_components</code> <p>Number of expected strongly connected components for <code>the strongly_connected_modes</code>. Defaults to 1, as that is what MATSim expects. Other number may be used if disconnected islands are expected, and then connected up using the <code>connect_components</code> method.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>A new Network object that is a subset of the original</p> <p> TYPE: <code>Network</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def subnetwork_on_spatial_condition(\n    self,\n    region_input: Union[str, BaseGeometry],\n    how: Literal[\"intersect\", \"within\"] = \"intersect\",\n    strongly_connected_modes: Optional[Union[list, set]] = None,\n    n_connected_components: int = 1,\n) -&gt; \"Network\":\n    \"\"\"Subset a Network object using a spatial bound.\n\n    Args:\n        region_input (Union[str, BaseGeometry]):\n            - path to a geojson file, can have multiple features.\n            - string with comma separated hex tokens of Google's S2 geometry.\n            A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/.\n            E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.\n            - shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.\n        how (Literal[intersect, within], optional):\n            Defaults to \"intersect\".\n            - 'intersect' will return IDs of the Services whose at least one Stop intersects the `region_input`.\n            - 'within' will return IDs of the Services whose all of the Stops are contained within the `region_input`.\n        strongly_connected_modes (Optional[Union[list, set]], optional):\n            Modes in the network that need to be strongly connected.\n            For MATSim those  are modes that agents are allowed to route on. Defaults to {'car', 'walk', 'bike'}.\n            Defaults to None.\n        n_connected_components (int, optional):\n            Number of expected strongly connected components for `the strongly_connected_modes`.\n            Defaults to 1, as that is what MATSim expects.\n            Other number may be used if disconnected islands are expected, and then connected up using the `connect_components` method.\n\n    Returns:\n        Network: A new Network object that is a subset of the original\n    \"\"\"\n    if self.schedule:\n        services_to_keep = self.schedule.services_on_spatial_condition(\n            region_input=region_input, how=how\n        )\n    else:\n        services_to_keep = None\n\n    subset_links = set(self.links_on_spatial_condition(region_input=region_input, how=how))\n    return self.subnetwork(\n        links=subset_links,\n        services=services_to_keep,\n        strongly_connected_modes=strongly_connected_modes,\n        n_connected_components=n_connected_components,\n    )\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.summary","title":"<code>summary()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def summary(self):\n    report = {}\n    network_stats = {\n        \"number_of_links\": nx.number_of_edges(self.graph),\n        \"number_of_nodes\": nx.number_of_nodes(self.graph),\n    }\n    report[\"network_graph_info\"] = network_stats\n    report[\"modes\"] = {\"modes_on_links\": self.modes()}\n\n    # check for the old format, i.e. long-form attribute notation\n    if (\n        len(\n            graph_operations.get_attribute_data_under_key(\n                self.links(), {\"attributes\": {\"osm:way:highway\": \"text\"}}\n            ).values()\n        )\n        == 0\n    ):\n        highway_tags = self.link_attribute_data_under_key({\"attributes\": \"osm:way:highway\"})\n        highway_tags = set(\n            itertools.chain.from_iterable(highway_tags.apply(lambda x: persistence.setify(x)))\n        )\n    else:\n        highway_tags = self.link_attribute_data_under_key(\n            {\"attributes\": {\"osm:way:highway\": \"text\"}}\n        )\n        highway_tags = set(\n            itertools.chain.from_iterable(highway_tags.apply(lambda x: persistence.setify(x)))\n        )\n\n    osm_highway_tags = {}\n    for tag in highway_tags:\n        tag_links = self.extract_links_on_edge_attributes(\n            conditions={\"attributes\": {\"osm:way:highway\": tag}}, mixed_dtypes=True\n        )\n        osm_highway_tags[tag] = len(tag_links)\n    report[\"osm_highway_tags\"] = {\"number_of_links_by_tag\": osm_highway_tags}\n\n    links_by_mode = {}\n    for mode in self.modes():\n        mode_links = self.extract_links_on_edge_attributes(\n            conditions={\"modes\": mode}, mixed_dtypes=True\n        )\n        links_by_mode[mode] = len(mode_links)\n    report[\"modes\"][\"number_of_links_by_mode\"] = links_by_mode\n\n    return report\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.summary_report","title":"<code>summary_report()</code>","text":"<p>Returns a report with summary statistics for the network and the schedule.</p> Source code in <code>src/genet/core.py</code> <pre><code>def summary_report(self):\n    \"\"\"\n    Returns a report with summary statistics for the network and the schedule.\n    \"\"\"\n    logging.info(\"Creating a summary report\")\n    report = {\"network\": self.summary()}\n\n    if self.schedule:\n        report[\"schedule\"] = self.schedule.summary()\n\n    return report\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.teleport_service","title":"<code>teleport_service(service_ids)</code>","text":"<p>Teleports service(s) of ID(s) given in <code>service_ids</code> in-place</p> PARAMETER DESCRIPTION <code>service_ids</code> <p>a Service ID or collection of them.</p> <p> TYPE: <code>Union[str, list, set]</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def teleport_service(self, service_ids: Union[str, list, set]):\n    \"\"\"Teleports service(s) of ID(s) given in `service_ids` in-place\n\n    Args:\n        service_ids (Union[str, list, set]): a Service ID or collection of them.\n    \"\"\"\n\n    def route_path(ordered_stops):\n        path = []\n        for u, v in zip(ordered_stops[:-1], ordered_stops[1:]):\n            from_linkrefid = stop_linkrefids[u][\"linkRefId\"]\n            to_linkrefid = stop_linkrefids[v][\"linkRefId\"]\n            f_node = reference_links[from_linkrefid][\"to\"]\n            t_node = reference_links[to_linkrefid][\"from\"]\n            f_node_data = nodes[f_node]\n            t_node_data = nodes[t_node]\n\n            connecting_link = f\"artificial_link===from:{f_node}===to:{t_node}\"\n            reference_links[connecting_link] = {\n                \"id\": connecting_link,\n                \"from\": f_node,\n                \"to\": t_node,\n                \"modes\": {\n                    routes_to_mode_map[route_id][\"mode\"] for route_id in g.nodes[u][\"routes\"]\n                }\n                | {routes_to_mode_map[route_id][\"mode\"] for route_id in g.nodes[v][\"routes\"]},\n                \"length\": spatial.distance_between_s2cellids(\n                    f_node_data[\"s2_id\"], t_node_data[\"s2_id\"]\n                ),\n                \"freespeed\": 44.44,\n                \"capacity\": 9999.0,\n                \"permlanes\": 1,\n            }\n\n            pairwise_path = [from_linkrefid, connecting_link, to_linkrefid]\n            if path:\n                if path[-1] == pairwise_path[0]:\n                    path += pairwise_path[1:]\n                else:\n                    path += pairwise_path\n            else:\n                path.extend(pairwise_path)\n        return path\n\n    if isinstance(service_ids, str):\n        service_ids = {service_ids}\n    sub_graph_edges = set()\n    for service_id in service_ids:\n        sub_graph_edges |= self.schedule.service_reference_edges(service_id)\n    g = nx.DiGraph(nx.edge_subgraph(self.schedule.graph(), sub_graph_edges))\n\n    routes_to_mode_map = self.schedule.route_attribute_data(keys=[\"mode\"]).T.to_dict()\n    nodes = {}\n    reference_links = {}\n    stop_linkrefids = {}\n    for stop, data in g.nodes(data=True):\n        if (\"linkRefId\" not in data) or (not self.has_link(data[\"linkRefId\"])):\n            nodes[stop] = {\n                k: v for k, v in data.items() if k not in {\"services\", \"routes\", \"epsg\"}\n            }\n\n            link_id = f\"artificial_link===from:{stop}===to:{stop}\"\n            reference_links[link_id] = {\n                \"id\": link_id,\n                \"from\": stop,\n                \"to\": stop,\n                \"modes\": {routes_to_mode_map[route_id][\"mode\"] for route_id in data[\"routes\"]},\n                \"length\": 1,\n                \"freespeed\": 44.44,\n                \"capacity\": 9999.0,\n                \"permlanes\": 1,\n            }\n\n            stop_linkrefids[stop] = {\"linkRefId\": link_id}\n        else:\n            link_id = data[\"linkRefId\"]\n            link_data = self.link(link_id)\n            stop_linkrefids[stop] = {\"linkRefId\": link_id}\n            reference_links[link_id] = link_data\n            nodes[link_data[\"from\"]] = self.node(link_data[\"from\"])\n            nodes[link_data[\"to\"]] = self.node(link_data[\"to\"])\n\n    routes = self.schedule.route_attribute_data(keys=\"ordered_stops\")\n    _rs = [self.schedule.service_to_route_map()[service_id] for service_id in service_ids]\n    routes = routes[\n        routes.index.to_series().isin({item for sublist in _rs for item in sublist})\n    ]\n    routes[\"network_links\"] = routes[\"ordered_stops\"].apply(lambda x: route_path(x))\n    routes = routes.drop(\"ordered_stops\", axis=1).T.to_dict()\n\n    self.add_nodes({node: nodes[node] for node in set(nodes) - set(self.graph.nodes)})\n    self.add_links(\n        {\n            link: reference_links[link]\n            for link in set(reference_links) - set(self.link_id_mapping)\n        }\n    )\n    self.schedule.apply_attributes_to_stops(stop_linkrefids)\n    self.schedule.apply_attributes_to_routes(routes)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.to_encoded_geometry_dataframe","title":"<code>to_encoded_geometry_dataframe()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def to_encoded_geometry_dataframe(self):\n    _network = self.to_geodataframe()\n    _network[\"nodes\"] = pd.DataFrame(_network[\"nodes\"])\n    _network[\"links\"] = pd.DataFrame(_network[\"links\"])\n    _network[\"nodes\"][\"geometry\"] = _network[\"nodes\"][\"geometry\"].apply(\n        lambda row: [row.x, row.y]\n    )\n    _network[\"links\"][\"geometry\"] = _network[\"links\"][\"geometry\"].apply(\n        lambda x: spatial.encode_shapely_linestring_to_polyline(x)\n    )\n    return _network\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.to_geodataframe","title":"<code>to_geodataframe()</code>","text":"<p>Generates GeoDataFrames of the Network graph in Network's crs.</p> RETURNS DESCRIPTION <code>dict</code> <p>dict with keys 'nodes' and 'links', values are the GeoDataFrames corresponding to nodes and links.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def to_geodataframe(self) -&gt; dict:\n    \"\"\"Generates GeoDataFrames of the Network graph in Network's crs.\n\n    Returns:\n        dict: dict with keys 'nodes' and 'links', values are the GeoDataFrames corresponding to nodes and links.\n    \"\"\"\n    return spatial_output.generate_geodataframes(self.graph)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.to_json","title":"<code>to_json()</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def to_json(self):\n    _network = self.to_encoded_geometry_dataframe()\n    return {\n        \"nodes\": dict_support.dataframe_to_dict(_network[\"nodes\"].T),\n        \"links\": dict_support.dataframe_to_dict(_network[\"links\"].T),\n    }\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.update_link_auxiliary_files","title":"<code>update_link_auxiliary_files(id_map)</code>","text":"PARAMETER DESCRIPTION <code>id_map</code> <p>dict map between old link ID and new link ID.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def update_link_auxiliary_files(self, id_map: dict):\n    \"\"\"\n\n    Args:\n        id_map (dict): dict map between old link ID and new link ID.\n    \"\"\"\n    for name, aux_file in self.auxiliary_files[\"link\"].items():\n        aux_file.apply_map(id_map)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.update_node_auxiliary_files","title":"<code>update_node_auxiliary_files(id_map)</code>","text":"PARAMETER DESCRIPTION <code>id_map</code> <p>dict map between old node ID and new node ID</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def update_node_auxiliary_files(self, id_map: dict):\n    \"\"\"\n\n    Args:\n        id_map (dict): dict map between old node ID and new node ID\n    \"\"\"\n    for name, aux_file in self.auxiliary_files[\"node\"].items():\n        aux_file.apply_map(id_map)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.write_auxiliary_files","title":"<code>write_auxiliary_files(output_dir)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def write_auxiliary_files(self, output_dir):\n    for id_type in {\"node\", \"link\"}:\n        for name, aux_file in self.auxiliary_files[id_type].items():\n            aux_file.write_to_file(output_dir)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.write_extras","title":"<code>write_extras(output_dir)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def write_extras(self, output_dir):\n    self.change_log.export(os.path.join(output_dir, \"network_change_log.csv\"))\n    self.write_auxiliary_files(os.path.join(output_dir, \"auxiliary_files\"))\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.write_spatial","title":"<code>write_spatial(output_dir, epsg=None, filetype='parquet')</code>","text":"<p>Transforms Network and Schedule (if applicable) to geopandas.GeoDataFrame of nodes and links and saves to the requested file format.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Path to folder where to save the file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection if the geometry is to be reprojected. Defaults to None (no reprojection).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>filetype</code> <p>The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported. Defaults to parquet format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parquet'</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def write_spatial(self, output_dir, epsg: Optional[str] = None, filetype: str = \"parquet\"):\n    \"\"\"Transforms Network and Schedule (if applicable) to geopandas.GeoDataFrame of nodes and links and saves to\n    the requested file format.\n\n    Args:\n        output_dir (str):\n            Path to folder where to save the file.\n        epsg (Optional[str], optional):\n            Projection if the geometry is to be reprojected. Defaults to None (no reprojection).\n        filetype (str, optional):\n            The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported.\n            Defaults to parquet format.\n    \"\"\"\n    # do a quick check the file type is supported before generating all the files\n    gnio.check_file_type_is_supported(filetype)\n\n    persistence.ensure_dir(output_dir)\n    _network = self.to_geodataframe()\n    if epsg is not None:\n        _network[\"nodes\"] = _network[\"nodes\"].to_crs(epsg)\n        _network[\"links\"] = _network[\"links\"].to_crs(epsg)\n    logging.info(f\"Saving Network in {output_dir}\")\n    for gdf, filename in (\n        (_network[\"nodes\"], \"network_nodes\"),\n        (_network[\"links\"], \"network_links\"),\n        (_network[\"nodes\"][\"geometry\"], \"network_nodes_geometry_only\"),\n        (_network[\"links\"][\"geometry\"], \"network_links_geometry_only\"),\n    ):\n        gnio.save_geodataframe(gdf, filename, output_dir, filetype=filetype)\n    if self.schedule:\n        self.schedule.write_spatial(output_dir, epsg=epsg, filetype=filetype)\n    self.write_extras(output_dir)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.write_to_csv","title":"<code>write_to_csv(output_dir, gtfs_day='19700101')</code>","text":"<p>Writes nodes and links tables for the Network and if there is a Schedule, exports it to a GTFS-like format.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>path to folder where to save resulting CSVs.</p> <p> TYPE: <code>str</code> </p> <code>gtfs_day</code> <p>Day in format YYYYMMDD which is represented in the network's schedule. Defaults to \"19700101\" (1970-01-01).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def write_to_csv(self, output_dir: str, gtfs_day: str = \"19700101\"):\n    \"\"\"Writes nodes and links tables for the Network and if there is a Schedule, exports it to a GTFS-like format.\n\n    Args:\n        output_dir (str): path to folder where to save resulting CSVs.\n        gtfs_day (str, optional):\n            Day in format YYYYMMDD which is represented in the network's schedule.\n            Defaults to \"19700101\" (1970-01-01).\n    \"\"\"\n    network_csv_folder = os.path.join(output_dir, \"network\")\n    schedule_csv_folder = os.path.join(output_dir, \"schedule\")\n    persistence.ensure_dir(network_csv_folder)\n    csv_network = self.to_encoded_geometry_dataframe()\n    logging.info(f\"Saving Network to CSV in {network_csv_folder}\")\n    csv_network[\"nodes\"].to_csv(os.path.join(network_csv_folder, \"nodes.csv\"))\n    csv_network[\"links\"].to_csv(os.path.join(network_csv_folder, \"links.csv\"))\n    if self.schedule:\n        persistence.ensure_dir(schedule_csv_folder)\n        self.schedule.write_to_csv(schedule_csv_folder, gtfs_day)\n    self.write_extras(network_csv_folder)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.write_to_json","title":"<code>write_to_json(output_dir)</code>","text":"<p>Writes Network and Schedule (if applicable) to a single JSON file with nodes and links.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Output directory.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def write_to_json(self, output_dir: str):\n    \"\"\"Writes Network and Schedule (if applicable) to a single JSON file with nodes and links.\n\n    Args:\n        output_dir (str): Output directory.\n    \"\"\"\n    persistence.ensure_dir(output_dir)\n    logging.info(f\"Saving Network to JSON in {output_dir}\")\n    with open(os.path.join(output_dir, \"network.json\"), \"w\") as outfile:\n        json.dump(sanitiser.sanitise_dictionary(self.to_json()), outfile)\n    if self.schedule:\n        self.schedule.write_to_json(output_dir)\n    self.write_extras(output_dir)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.Network.write_to_matsim","title":"<code>write_to_matsim(output_dir)</code>","text":"<p>Writes Network and Schedule (if applicable) to MATSim xml format.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Output directory.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/core.py</code> <pre><code>def write_to_matsim(self, output_dir: str):\n    \"\"\"Writes Network and Schedule (if applicable) to MATSim xml format.\n\n    Args:\n        output_dir (str): Output directory.\n    \"\"\"\n    persistence.ensure_dir(output_dir)\n    matsim_xml_writer.write_matsim_network(output_dir, self)\n    if self.schedule:\n        self.schedule.write_to_matsim(output_dir)\n    self.write_extras(output_dir)\n</code></pre>"},{"location":"reference/genet/core/#genet.core.replace_link_on_pt_route","title":"<code>replace_link_on_pt_route(route, mapping)</code>","text":"Source code in <code>src/genet/core.py</code> <pre><code>def replace_link_on_pt_route(route: list[str], mapping: dict[str, Union[str, list]]):\n    new_route: list = []\n    for link in route:\n        mapped_link = mapping.get(link, link)\n        if isinstance(mapped_link, list):\n            new_route += mapped_link\n        else:\n            new_route.append(mapped_link)\n    return new_route\n</code></pre>"},{"location":"reference/genet/exceptions/","title":"genet.exceptions","text":""},{"location":"reference/genet/exceptions/#genet.exceptions.ConflictingStopData","title":"<code>ConflictingStopData</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when two elements share Stop IDs but their data does not match</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.EmptySpatialTree","title":"<code>EmptySpatialTree</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when there is no (relevant) data in the Spatial Tree</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.InconsistentVehicleModeError","title":"<code>InconsistentVehicleModeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when vehicles are shared between Routes with different modes</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.InvalidMaxStableSetProblem","title":"<code>InvalidMaxStableSetProblem</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the maximum stable set to snap PT to the network is not valid and cannot proceed to the solver</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.MalformedAdditionalAttributeError","title":"<code>MalformedAdditionalAttributeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when additional attributes can not be saved to MATSim network</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.MisalignedNodeError","title":"<code>MisalignedNodeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the Network node is not aligned to geometry of a Network link. E.g. when spliting a link at a node or the start/end point of link geometry is different to the location of the node</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.NetworkSchemaError","title":"<code>NetworkSchemaError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the Network or any of its' elements is missing data or is not arranged correctly</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.PartialMaxStableSetProblem","title":"<code>PartialMaxStableSetProblem</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the maximum stable set to snap PT to the network is partial - some stops found nothing to snap to</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.RouteIndexError","title":"<code>RouteIndexError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised in case of Route indexing inconsistency</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.RouteInitialisationError","title":"<code>RouteInitialisationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a genet.Route cannot be instantiated</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.ScheduleElementGraphSchemaError","title":"<code>ScheduleElementGraphSchemaError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the graph which represents a Schedule or any of its' sub elements is missing data or is not arranged correctly</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.ScheduleInitialisationError","title":"<code>ScheduleInitialisationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a genet.Schedule cannot be instantiated</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.ServiceIndexError","title":"<code>ServiceIndexError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised in case of Service indexing inconsistency</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.ServiceInitialisationError","title":"<code>ServiceInitialisationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a genet.Service cannot be instantiated</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.StopIndexError","title":"<code>StopIndexError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised in case of Stop indexing inconsistency</p>"},{"location":"reference/genet/exceptions/#genet.exceptions.UndefinedCoordinateSystemError","title":"<code>UndefinedCoordinateSystemError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an object requires a coordinate system</p>"},{"location":"reference/genet/input/gtfs_reader/","title":"genet.input.gtfs_reader","text":""},{"location":"reference/genet/input/gtfs_reader/#genet.input.gtfs_reader.get_mode","title":"<code>get_mode(route_type)</code>","text":"Source code in <code>src/genet/input/gtfs_reader.py</code> <pre><code>def get_mode(route_type):\n    if not isinstance(route_type, int):\n        route_type = int(route_type)\n\n    if route_type in variables.EXTENDED_TYPE_MAP:\n        return variables.EXTENDED_TYPE_MAP[route_type]\n    else:\n        return \"other\"\n</code></pre>"},{"location":"reference/genet/input/gtfs_reader/#genet.input.gtfs_reader.gtfs_db_to_schedule_graph","title":"<code>gtfs_db_to_schedule_graph(stop_times_db, stops_db, trips_db, routes_db, services)</code>","text":"Source code in <code>src/genet/input/gtfs_reader.py</code> <pre><code>def gtfs_db_to_schedule_graph(stop_times_db, stops_db, trips_db, routes_db, services):\n    def get_time(time):\n        # return time as datetime.datetime, account for 24 in %H\n        time_list = time.split(\":\")\n        if int(time_list[0]) &gt;= 24:\n            days = int(time_list[0]) // 24\n            time_list[0] = int(time_list[0]) % 24\n            if time_list[0] &lt; 10:\n                time_list[0] = \"0{}\".format(time_list[0])\n            else:\n                time_list[0] = str(time_list[0])\n            return datetime.strptime(\":\".join(time_list), \"%H:%M:%S\") + timedelta(days=days)\n        else:\n            return datetime.strptime(time, \"%H:%M:%S\")\n\n    def timedelta_to_hms(td):\n        return str(td).split(\"days\")[-1].strip(\" \")\n\n    def generate_stop_sequence(group):\n        group = group.sort_values(by=\"stop_sequence\")\n        # remove stops that are loopy (consecutively duplicated)\n        unique_stops_mask = group[\"stop_id\"].shift() != group[\"stop_id\"]\n        if not unique_stops_mask.all():\n            logging.warning(\n                \"Your GTFS has (a) looooop edge(s)! A zero link between a node and itself, edge affected \"\n                \"\\nThis edge will not be considered for computation, the stop will be deleted and the \"\n                f'schedule will be changed. Affected stops: {group[~unique_stops_mask][\"stop_id\"].to_list()}'\n            )\n        group = group.loc[unique_stops_mask]\n        flattened = group.iloc[0, :][\n            list(\n                set(group.columns)\n                - {\"trip_id\", \"stop_sequence\", \"stop_id\", \"arrival_time\", \"departure_time\"}\n            )\n        ]\n        departure_time = group.iloc[0, :][\"arrival_time\"]\n        flattened[\"trip_departure_time\"] = departure_time.strftime(\"%H:%M:%S\")\n        flattened[\"ordered_stops\"] = group[\"stop_id\"].to_list()\n        flattened[\"stops_str\"] = \",\".join(group[\"stop_id\"].to_list())\n        flattened[\"arrival_offsets\"] = [\n            timedelta_to_hms(t - departure_time) for t in group[\"arrival_time\"]\n        ]\n        flattened[\"departure_offsets\"] = [\n            timedelta_to_hms(t - departure_time) for t in group[\"departure_time\"]\n        ]\n        return flattened\n\n    def generate_trips(group):\n        flattened = group.iloc[0, :][\n            list(\n                set(group.columns)\n                - {\"route_id\", \"stops_str\", \"trip_id\", \"vehicle_id\", \"trip_departure_time\"}\n            )\n        ]\n        trip_id = group[\"trip_id\"].to_list()\n        trip_departure_time = group[\"trip_departure_time\"].to_list()\n        vehicle_id = group[\"vehicle_id\"].to_list()\n        flattened[\"trips\"] = {\n            \"trip_id\": trip_id,\n            \"trip_departure_time\": trip_departure_time,\n            \"vehicle_id\": vehicle_id,\n        }\n        return flattened\n\n    def generate_routes(group):\n        service_id = group.iloc[0, :][\"service_id\"]\n        group[\"route_id\"] = [f\"{service_id}_{i}\" for i in range(len(group))]\n        return group\n\n    trips_db = trips_db[trips_db[\"service_id\"].isin(services)]\n    df = trips_db[[\"route_id\", \"trip_id\"]].merge(\n        routes_db[\n            routes_db.columns.union(\n                [\"route_id\", \"route_type\", \"route_short_name\", \"route_long_name\", \"route_color\"]\n            )\n        ],\n        on=\"route_id\",\n        how=\"left\",\n    )\n    df[\"mode\"] = df[\"route_type\"].apply(lambda x: get_mode(x))\n    df = df.merge(\n        stop_times_db[[\"trip_id\", \"stop_id\", \"arrival_time\", \"departure_time\", \"stop_sequence\"]],\n        on=\"trip_id\",\n        how=\"left\",\n    )\n    df[\"arrival_time\"] = df[\"arrival_time\"].apply(lambda x: get_time(x))\n    df[\"departure_time\"] = df[\"departure_time\"].apply(lambda x: get_time(x))\n\n    df = df.groupby(\"trip_id\", as_index=False).apply(generate_stop_sequence)\n    # drop stop sequences that are single stops\n    df = df[df[\"ordered_stops\"].str.len() &gt; 1]\n    df[\"vehicle_id\"] = [f\"veh_{i}\" for i in range(len(df))]\n    df = df.groupby([\"route_id\", \"stops_str\"], as_index=False).apply(generate_trips)\n    df = df.drop(\"stops_str\", axis=1)\n    df[\"service_id\"] = df[\"route_id\"].astype(str)\n    df = df.groupby([\"service_id\"], group_keys=False).apply(generate_routes)\n\n    g = nx.DiGraph(name=\"Schedule graph\")\n    g.graph[\"crs\"] = \"epsg:4326\"\n    g.graph[\"route_to_service_map\"] = df.set_index(\"route_id\")[\"service_id\"].T.to_dict()\n    g.graph[\"service_to_route_map\"] = df.groupby(\"service_id\")[\"route_id\"].apply(list).to_dict()\n    g.graph[\"change_log\"] = change_log.ChangeLog()\n\n    df[\"id\"] = df[\"route_id\"]\n    g.graph[\"routes\"] = df.set_index(\"route_id\").T.to_dict()\n    df[\"id\"] = df[\"service_id\"]\n    df = df.rename(columns={\"route_short_name\": \"name\"})\n    g.graph[\"services\"] = df[[\"service_id\", \"id\", \"name\"]].groupby(\"service_id\").first().T.to_dict()\n\n    # finally nodes\n    stops = pd.DataFrame(\n        {\n            col: np.repeat(df[col].values, df[\"ordered_stops\"].str.len())\n            for col in {\"route_id\", \"service_id\"}\n        }\n    ).assign(stop_id=np.concatenate(df[\"ordered_stops\"].values))\n    stop_groups = stops.groupby(\"stop_id\")\n    stops = set(stop_groups.groups)\n    g.add_nodes_from(stops)\n    stops_db = stops_db.rename(columns={\"stop_lat\": \"lat\", \"stop_lon\": \"lon\", \"stop_name\": \"name\"})\n    stops_db[\"id\"] = stops_db[\"stop_id\"]\n    stops_db[\"x\"] = stops_db[\"lon\"]\n    stops_db[\"y\"] = stops_db[\"lat\"]\n    stops_db[\"epsg\"] = \"epsg:4326\"\n    stops_db[\"s2_id\"] = stops_db.apply(\n        lambda x: spatial.generate_index_s2(lat=float(x[\"lat\"]), lng=float(x[\"lon\"])), axis=1\n    )\n    nx.set_node_attributes(\n        g, stops_db[stops_db[\"stop_id\"].isin(stops)].set_index(\"stop_id\").T.to_dict()\n    )\n    nx.set_node_attributes(\n        g,\n        pd.DataFrame(stop_groups[\"route_id\"].apply(set))\n        .rename(columns={\"route_id\": \"routes\"})\n        .T.to_dict(),\n    )\n    nx.set_node_attributes(\n        g,\n        pd.DataFrame(stop_groups[\"service_id\"].apply(set))\n        .rename(columns={\"service_id\": \"services\"})\n        .T.to_dict(),\n    )\n\n    # and edges\n    df[\"ordered_stops\"] = df[\"ordered_stops\"].apply(lambda x: list(zip(x[:-1], x[1:])))\n    stop_cols = np.concatenate(df[\"ordered_stops\"].values)\n    edges = pd.DataFrame(\n        {\n            col: np.repeat(df[col].values, df[\"ordered_stops\"].str.len())\n            for col in {\"route_id\", \"service_id\"}\n        }\n    ).assign(from_stop=stop_cols[:, 0], to_stop=stop_cols[:, 1])\n    edge_groups = edges.groupby([\"from_stop\", \"to_stop\"])\n    g.add_edges_from(edge_groups.groups)\n    nx.set_edge_attributes(\n        g,\n        pd.DataFrame(edge_groups[\"route_id\"].apply(set))\n        .rename(columns={\"route_id\": \"routes\"})\n        .T.to_dict(),\n    )\n    nx.set_edge_attributes(\n        g,\n        pd.DataFrame(edge_groups[\"service_id\"].apply(set))\n        .rename(columns={\"service_id\": \"services\"})\n        .T.to_dict(),\n    )\n    return g\n</code></pre>"},{"location":"reference/genet/input/gtfs_reader/#genet.input.gtfs_reader.read_gtfs_to_db_like_tables","title":"<code>read_gtfs_to_db_like_tables(path)</code>","text":"Source code in <code>src/genet/input/gtfs_reader.py</code> <pre><code>def read_gtfs_to_db_like_tables(path):\n    logging.info(\"Reading GTFS data into usable format\")\n\n    trips_db = None\n    stops_db = None\n    routes_db = None\n    stop_times_db = None\n\n    for file_name in os.listdir(path):\n        file = os.path.join(path, file_name)\n\n        if \"stop_times\" in file:\n            logging.info(\"Reading stop times\")\n            stop_times_db = pd.read_csv(\n                file, dtype={\"trip_id\": str, \"stop_id\": str}, low_memory=False\n            )\n            stop_times_db[\"trip_id\"] = stop_times_db[\"trip_id\"].apply(lambda x: sanitise_id(x))\n            stop_times_db[\"stop_id\"] = stop_times_db[\"stop_id\"].apply(lambda x: sanitise_id(x))\n\n        elif \"stops\" in file:\n            logging.info(\"Reading stops\")\n            stops_db = pd.read_csv(file, dtype={\"stop_id\": str})\n            stops_db[\"stop_id\"] = stops_db[\"stop_id\"].apply(lambda x: sanitise_id(x))\n\n        elif \"trips\" in file:\n            logging.info(\"Reading trips\")\n            trips_db = pd.read_csv(file, dtype={\"route_id\": str, \"service_id\": str, \"trip_id\": str})\n            trips_db[\"trip_id\"] = trips_db[\"trip_id\"].apply(lambda x: sanitise_id(x))\n            trips_db[\"route_id\"] = trips_db[\"route_id\"].apply(lambda x: sanitise_id(x))\n            trips_db[\"service_id\"] = trips_db[\"service_id\"].apply(lambda x: sanitise_id(x))\n\n        elif \"routes\" in file:\n            logging.info(\"Reading routes\")\n            routes_db = pd.read_csv(\n                file, dtype={\"route_id\": str, \"route_short_name\": str, \"route_long_name\": str}\n            )\n            routes_db[\"route_id\"] = routes_db[\"route_id\"].apply(lambda x: sanitise_id(x))\n            routes_db[\"route_short_name\"] = routes_db[\"route_short_name\"].fillna(\"\")\n            routes_db[\"route_long_name\"] = routes_db[\"route_long_name\"].fillna(\"\")\n\n    return stop_times_db, stops_db, trips_db, routes_db\n</code></pre>"},{"location":"reference/genet/input/gtfs_reader/#genet.input.gtfs_reader.read_gtfs_to_schedule_graph","title":"<code>read_gtfs_to_schedule_graph(path, day)</code>","text":"Source code in <code>src/genet/input/gtfs_reader.py</code> <pre><code>def read_gtfs_to_schedule_graph(path: str, day: str):\n    if persistence.is_zip(path):\n        gtfs_path = os.path.join(os.getcwd(), \"tmp\")\n        if not os.path.exists(gtfs_path):\n            os.makedirs(gtfs_path)\n        import zipfile\n\n        with zipfile.ZipFile(path, \"r\") as zip_ref:\n            zip_ref.extractall(gtfs_path)\n        gtfs_path = os.path.join(gtfs_path, os.path.splitext(os.path.basename(path))[0])\n    else:\n        gtfs_path = path\n\n    services = read_services_from_calendar(gtfs_path, day=day)\n    stop_times_db, stops_db, trips_db, routes_db = read_gtfs_to_db_like_tables(gtfs_path)\n    schedule_graph = gtfs_db_to_schedule_graph(\n        stop_times_db, stops_db, trips_db, routes_db, services\n    )\n\n    if persistence.is_zip(path):\n        shutil.rmtree(os.path.dirname(gtfs_path))\n    return schedule_graph\n</code></pre>"},{"location":"reference/genet/input/gtfs_reader/#genet.input.gtfs_reader.read_services_from_calendar","title":"<code>read_services_from_calendar(path, day)</code>","text":"<p>Return list of services to be included.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to GTFS directory.</p> <p> TYPE: <code>str</code> </p> <code>day</code> <p>'YYYYMMDD' for specific day in which to find services.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>There must be at least one service on the day selected.</p> <code>RuntimeError</code> <p>GTFS directory must include a calendar file.</p> RETURNS DESCRIPTION <code>list</code> <p>Included service IDs.</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/input/gtfs_reader.py</code> <pre><code>def read_services_from_calendar(path: str, day: str) -&gt; list:\n    \"\"\"Return list of services to be included.\n\n    Args:\n        path (str): Path to GTFS directory.\n        day (str): 'YYYYMMDD' for specific day in which to find services.\n\n    Raises:\n        RuntimeError: There must be at least one service on the day selected.\n        RuntimeError: GTFS directory must include a calendar file.\n\n    Returns:\n        list: Included service IDs.\n    \"\"\"\n    logging.info(\"Reading the calendar for GTFS\")\n\n    weekdays = {\n        0: \"monday\",\n        1: \"tuesday\",\n        2: \"wednesday\",\n        3: \"thursday\",\n        4: \"friday\",\n        5: \"saturday\",\n        6: \"sunday\",\n    }\n    day_of_the_week = weekdays[datetime.strptime(day, \"%Y%m%d\").weekday()]\n\n    services = []\n\n    calendar_present = False\n    for file_name in os.listdir(path):\n        file = os.path.join(path, file_name)\n        if (\"calendar\" in file) and (\"dates\" not in file):\n            calendar_present = True\n            with open(file, mode=\"r\", encoding=\"utf-8-sig\") as infile:\n                reader = csv.DictReader(infile)\n                for row in reader:\n                    row[\"service_id\"] = sanitise_id(row[\"service_id\"])\n                    if (int(day) in range(int(row[\"start_date\"]), int(row[\"end_date\"]))) and (\n                        int(row[day_of_the_week]) == 1\n                    ):\n                        services.append(row[\"service_id\"])\n    if not services:\n        if calendar_present:\n            raise RuntimeError(\"The date you have selected yielded no services\")\n        else:\n            raise RuntimeError(\"Calendar was not found with the GTFS\")\n    return services\n</code></pre>"},{"location":"reference/genet/input/gtfs_reader/#genet.input.gtfs_reader.sanitise_id","title":"<code>sanitise_id(_id)</code>","text":"Source code in <code>src/genet/input/gtfs_reader.py</code> <pre><code>def sanitise_id(_id: str):\n    return _id.replace(\" \", \"_\")\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/","title":"genet.input.matsim_reader","text":""},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.read_additional_attrib","title":"<code>read_additional_attrib(elem, force_long_form_attributes=False)</code>","text":"<p>Reads additional attributes dictionary from stream.</p> PARAMETER DESCRIPTION <code>elem</code> <p>Stream element for which additional attributes are to be read and updated.</p> <p> TYPE: <code>Element</code> </p> <code>force_long_form_attributes</code> <p>If True the additional attributes will be read into long form. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict</code> <p><code>elem</code> additional attributes.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def read_additional_attrib(elem: ET.Element, force_long_form_attributes: bool = False) -&gt; dict:\n    \"\"\"Reads additional attributes dictionary from stream.\n\n    Args:\n        elem (ET.Element): Stream element for which additional attributes are to be read and updated.\n        force_long_form_attributes (bool, optional):\n            If True the additional attributes will be read into long form. Defaults to False.\n\n    Returns:\n        dict: `elem` additional attributes.\n    \"\"\"\n    if force_long_form_attributes:\n        return _read_additional_attrib_to_long_form(elem)\n    else:\n        return _read_additional_attrib_to_short_form(elem)\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.read_link","title":"<code>read_link(elem, g, u, v, node_id_mapping, link_id_mapping, link_attribs)</code>","text":"<p>Adds link elem of the stream to the network</p> PARAMETER DESCRIPTION <code>elem</code> <p>Element of the stream.</p> <p> TYPE: <code>Element</code> </p> <code>g</code> <p>Network.</p> <p> TYPE: <code>MultiDiGraph</code> </p> <code>u</code> <p><code>from</code> node of the previous link.</p> <p> TYPE: <code>str</code> </p> <code>v</code> <p><code>to</code> node of the previous link.</p> <p> TYPE: <code>str</code> </p> <code>node_id_mapping</code> <p>Mapping from node IDs to S2 IDs.</p> <p> TYPE: <code>dict</code> </p> <code>link_id_mapping</code> <p>Mapping from link ID to node to and from IDs.</p> <p> TYPE: <code>dict</code> </p> <code>link_attribs</code> <p>link attributes of the previous link.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>tuple[MultiDiGraph, str, str, dict, dict]</code> <p>tuple[nx.MultiDiGraph, str, str, dict, dict]: Network with added link; <code>from</code> node ID of link; <code>to</code> node ID of link; <code>link_id_mapping</code> with mapping for the newly added link; found duplicated link IDs.</p> Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def read_link(\n    elem: ET.Element,\n    g: nx.MultiDiGraph,\n    u: str,\n    v: str,\n    node_id_mapping: dict,\n    link_id_mapping: dict,\n    link_attribs: dict,\n) -&gt; tuple[nx.MultiDiGraph, str, str, dict, dict]:\n    \"\"\"Adds link elem of the stream to the network\n\n    Args:\n        elem (ET.Element): Element of the stream.\n        g (nx.MultiDiGraph): Network.\n        u (str): `from` node of the previous link.\n        v (str): `to` node of the previous link.\n        node_id_mapping (dict): Mapping from node IDs to S2 IDs.\n        link_id_mapping (dict): Mapping from link ID to node to and from IDs.\n        link_attribs (dict): link attributes of the previous link.\n\n    Returns:\n        tuple[nx.MultiDiGraph, str, str, dict, dict]:\n            Network with added link;\n            `from` node ID of link;\n            `to` node ID of link;\n            `link_id_mapping` with mapping for the newly added link;\n            found duplicated link IDs.\n    \"\"\"\n\n    duplicated_link_id = {}\n\n    attribs = elem.attrib\n    attribs[\"s2_from\"] = node_id_mapping[attribs[\"from\"]]\n    attribs[\"s2_to\"] = node_id_mapping[attribs[\"to\"]]\n    attribs[\"modes\"] = set(attribs[\"modes\"].split(\",\"))\n\n    link_id, duplicated_link_id = unique_link_id(attribs[\"id\"], link_id_mapping)\n    attribs[\"id\"] = link_id\n    link_id_mapping[link_id] = {\"from\": attribs[\"from\"], \"to\": attribs[\"to\"]}\n\n    for key in [\"freespeed\", \"capacity\", \"permlanes\"]:\n        try:\n            attribs[key] = float(attribs[key])\n        except KeyError:\n            logging.warning(\n                \"Key: {} is not present in link: {}. This may lead to problems if using this\"\n                \"network with MATSim.\"\n            )\n\n    length = float(attribs[\"length\"])\n    del attribs[\"length\"]\n\n    u = attribs[\"from\"]\n    v = attribs[\"to\"]\n\n    if link_attribs:\n        if \"geometry\" in link_attribs:\n            if link_attribs[\"geometry\"]:\n                attribs[\"geometry\"] = spatial.decode_polyline_to_shapely_linestring(\n                    link_attribs[\"geometry\"]\n                )\n                del link_attribs[\"geometry\"]\n        if link_attribs:\n            attribs[\"attributes\"] = link_attribs\n\n    if g.has_edge(u, v):\n        link_id_mapping[link_id][\"multi_edge_idx\"] = len(g[u][v])\n    else:\n        link_id_mapping[link_id][\"multi_edge_idx\"] = 0\n    g.add_weighted_edges_from([(u, v, length)], weight=\"length\", **attribs)\n    return g, u, v, link_id_mapping, duplicated_link_id\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.read_network","title":"<code>read_network(network_path, transformer, force_long_form_attributes=False)</code>","text":"<p>Read MATSim network.</p> PARAMETER DESCRIPTION <code>network_path</code> <p>path to the network.xml file.</p> <p> TYPE: <code>str</code> </p> <code>transformer</code> <p>PyProj CRS Transformer to update the <code>elem</code> <code>x</code>/<code>y</code> coordinates to <code>lat</code>/<code>lon</code>.</p> <p> TYPE: <code>Transformer</code> </p> <code>force_long_form_attributes</code> <p>If True the additional attributes will be read into verbose format: <pre><code>    {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n</code></pre> where <code>attrib_value</code> is always a python string.</p> <p>If False, defaults to short-form: <pre><code>    {'additional_attrib': attrib_value}\n</code></pre> where the type of <code>attrib_value</code> is mapped to a python type using the declared java class.</p> <p>Note</p> <p>Network level attributes cannot be forced to be read into long form.</p> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[MultiDiGraph, dict, dict, dict, dict]</code> <p>tuple[nx.MultiDiGraph, dict, dict, dict, dict]: Representation of the multimodal network; MATSim node ID mapping: <code>{network node ID : s2 spatial ID}</code>; MATSIM link ID to node ID mapping: <code>{network link ID : {'from': from node ID, 'to': to node ID, 's2_from' : from node S2 spatial ID, 's2_to': to node S2 spatial ID}}</code> Network additional attribute dictionary.</p> Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def read_network(\n    network_path: str, transformer: Transformer, force_long_form_attributes: bool = False\n) -&gt; tuple[nx.MultiDiGraph, dict, dict, dict, dict]:\n    \"\"\"Read MATSim network.\n\n    Args:\n        network_path (str): path to the network.xml file.\n        transformer (Transformer): PyProj CRS Transformer to update the `elem` `x`/`y` coordinates to `lat`/`lon`.\n        force_long_form_attributes (bool, optional):\n            If True the additional attributes will be read into verbose format:\n            ```dict\n                {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n            ```\n            where `attrib_value` is always a python string.\n\n            If False, defaults to short-form:\n            ```python\n                {'additional_attrib': attrib_value}\n            ```\n            where the type of `attrib_value` is mapped to a python type using the declared java class.\n\n            !!! note\n                Network level attributes cannot be forced to be read into long form.\n\n            Defaults to False.\n\n    Returns:\n        tuple[nx.MultiDiGraph, dict, dict, dict, dict]:\n            Representation of the multimodal network;\n            MATSim node ID mapping: `{network node ID : s2 spatial ID}`;\n            MATSIM link ID to node ID mapping: `{network link ID : {'from': from node ID, 'to': to node ID, 's2_from' : from node S2 spatial ID, 's2_to': to node S2 spatial ID}}`\n            Network additional attribute dictionary.\n    \"\"\"\n    g = nx.MultiDiGraph()\n\n    network_attributes: dict = {}\n    node_id_mapping: dict = {}\n    node_attribs: dict = {}\n    link_id_mapping: dict = {}\n    link_attribs: dict = {}\n    duplicated_link_ids: dict = {}\n    duplicated_node_ids: dict = {}\n    u: Optional[str] = None\n    v: Optional[str] = None\n\n    elem_themes_for_additional_attributes = {\"network\", \"nodes\", \"links\"}\n    elem_type_for_additional_attributes = None\n\n    for event, elem in ET.iterparse(network_path, events=(\"start\", \"end\")):\n        if event == \"start\":\n            if elem.tag in elem_themes_for_additional_attributes:\n                elem_type_for_additional_attributes = elem.tag\n        elif event == \"end\":\n            if elem.tag == \"node\":\n                g, duplicated_node_id = read_node(\n                    elem, g, node_id_mapping, node_attribs, transformer\n                )\n                if duplicated_node_id:\n                    for key, val in duplicated_node_id.items():\n                        if key in duplicated_node_ids:\n                            duplicated_node_ids[key].append(val)\n                        else:\n                            duplicated_node_ids[key] = [val]\n                # reset node_attribs\n                node_attribs = {}\n            elif elem.tag == \"link\":\n                g, u, v, link_id_mapping, duplicated_link_id = read_link(\n                    elem, g, u, v, node_id_mapping, link_id_mapping, link_attribs\n                )\n                if duplicated_link_id:\n                    for key, val in duplicated_link_id.items():\n                        if key in duplicated_link_ids:\n                            duplicated_link_ids[key].append(val)\n                        else:\n                            duplicated_link_ids[key] = [val]\n                # reset link_attribs\n                link_attribs = {}\n            elif elem.tag == \"attribute\":\n                if elem_type_for_additional_attributes == \"links\":\n                    link_attribs = update_additional_attrib(\n                        elem, link_attribs, force_long_form_attributes\n                    )\n                elif elem_type_for_additional_attributes == \"network\":\n                    if force_long_form_attributes:\n                        logging.warning(\n                            \"Network-level additional attributes are always read into short form.\"\n                        )\n                    network_attributes = update_additional_attrib(\n                        elem, network_attributes, force_long_form_attributes=False\n                    )\n                elif elem_type_for_additional_attributes == \"nodes\":\n                    node_attribs = update_additional_attrib(\n                        elem, node_attribs, force_long_form_attributes\n                    )\n    return g, link_id_mapping, duplicated_node_ids, duplicated_link_ids, network_attributes\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.read_node","title":"<code>read_node(elem, g, node_id_mapping, node_attribs, transformer)</code>","text":"<p>Adds node elem of the stream to the network.</p> PARAMETER DESCRIPTION <code>elem</code> <p>Element of the stream.</p> <p> TYPE: <code>Element</code> </p> <code>g</code> <p>Network.</p> <p> TYPE: <code>MultiDiGraph</code> </p> <code>node_id_mapping</code> <p>Mapping from node IDs to S2 IDs.</p> <p> TYPE: <code>dict</code> </p> <code>node_attribs</code> <p>Node attributes to attach to the node in the network object.</p> <p> TYPE: <code>dict</code> </p> <code>transformer</code> <p>PyProj CRS Transformer to update the <code>elem</code> <code>x</code>/<code>y</code> coordinates to <code>lat</code>/<code>lon</code>.</p> <p> TYPE: <code>Transformer</code> </p> RETURNS DESCRIPTION <code>tuple[MultiDiGraph, dict]</code> <p>tuple[nx.MultiDiGraph, dict]: Network with added node; found duplicated node IDs.</p> Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def read_node(\n    elem: ET.Element,\n    g: nx.MultiDiGraph,\n    node_id_mapping: dict,\n    node_attribs: dict,\n    transformer: Transformer,\n) -&gt; tuple[nx.MultiDiGraph, dict]:\n    \"\"\"Adds node elem of the stream to the network.\n\n    Args:\n        elem (ET.Element): Element of the stream.\n        g (nx.MultiDiGraph): Network.\n        node_id_mapping (dict): Mapping from node IDs to S2 IDs.\n        node_attribs (dict): Node attributes to attach to the node in the network object.\n        transformer (Transformer): PyProj CRS Transformer to update the `elem` `x`/`y` coordinates to `lat`/`lon`.\n\n    Returns:\n        tuple[nx.MultiDiGraph, dict]: Network with added node; found duplicated node IDs.\n    \"\"\"\n    duplicated_node_id = {}\n    attribs = elem.attrib\n    attribs[\"x\"], attribs[\"y\"] = float(attribs[\"x\"]), float(attribs[\"y\"])\n\n    if \"z\" in attribs:\n        attribs[\"z\"] = float(attribs[\"z\"])\n\n    lon, lat = spatial.change_proj(attribs[\"x\"], attribs[\"y\"], transformer)\n    # ideally we would check if the transformer was created with always_xy=True and swap\n    # lat and long values if so, but there is no obvious way to interrogate the transformer\n    attribs[\"lon\"], attribs[\"lat\"] = lon, lat\n    attribs[\"s2_id\"] = spatial.generate_index_s2(lat, lon)\n\n    if node_attribs:\n        attribs[\"attributes\"] = node_attribs\n\n    node_id = attribs[\"id\"]\n    if node_id in node_id_mapping:\n        logging.warning(\n            \"This MATSim network has a node that is not unique: {}. Generating a new id would\"\n            \"be pointless as we don't know which links should be connected to this particular\"\n            \"node. The node will cease to exist and the first encountered node with this id\"\n            \"will be kept. Investigate the links connected to that node.\".format(node_id)\n        )\n        duplicated_node_id[node_id] = attribs\n    else:\n        node_id_mapping[node_id] = attribs[\"s2_id\"]\n        g.add_node(node_id, **attribs)\n    return g, duplicated_node_id\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.read_schedule","title":"<code>read_schedule(schedule_path, epsg, force_long_form_attributes=False)</code>","text":"<p>Read MATSim schedule.</p> PARAMETER DESCRIPTION <code>schedule_path</code> <p>Path to the <code>schedule.xml</code> file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Schedule projection CRS, e.g. <code>epsg:4326</code>.</p> <p> TYPE: <code>str</code> </p> <code>force_long_form_attributes</code> <p>If True the additional attributes will be read into verbose format: <pre><code>    {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n</code></pre> where <code>attrib_value</code> is always a python string.</p> <p>If False, defaults to short-form: <pre><code>    {'additional_attrib': attrib_value}\n</code></pre> where the type of <code>attrib_value</code> is mapped to a python type using the declared java class.</p> <p>Note</p> <p>Schedule level attributes cannot be forced to be read into long form.</p> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[list, dict, dict, dict]</code> <p>tuple[list, dict, dict, dict]: list of Service objects; Minimal transfer times between stops; Transit stop ID mapping; Schedule additional attributes.</p> Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def read_schedule(\n    schedule_path: str, epsg: str, force_long_form_attributes: bool = False\n) -&gt; tuple[list, dict, dict, dict]:\n    \"\"\"Read MATSim schedule.\n\n    Args:\n        schedule_path (str): Path to the `schedule.xml` file.\n        epsg (str): Schedule projection CRS, e.g. `epsg:4326`.\n        force_long_form_attributes (bool, optional):\n            If True the additional attributes will be read into verbose format:\n            ```dict\n                {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n            ```\n            where `attrib_value` is always a python string.\n\n            If False, defaults to short-form:\n            ```python\n                {'additional_attrib': attrib_value}\n            ```\n            where the type of `attrib_value` is mapped to a python type using the declared java class.\n\n            !!! note\n                Schedule level attributes cannot be forced to be read into long form.\n\n            Defaults to False.\n\n    Returns:\n        tuple[list, dict, dict, dict]:\n            list of Service objects;\n            Minimal transfer times between stops;\n            Transit stop ID mapping;\n            Schedule additional attributes.\n\n    \"\"\"\n    services = []\n    transformer = Transformer.from_proj(Proj(epsg), Proj(\"epsg:4326\"), always_xy=True)\n\n    def write_transitLinesTransitRoute(transitLine, transitRoutes, transportMode):\n        mode = transportMode[\"transportMode\"]\n        service_id = transitLine[\"transitLine_data\"][\"id\"]\n        service_routes = []\n        for transitRoute, transitRoute_val in transitRoutes.items():\n            stops = [\n                Stop(\n                    s[\"stop\"][\"refId\"],\n                    x=transit_stop_id_mapping[s[\"stop\"][\"refId\"]][\"x\"],\n                    y=transit_stop_id_mapping[s[\"stop\"][\"refId\"]][\"y\"],\n                    epsg=epsg,\n                    transformer=transformer,\n                )\n                for s in transitRoute_val[\"stops\"]\n            ]\n            for s in stops:\n                s.add_additional_attributes(transit_stop_id_mapping[s.id])\n\n            arrival_offsets = []\n            departure_offsets = []\n            await_departure = []\n            for stop in transitRoute_val[\"stops\"]:\n                if \"departureOffset\" not in stop[\"stop\"] and \"arrivalOffset\" not in stop[\"stop\"]:\n                    pass\n                elif \"departureOffset\" not in stop[\"stop\"]:\n                    arrival_offsets.append(stop[\"stop\"][\"arrivalOffset\"])\n                    departure_offsets.append(stop[\"stop\"][\"arrivalOffset\"])\n                elif \"arrivalOffset\" not in stop[\"stop\"]:\n                    arrival_offsets.append(stop[\"stop\"][\"departureOffset\"])\n                    departure_offsets.append(stop[\"stop\"][\"departureOffset\"])\n                else:\n                    arrival_offsets.append(stop[\"stop\"][\"arrivalOffset\"])\n                    departure_offsets.append(stop[\"stop\"][\"departureOffset\"])\n\n                if \"awaitDeparture\" in stop[\"stop\"]:\n                    await_departure.append(\n                        str(stop[\"stop\"][\"awaitDeparture\"]).lower() in [\"true\", \"1\"]\n                    )\n\n            route = [r_val[\"link\"][\"refId\"] for r_val in transitRoute_val[\"links\"]]\n\n            trips = {\"trip_id\": [], \"trip_departure_time\": [], \"vehicle_id\": []}\n            for dep in transitRoute_val[\"departure_list\"]:\n                trips[\"trip_id\"].append(dep[\"departure\"][\"id\"])\n                trips[\"trip_departure_time\"].append(dep[\"departure\"][\"departureTime\"])\n                trips[\"vehicle_id\"].append(dep[\"departure\"][\"vehicleRefId\"])\n\n            r = Route(\n                route_short_name=transitLine[\"transitLine_data\"][\"name\"],\n                mode=mode,\n                stops=stops,\n                network_links=route,\n                trips=trips,\n                arrival_offsets=arrival_offsets,\n                departure_offsets=departure_offsets,\n                id=transitRoute,\n                await_departure=await_departure,\n            )\n            if transitRoute_val[\"attributes\"]:\n                r.add_additional_attributes({\"attributes\": transitRoute_val[\"attributes\"]})\n            service_routes.append(r)\n        _service = Service(id=service_id, routes=service_routes)\n        if transitLine[\"attributes\"]:\n            _service.add_additional_attributes({\"attributes\": transitLine[\"attributes\"]})\n        services.append(_service)\n\n    transitLine: dict = {}\n    transitRoutes: dict = {}\n    transportMode: dict = {}\n    transit_stop_id_mapping: dict = {}\n    is_minimalTransferTimes = False\n\n    # {'stop_id_1': {'stop_id_2': 0.0}} seconds_to_transfer between stop_id_1 and stop_id_2\n    minimalTransferTimes: dict = {}\n\n    elem_themes_for_additional_attributes = {\n        \"transitSchedule\",\n        \"stopFacility\",\n        \"transitLine\",\n        \"transitRoute\",\n    }\n    elem_type_for_additional_attributes = None\n    schedule_attribs: dict = {}\n    # Track IDs through the stream\n    current_stop_id = None\n    current_route_id = None\n\n    # transitLines\n    for event, elem in ET.iterparse(schedule_path, events=(\"start\", \"end\")):\n        if event == \"start\":\n            if elem.tag in elem_themes_for_additional_attributes:\n                elem_type_for_additional_attributes = elem.tag\n\n            if elem.tag == \"stopFacility\":\n                attribs = elem.attrib\n                attribs[\"epsg\"] = epsg\n                attribs[\"x\"] = float(attribs[\"x\"])\n                attribs[\"y\"] = float(attribs[\"y\"])\n                if attribs[\"id\"] not in transit_stop_id_mapping:\n                    transit_stop_id_mapping[attribs[\"id\"]] = attribs\n                current_stop_id = attribs[\"id\"]\n\n            elif elem.tag == \"minimalTransferTimes\":\n                is_minimalTransferTimes = not is_minimalTransferTimes\n            elif elem.tag == \"relation\":\n                if is_minimalTransferTimes:\n                    attribs = elem.attrib\n                    minimalTransferTimes = dict_support.merge_complex_dictionaries(\n                        minimalTransferTimes,\n                        {attribs[\"fromStop\"]: {attribs[\"toStop\"]: float(attribs[\"transferTime\"])}},\n                    )\n            elif elem.tag == \"transitLine\":\n                if transitLine:\n                    write_transitLinesTransitRoute(transitLine, transitRoutes, transportMode)\n                transitLine = {\"transitLine_data\": elem.attrib, \"attributes\": {}}\n                transitRoutes = {}\n\n            elif elem.tag == \"transitRoute\":\n                transitRoutes[elem.attrib[\"id\"]] = {\n                    \"stops\": [],\n                    \"links\": [],\n                    \"departure_list\": [],\n                    \"attributes\": {},\n                }\n                current_route_id = elem.attrib[\"id\"]\n\n            # doesn't have any attribs\n            # if elem.tag == 'routeProfile':\n            #     routeProfile = {'routeProfile': elem.attrib}\n\n            elif elem.tag == \"stop\":\n                transitRoutes[current_route_id][\"stops\"].append({\"stop\": elem.attrib})\n\n            # doesn't have any attribs\n            # if elem.tag == 'route':\n            #     route = {'route': elem.attrib}\n\n            elif elem.tag == \"link\":\n                transitRoutes[current_route_id][\"links\"].append({\"link\": elem.attrib})\n\n            # doesn't have any attribs\n            # if elem.tag == 'departures':\n            #     departures = {'departures': elem.attrib}\n\n            elif elem.tag == \"departure\":\n                transitRoutes[current_route_id][\"departure_list\"].append({\"departure\": elem.attrib})\n\n        elif event == \"end\":\n            if elem.tag == \"attribute\":\n                if elem_type_for_additional_attributes == \"transitSchedule\":\n                    if force_long_form_attributes:\n                        logging.warning(\n                            \"Schedule-level additional attributes are always read into short form.\"\n                        )\n                    schedule_attribs = update_additional_attrib(elem, schedule_attribs)\n                elif elem_type_for_additional_attributes == \"stopFacility\":\n                    current_stop_data = transit_stop_id_mapping[current_stop_id]\n                    if \"attributes\" in current_stop_data:\n                        current_stop_data[\"attributes\"] = update_additional_attrib(\n                            elem,\n                            transit_stop_id_mapping[current_stop_id][\"attributes\"],\n                            force_long_form_attributes=force_long_form_attributes,\n                        )\n                    else:\n                        current_stop_data[\"attributes\"] = update_additional_attrib(\n                            elem, {}, force_long_form_attributes=force_long_form_attributes\n                        )\n                elif elem_type_for_additional_attributes == \"transitLine\":\n                    transitLine[\"attributes\"] = update_additional_attrib(\n                        elem,\n                        transitLine[\"attributes\"],\n                        force_long_form_attributes=force_long_form_attributes,\n                    )\n                elif elem_type_for_additional_attributes == \"transitRoute\":\n                    transitRoutes[current_route_id][\"attributes\"] = update_additional_attrib(\n                        elem,\n                        transitRoutes[current_route_id][\"attributes\"],\n                        force_long_form_attributes=force_long_form_attributes,\n                    )\n            elif elem.tag == \"transportMode\":\n                transportMode = {\"transportMode\": elem.text}\n\n    # add the last one\n    write_transitLinesTransitRoute(transitLine, transitRoutes, transportMode)\n\n    return services, minimalTransferTimes, transit_stop_id_mapping, schedule_attribs\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.read_vehicles","title":"<code>read_vehicles(vehicles_path)</code>","text":"Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def read_vehicles(vehicles_path):\n    vehicles = {}\n    vehicle_types = {}\n    v = {\"capacity\": {}}\n    read_capacity = False\n    for event, elem in ET.iterparse(vehicles_path):\n        tag = re.sub(r\"{http://www\\.matsim\\.org/files/dtd}\", \"\", elem.tag)\n        if tag == \"vehicle\":\n            _id = elem.attrib.pop(\"id\")\n            vehicles[_id] = elem.attrib\n            read_capacity = False\n        elif tag == \"vehicleType\":\n            vehicle_types[elem.attrib[\"id\"]] = v\n            v = {\"capacity\": {}}\n            read_capacity = False\n        elif tag == \"capacity\":\n            read_capacity = True\n        elif read_capacity:\n            v[tag] = elem.attrib\n        else:\n            v[\"capacity\"][tag] = elem.attrib\n    return vehicles, vehicle_types\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.unique_link_id","title":"<code>unique_link_id(link_id, link_id_mapping)</code>","text":"Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def unique_link_id(link_id, link_id_mapping):\n    duplicated_link_id = {}\n    if link_id in link_id_mapping:\n        old_link_id = link_id\n        logging.warning(\"This MATSim network has a link that is not unique: {}\".format(old_link_id))\n        i = 1\n        link_id = old_link_id\n        while link_id in link_id_mapping:\n            link_id = \"{}_{}\".format(old_link_id, i)\n            i += 1\n        logging.warning(\"Generated new link_id: {}\".format(link_id))\n        duplicated_link_id[old_link_id] = link_id\n    return link_id, duplicated_link_id\n</code></pre>"},{"location":"reference/genet/input/matsim_reader/#genet.input.matsim_reader.update_additional_attrib","title":"<code>update_additional_attrib(elem, attribs, force_long_form_attributes=False)</code>","text":"<p>Updates additional attributes dictionary with data read from stream.</p> PARAMETER DESCRIPTION <code>elem</code> <p>Stream element for which additional attributes are to be read and updated.</p> <p> TYPE: <code>Element</code> </p> <code>attribs</code> <p>Current additional attributes.</p> <p> TYPE: <code>dict</code> </p> <code>force_long_form_attributes</code> <p>If True the additional attributes will be read into long form. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated <code>attribs</code> dictionary with <code>elem</code> additional attributes.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/input/matsim_reader.py</code> <pre><code>def update_additional_attrib(\n    elem: ET.Element, attribs: dict, force_long_form_attributes: bool = False\n) -&gt; dict:\n    \"\"\"Updates additional attributes dictionary with data read from stream.\n\n    Args:\n        elem (ET.Element): Stream element for which additional attributes are to be read and updated.\n        attribs (dict): Current additional attributes.\n        force_long_form_attributes (bool, optional):\n            If True the additional attributes will be read into long form. Defaults to False.\n\n    Returns:\n        dict: Updated `attribs` dictionary with `elem` additional attributes.\n    \"\"\"\n    attribs[elem.attrib[\"name\"]] = read_additional_attrib(\n        elem, force_long_form_attributes=force_long_form_attributes\n    )\n    return attribs\n</code></pre>"},{"location":"reference/genet/input/osm_reader/","title":"genet.input.osm_reader","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.MANDATORY_PATH_TAGS","title":"<code>MANDATORY_PATH_TAGS = {'oneway', 'highway', 'junction', 'route'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.Config","title":"<code>Config(path)</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def __init__(self, path):\n    with open(path) as c:\n        self.config = yaml.load(c, Loader=yaml.FullLoader)\n\n    self.USEFUL_TAGS_NODE = self.config[\"OSM_TAGS\"][\"USEFUL_TAGS_NODE\"]\n    self.USEFUL_TAGS_PATH = self.config[\"OSM_TAGS\"][\"USEFUL_TAGS_PATH\"]\n\n    self.MODE_INDICATORS = self.config[\"MODES\"][\"MODE_INDICATORS\"]\n    self.DEFAULT_OSM_TAG_VALUE = self.config[\"MODES\"][\"DEFAULT_OSM_TAG_VALUE\"]\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.Config.DEFAULT_OSM_TAG_VALUE","title":"<code>DEFAULT_OSM_TAG_VALUE = self.config['MODES']['DEFAULT_OSM_TAG_VALUE']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.Config.MODE_INDICATORS","title":"<code>MODE_INDICATORS = self.config['MODES']['MODE_INDICATORS']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.Config.USEFUL_TAGS_NODE","title":"<code>USEFUL_TAGS_NODE = self.config['OSM_TAGS']['USEFUL_TAGS_NODE']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.Config.USEFUL_TAGS_PATH","title":"<code>USEFUL_TAGS_PATH = self.config['OSM_TAGS']['USEFUL_TAGS_PATH']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.Config.config","title":"<code>config = yaml.load(c, Loader=yaml.FullLoader)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.OSMHandler","title":"<code>OSMHandler(config)</code>","text":"<p>               Bases: <code>SimpleHandler</code></p> Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def __init__(self, config):\n    super(OSMHandler, self).__init__()\n    self.elements = []\n    self.config = config\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.OSMHandler.config","title":"<code>config = config</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.OSMHandler.elements","title":"<code>elements = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.OSMHandler.node","title":"<code>node(entity)</code>","text":"<p>Parses OSM data for an OSM 'node' into dict format.</p> <p>Uses USEFUL_TAGS_PATH specified via genet config to ignore irrelevant tags</p> Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def node(self, entity):\n    \"\"\"Parses OSM data for an OSM 'node' into dict format.\n\n    Uses USEFUL_TAGS_PATH specified via genet config to ignore irrelevant tags\n    \"\"\"\n    json_data = {\n        \"type\": \"node\",\n        \"id\": str(entity.id),\n        \"version\": entity.version,\n        \"timestamp\": entity.timestamp,\n        \"uid\": entity.uid,\n        \"tags\": {},\n        \"lon\": entity.location.lon,\n        \"lat\": entity.location.lat,\n    }\n    for useful_tag in self.config.USEFUL_TAGS_NODE:\n        value = entity.tags.get(useful_tag)\n        if value:\n            json_data[\"tags\"][useful_tag] = value\n    self.elements.append(json_data)\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.OSMHandler.way","title":"<code>way(entity)</code>","text":"<p>Parses OSM data for an OSM 'way' into dict format.</p> <p>Uses USEFUL_TAGS_PATH specified via genet config to ignore irrelevant tags</p> Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def way(self, entity):\n    \"\"\"Parses OSM data for an OSM 'way' into dict format.\n\n    Uses USEFUL_TAGS_PATH specified via genet config to ignore irrelevant tags\n    \"\"\"\n    json_data = {\n        \"type\": \"way\",\n        \"id\": str(entity.id),\n        \"version\": entity.version,\n        \"timestamp\": entity.timestamp,\n        \"uid\": entity.uid,\n        \"tags\": {},\n        \"nodes\": tuple(str(n) for n in entity.nodes),\n    }\n    for useful_tag in set(self.config.USEFUL_TAGS_PATH) | MANDATORY_PATH_TAGS:\n        value = entity.tags.get(useful_tag)\n        if value:\n            json_data[\"tags\"][useful_tag] = value\n    self.elements.append(json_data)\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.assume_travel_modes","title":"<code>assume_travel_modes(edge, config)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def assume_travel_modes(edge, config):\n    modes = []\n    for key, val in edge.items():\n        if key in config.MODE_INDICATORS:\n            if isinstance(config.MODE_INDICATORS[key], dict):\n                if val == \"road\":\n                    edge[\"highway\"] = \"unclassified\"\n                    modes.extend(config.MODE_INDICATORS[\"highway\"][\"unclassified\"])\n                elif val not in [\"construction\", \"proposed\"]:\n                    if val in config.MODE_INDICATORS[key]:\n                        modes.extend(config.MODE_INDICATORS[key][val])\n                    else:\n                        logging.debug(\n                            \"Value {} for key {} does not have a mode assignment\".format(val, key)\n                        )\n            else:\n                modes.extend(config.MODE_INDICATORS[key])\n        elif key not in [\"osmid\", \"nodes\", \"name\", \"maxspeed\", \"oneway\", \"lanes\", \"access\"]:\n            logging.debug(\"Key {} is not present in OSM mode definitions\".format(key))\n    return list(set(modes))\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.create_s2_indexed_osm_graph","title":"<code>create_s2_indexed_osm_graph(response_jsons, config, num_processes, bidirectional)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def create_s2_indexed_osm_graph(response_jsons, config, num_processes, bidirectional):\n    logging.info(\"Creating networkx graph from OSM data\")\n\n    elements = []\n    for response_json in response_jsons:\n        elements.extend(response_json[\"elements\"])\n\n    logging.info(\"OSM: Extract Nodes and Paths from OSM data\")\n    nodes = {}\n    paths = {}\n    for osm_data in response_jsons:\n        nodes_temp, paths_temp = osmnx_customised.parse_osm_nodes_paths(osm_data, config)\n        for key, value in nodes_temp.items():\n            nodes[key] = value\n        for key, value in paths_temp.items():\n            paths[key] = value\n\n    logging.info(\"OSM: Add each OSM way (aka, path) to the OSM graph\")\n    edges = parallel.multiprocess_wrap(\n        data=paths,\n        split=parallel.split_dict,\n        apply=osmnx_customised.return_edges,\n        combine=parallel.combine_list,\n        processes=num_processes,\n        config=config,\n        bidirectional=bidirectional,\n    )\n\n    return nodes, edges\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.file_converter","title":"<code>file_converter(osm_file, config)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def file_converter(osm_file, config):\n    osmium_read_handler = OSMHandler(config)\n    osmium_read_handler.apply_file(osm_file)\n    return [{\"elements\": osmium_read_handler.elements}]\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.find_matsim_link_values","title":"<code>find_matsim_link_values(edge_data, config)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def find_matsim_link_values(edge_data, config):\n    matsim_vals = {}\n    if (set(edge_data.keys()) | set(MATSIM_JOSM_DEFAULTS.keys())) or (\"highway\" in edge_data):\n        if \"highway\" in edge_data:\n            # highway is the one allowed 'nested' osm tag, the values of the tags are flattened in MATSIM_JOSM_DEFAULTS\n            if edge_data[\"highway\"] in MATSIM_JOSM_DEFAULTS:\n                matsim_vals = MATSIM_JOSM_DEFAULTS[edge_data[\"highway\"]]\n            else:\n                logging.info(\"{} is highway but has no value defaults\".format(edge_data[\"highway\"]))\n        else:\n            for key in edge_data.keys():\n                if key in MATSIM_JOSM_DEFAULTS:\n                    # checks the non nested tags, at the time of writing that is just railway\n                    matsim_vals = MATSIM_JOSM_DEFAULTS[key]\n\n    if not matsim_vals:\n        # check the modes as a last resort and look at the defaults in the config\n        for mode in edge_data[\"modes\"]:\n            # if more than one mode, there may have been a capacity already assumed for the link, go for the values\n            # with bigger capacity\n            if \"capacity\" in matsim_vals:\n                if mode in config.DEFAULT_OSM_TAG_VALUE:\n                    new_matsim_vals = MATSIM_JOSM_DEFAULTS[config.DEFAULT_OSM_TAG_VALUE[mode]]\n                    # decide which one is better on lane capacity\n                    if float(new_matsim_vals[\"capacity\"]) &gt; float(matsim_vals[\"capacity\"]):\n                        matsim_vals = new_matsim_vals\n            elif mode in config.DEFAULT_OSM_TAG_VALUE:\n                matsim_vals = MATSIM_JOSM_DEFAULTS[config.DEFAULT_OSM_TAG_VALUE[mode]]\n            else:\n                logging.info(\n                    \"Mode {} not in the config's DEFAULT_OSM_TAG_VALUE's. \"\n                    \"Defaulting to {}\".format(mode, \"secondary\")\n                )\n                matsim_vals = MATSIM_JOSM_DEFAULTS[\"secondary\"]\n    return matsim_vals\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.generate_graph_edges","title":"<code>generate_graph_edges(edges, reindexing_dict, nodes_and_attributes, config_path)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def generate_graph_edges(edges, reindexing_dict, nodes_and_attributes, config_path):\n    edges_attributes = []\n    for edge, attribs in edges:\n        u, v = str(edge[0]), str(edge[1])\n        if u in reindexing_dict:\n            u = reindexing_dict[u]\n        if v in reindexing_dict:\n            v = reindexing_dict[v]\n\n        link_attributes = find_matsim_link_values(attribs, Config(config_path)).copy()\n        if \"lanes\" in attribs:\n            try:\n                # overwrite the default matsim josm values\n                link_attributes[\"permlanes\"] = ceil(float(attribs[\"lanes\"]))\n            except Exception as e:\n                logging.warning(\n                    f'Reading lanes from OSM resulted in {type(e)} with message \"{e}\".'\n                    f'Found at edge {edge}. Defaulting to permlanes={link_attributes[\"permlanes\"]}'\n                )\n        # compute link-wide capacity\n        link_attributes[\"capacity\"] = link_attributes[\"permlanes\"] * link_attributes[\"capacity\"]\n\n        link_attributes[\"oneway\"] = \"1\"\n        link_attributes[\"modes\"] = attribs[\"modes\"]\n        link_attributes[\"from\"] = u\n        link_attributes[\"to\"] = v\n        link_attributes[\"s2_from\"] = nodes_and_attributes[u][\"s2_id\"]\n        link_attributes[\"s2_to\"] = nodes_and_attributes[v][\"s2_id\"]\n        link_attributes[\"length\"] = spatial.distance_between_s2cellids(\n            link_attributes[\"s2_from\"], link_attributes[\"s2_to\"]\n        )\n        # the rest of the keys are osm attributes\n        link_attributes[\"attributes\"] = {}\n        for key, val in attribs.items():\n            if key not in link_attributes:\n                link_attributes[\"attributes\"][f\"osm:way:{key}\"] = val\n        edges_attributes.append(link_attributes)\n    return edges_attributes\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.generate_graph_nodes","title":"<code>generate_graph_nodes(nodes, epsg)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def generate_graph_nodes(nodes, epsg):\n    input_to_output_transformer = Transformer.from_crs(\"epsg:4326\", epsg, always_xy=True)\n    nodes_and_attributes = {}\n    for node_id, attribs in nodes.items():\n        x, y = spatial.change_proj(attribs[\"x\"], attribs[\"y\"], input_to_output_transformer)\n        nodes_and_attributes[str(node_id)] = {\n            \"id\": str(node_id),\n            \"x\": x,\n            \"y\": y,\n            \"lat\": attribs[\"y\"],\n            \"lon\": attribs[\"x\"],\n            \"s2_id\": attribs[\"s2id\"],\n        }\n    return nodes_and_attributes\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.generate_osm_graph_edges_from_file","title":"<code>generate_osm_graph_edges_from_file(osm_file, config, num_processes)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def generate_osm_graph_edges_from_file(osm_file, config, num_processes):\n    logging.info(\"Building OSM graph from file {}\".format(osm_file))\n    response_jsons = file_converter(osm_file, config)\n    nodes, edges = create_s2_indexed_osm_graph(\n        response_jsons, config, num_processes, bidirectional=False\n    )\n    logging.info(\"Created OSM edges\")\n    return nodes, edges\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.read_node","title":"<code>read_node(entity)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def read_node(entity):\n    json_data = {\n        \"type\": \"node\",\n        \"id\": entity.id,\n        \"version\": entity.version,\n        \"timestamp\": entity.timestamp,\n        \"uid\": entity.uid,\n        \"tags\": entity.tags,\n        \"lon\": entity.lon,\n        \"lat\": entity.lat,\n    }\n    return json_data\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.read_relation","title":"<code>read_relation(entity)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def read_relation(entity):\n    json_data = {\n        \"type\": \"relation\",\n        \"id\": entity.id,\n        \"version\": entity.version,\n        \"timestamp\": entity.timestamp,\n        \"uid\": entity.uid,\n        \"tags\": entity.tags,\n        \"members\": entity.members,\n    }\n    return json_data\n</code></pre>"},{"location":"reference/genet/input/osm_reader/#genet.input.osm_reader.read_way","title":"<code>read_way(entity)</code>","text":"Source code in <code>src/genet/input/osm_reader.py</code> <pre><code>def read_way(entity):\n    json_data = {\n        \"type\": \"way\",\n        \"id\": entity.id,\n        \"version\": entity.version,\n        \"timestamp\": entity.timestamp,\n        \"uid\": entity.uid,\n        \"tags\": entity.tags,\n        \"nodes\": entity.nodes,\n    }\n    return json_data\n</code></pre>"},{"location":"reference/genet/input/osmnx_customised/","title":"genet.input.osmnx_customised","text":""},{"location":"reference/genet/input/osmnx_customised/#genet.input.osmnx_customised.get_node","title":"<code>get_node(element, config)</code>","text":"<p>Convert an OSM node element into the format for a networkx node.</p> PARAMETER DESCRIPTION <code>element</code> <p>An OSM node element.</p> <p> TYPE: <code>dict</code> </p> <code>config</code> <p>OSM reader configuration.</p> <p> TYPE: <code>Config</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>OSM node element converted to the networkx node format.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/input/osmnx_customised.py</code> <pre><code>def get_node(element: dict, config: \"osm_reader.Config\") -&gt; dict:\n    \"\"\"Convert an OSM node element into the format for a networkx node.\n\n    Args:\n        element (dict): An OSM node element.\n        config (genet.input.osm_reader.Config): OSM reader configuration.\n\n    Returns:\n        dict: OSM node element converted to the networkx node format.\n    \"\"\"\n\n    node = {}\n    node[\"osmid\"] = element[\"id\"]\n    node[\"s2id\"] = spatial.generate_index_s2(lat=element[\"lat\"], lng=element[\"lon\"])\n    node[\"x\"], node[\"y\"] = element[\"lon\"], element[\"lat\"]\n    if \"tags\" in element:\n        for useful_tag in config.USEFUL_TAGS_NODE:\n            if useful_tag in element[\"tags\"]:\n                node[useful_tag] = element[\"tags\"][useful_tag]\n    return node\n</code></pre>"},{"location":"reference/genet/input/osmnx_customised/#genet.input.osmnx_customised.get_path","title":"<code>get_path(element, config)</code>","text":"<p>Convert an OSM way element into the format for a networkx graph path.</p> <p>Function from osmnx, adding our own spin on this - need extra tags</p> PARAMETER DESCRIPTION <code>element</code> <p>An OSM way element.</p> <p> TYPE: <code>dict</code> </p> <code>config</code> <p>OSM reader configuration.</p> <p> TYPE: <code>Config</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>OSM way element converted to the networkx graph path format.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/input/osmnx_customised.py</code> <pre><code>def get_path(element: dict, config: \"osm_reader.Config\") -&gt; dict:\n    \"\"\"Convert an OSM way element into the format for a networkx graph path.\n\n    Function from osmnx, adding our own spin on this - need extra tags\n\n    Args:\n        element (dict): An OSM way element.\n        config (genet.input.osm_reader.Config): OSM reader configuration.\n\n    Returns:\n        dict: OSM way element converted to the networkx graph path format.\n    \"\"\"\n\n    path = {}\n    path[\"osmid\"] = element[\"id\"]\n\n    # remove any consecutive duplicate elements in the list of nodes\n    grouped_list = groupby(element[\"nodes\"])\n    path[\"nodes\"] = [group[0] for group in grouped_list]\n\n    if \"tags\" in element:\n        for useful_tag in config.USEFUL_TAGS_PATH:\n            if useful_tag in element[\"tags\"]:\n                path[useful_tag] = element[\"tags\"][useful_tag]\n\n    path[\"modes\"] = osm_reader.assume_travel_modes(path, config)\n    return path\n</code></pre>"},{"location":"reference/genet/input/osmnx_customised/#genet.input.osmnx_customised.parse_osm_nodes_paths","title":"<code>parse_osm_nodes_paths(osm_data, config)</code>","text":"<p>Construct dicts of nodes and paths with key=osmid and value=dict of attributes.</p> <p>Function from osmnx. Adding our own spin on this - need extra tags</p> PARAMETER DESCRIPTION <code>osm_data</code> <p>JSON response from from the Overpass API</p> <p> TYPE: <code>dict</code> </p> <code>config</code> <p>OSM reader configuration.</p> <p> TYPE: <code>Config</code> </p> RETURNS DESCRIPTION <code>tuple[dict, dict]</code> <p>tuple[dict, dict]: Nodes; Paths.</p> Source code in <code>src/genet/input/osmnx_customised.py</code> <pre><code>def parse_osm_nodes_paths(osm_data: dict, config: \"osm_reader.Config\") -&gt; tuple[dict, dict]:\n    \"\"\"Construct dicts of nodes and paths with key=osmid and value=dict of attributes.\n\n    Function from osmnx. Adding our own spin on this - need extra tags\n\n    Args:\n        osm_data (dict): JSON response from from the Overpass API\n        config (genet.input.osm_reader.Config): OSM reader configuration.\n\n    Returns:\n        tuple[dict, dict]: Nodes; Paths.\n    \"\"\"\n\n    nodes = {}\n    paths = {}\n    for element in osm_data[\"elements\"]:\n        if element[\"type\"] == \"node\":\n            key = element[\"id\"]\n            nodes[key] = get_node(element, config)\n        elif element[\"type\"] == \"way\":  # osm calls network paths 'ways'\n            key = element[\"id\"]\n            path = get_path(element, config)\n            if path[\"modes\"]:\n                # only proceed with edges that have found a mode (that's why it's important to define them in\n                # MODE_INDICATORS in the config\n                paths[key] = path\n\n    return nodes, paths\n</code></pre>"},{"location":"reference/genet/input/osmnx_customised/#genet.input.osmnx_customised.return_edge","title":"<code>return_edge(data, one_way)</code>","text":"Source code in <code>src/genet/input/osmnx_customised.py</code> <pre><code>def return_edge(data, one_way):\n    # extract the ordered list of nodes from this path element, then delete it\n    # so we don't add it as an attribute to the edge later\n    path_nodes = data[\"nodes\"]\n    del data[\"nodes\"]\n\n    # set the oneway attribute to the passed-in value, to make it consistent\n    # True/False values\n    data[\"oneway\"] = one_way\n\n    # zip together the path nodes so you get tuples like (0,1), (1,2), (2,3)\n    # and so on\n    path_edges = list(zip(path_nodes[:-1], path_nodes[1:]))\n\n    # if the path is NOT one-way\n    if not one_way:\n        # reverse the direction of each edge and add this path going the\n        # opposite direction\n        path_edges_opposite_direction = [(v, u) for u, v in path_edges]\n        path_edges.extend(path_edges_opposite_direction)\n    return path_edges\n</code></pre>"},{"location":"reference/genet/input/osmnx_customised/#genet.input.osmnx_customised.return_edges","title":"<code>return_edges(paths, config, bidirectional=False)</code>","text":"<p>Makes graph edges from osm paths.</p> PARAMETER DESCRIPTION <code>paths</code> <p>OSM paths, e.g. <code>{osm_way_id: {osmid: x, nodes:[a,b], osmtags: vals}}</code></p> <p> TYPE: <code>dict</code> </p> <code>config</code> <p>OSM reader configuration object.</p> <p> TYPE: <code>Config</code> </p> <code>bidirectional</code> <p>If True, reads all paths as both ways. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/input/osmnx_customised.py</code> <pre><code>def return_edges(paths: dict, config: \"osm_reader.Config\", bidirectional: bool = False):\n    \"\"\"Makes graph edges from osm paths.\n\n    Args:\n        paths (dict): OSM paths, e.g. `{osm_way_id: {osmid: x, nodes:[a,b], osmtags: vals}}`\n        config (genet.input.osm_reader.Config): OSM reader configuration object.\n        bidirectional (bool, optional): If True, reads all paths as both ways. Defaults to False.\n    \"\"\"\n\n    def extract_osm_data(data, es):\n        d = {}\n        for tag in (set(config.USEFUL_TAGS_PATH) | {\"osmid\", \"modes\"}) - {\"oneway\"}:\n            if tag in data:\n                d[tag] = data[tag]\n        return [(es[i], d) for i in range(len(es))]\n\n    # the list of values OSM uses in its 'oneway' tag to denote True\n    osm_oneway_values = [\"yes\", \"true\", \"1\", \"-1\", \"reverse\"]\n\n    edges = []\n\n    for data in paths.values():\n        # if this path is tagged as one-way and if it is not a walking network,\n        # then we'll add the path in one direction only\n        if (\"oneway\" in data and data[\"oneway\"] in osm_oneway_values) and not bidirectional:\n            if data[\"oneway\"] in [\"-1\", \"reverse\"]:\n                # paths with a one-way value of -1 are one-way, but in the\n                # reverse direction of the nodes' order, see osm documentation\n                data[\"nodes\"] = list(reversed(data[\"nodes\"]))\n            # add this path (in only one direction) to the graph\n            es = return_edge(data, one_way=True)\n            edges.extend(extract_osm_data(data, es))\n\n        elif (\"junction\" in data and data[\"junction\"] == \"roundabout\") and not bidirectional:\n            # roundabout are also oneway but not tagged as is\n            es = return_edge(data, one_way=True)\n            edges.extend(extract_osm_data(data, es))\n\n        # else, this path is not tagged as one-way or it is a walking network\n        # (you can walk both directions on a one-way street)\n        else:\n            # add this path (in both directions) to the graph and set its\n            # 'oneway' attribute to False. if this is a walking network, this\n            # may very well be a one-way street (as cars/bikes go), but in a\n            # walking-only network it is a bi-directional edge\n            es = return_edge(data, one_way=False)\n            edges.extend(extract_osm_data(data, es))\n\n    return edges\n</code></pre>"},{"location":"reference/genet/input/read/","title":"genet.input.read","text":""},{"location":"reference/genet/input/read/#genet.input.read.read_csv","title":"<code>read_csv(path_to_network_nodes, path_to_network_links, epsg)</code>","text":"<p>Reads CSV data into a genet.Network object</p> PARAMETER DESCRIPTION <code>path_to_network_nodes</code> <p>CSV file describing nodes. Should at least include columns: - id: unique ID for the node - x: spatial coordinate in given epsg - y: spatial coordinate in given epsg</p> <p> TYPE: <code>str</code> </p> <code>path_to_network_links</code> <p>CSV file describing links. Should at least include columns: - from - source Node ID - to - target Node ID</p> <p>Optional columns, but strongly encouraged: - id - unique ID for link - length - link length in metres - freespeed - meter/seconds speed - capacity - vehicles/hour - permlanes - number of lanes - modes - set of modes</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NetworkSchemaError</code> <p>Network nodes must have at least the columns specified above.</p> RETURNS DESCRIPTION <code>Network</code> <p>core.Network: GeNet network object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_csv(path_to_network_nodes: str, path_to_network_links: str, epsg: str) -&gt; core.Network:\n    \"\"\"Reads CSV data into a genet.Network object\n\n    Args:\n        path_to_network_nodes (str):\n            CSV file describing nodes.\n            Should at least include columns:\n            - id: unique ID for the node\n            - x: spatial coordinate in given epsg\n            - y: spatial coordinate in given epsg\n\n        path_to_network_links (str):\n            CSV file describing links.\n            Should at least include columns:\n            - from - source Node ID\n            - to - target Node ID\n\n            Optional columns, but strongly encouraged:\n            - id - unique ID for link\n            - length - link length in metres\n            - freespeed - meter/seconds speed\n            - capacity - vehicles/hour\n            - permlanes - number of lanes\n            - modes - set of modes\n\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n\n    Raises:\n        NetworkSchemaError: Network nodes must have at least the columns specified above.\n\n    Returns:\n        core.Network: GeNet network object.\n    \"\"\"\n    logging.info(f\"Reading nodes from {path_to_network_nodes}\")\n    df_nodes = pd.read_csv(path_to_network_nodes)\n    if {\"index\", \"id\"}.issubset(set(df_nodes.columns)):\n        df_nodes = df_nodes.drop(\"index\", axis=1)\n    elif \"id\" not in df_nodes.columns:\n        raise NetworkSchemaError(\n            \"Expected `id` column in the nodes.csv is missing. This need to be the IDs to which \"\n            \"links.csv refers to in `from` and `to` columns.\"\n        )\n    df_nodes[\"id\"] = df_nodes[\"id\"].astype(int).astype(str)\n    df_nodes = df_nodes.set_index(\"id\", drop=False)\n    try:\n        df_nodes = df_nodes.drop(\"geometry\", axis=1)\n    except KeyError:\n        pass\n\n    logging.info(f\"Reading links from {path_to_network_nodes}\")\n    df_links = pd.read_csv(path_to_network_links)\n    if {\"index\", \"id\"}.issubset(set(df_links.columns)):\n        df_links = df_links.drop(\"index\", axis=1)\n    elif \"id\" not in df_links.columns:\n        if \"index\" in df_links.columns:\n            if not df_links[\"index\"].duplicated().any():\n                df_links[\"id\"] = df_links[\"index\"]\n            else:\n                df_links = df_links.drop(\"index\", axis=1)\n        else:\n            df_links[\"id\"] = range(len(df_links))\n\n    df_links[\"id\"] = df_links[\"id\"].astype(int).astype(str)\n    df_links[\"from\"] = df_links[\"from\"].astype(int).astype(str)\n    df_links[\"to\"] = df_links[\"to\"].astype(int).astype(str)\n    df_links = df_links.set_index(\"id\", drop=False)\n    # recover encoded geometry\n    try:\n        df_links[\"geometry\"] = df_links[\"geometry\"].apply(\n            lambda x: spatial.decode_polyline_to_shapely_linestring(x)\n        )\n    except KeyError:\n        pass\n    df_links[\"attributes\"] = _literal_eval_col(df_links[\"attributes\"])\n    df_links[\"modes\"] = _literal_eval_col(df_links[\"modes\"])\n\n    n = core.Network(epsg=epsg)\n    n.add_nodes(df_nodes.T.to_dict())\n    n.add_links(df_links.T.to_dict())\n    n.change_log = change_log.ChangeLog()\n    return n\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_geojson_network","title":"<code>read_geojson_network(nodes_path, links_path, epsg)</code>","text":"<p>Reads Network graph from JSON file.</p> PARAMETER DESCRIPTION <code>nodes_path</code> <p>Path to geojson network nodes file.</p> <p> TYPE: <code>str</code> </p> <code>links_path</code> <p>Path to geojson network links file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>core.Network: GeNet network object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_geojson_network(nodes_path: str, links_path: str, epsg: str) -&gt; core.Network:\n    \"\"\"Reads Network graph from JSON file.\n\n    Args:\n        nodes_path (str): Path to geojson network nodes file.\n        links_path (str): Path to geojson network links file.\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n\n    Returns:\n        core.Network: GeNet network object.\n    \"\"\"\n    logging.info(f\"Reading Network nodes from {nodes_path}\")\n    nodes = gpd.read_file(nodes_path)\n    nodes = nodes.drop(\"geometry\", axis=1)\n    nodes[\"id\"] = nodes[\"id\"].astype(int).astype(str)\n    nodes = nodes.set_index(\"id\", drop=False)\n    if \"index\" in nodes.columns:\n        nodes = nodes.drop(\"index\", axis=1)\n\n    logging.info(f\"Reading Network links from {links_path}\")\n    links = gpd.read_file(links_path).to_crs(epsg)\n    links[\"modes\"] = links[\"modes\"].apply(lambda x: set(x.split(\",\")))\n    links[\"id\"] = links[\"id\"].astype(int).astype(str)\n    links = links.set_index(\"id\", drop=False)\n    if \"index\" in links.columns:\n        links = links.drop(\"index\", axis=1)\n\n    n = core.Network(epsg=epsg)\n    n.add_nodes(nodes.T.to_dict())\n    n.add_links(links.T.to_dict())\n    n.change_log = change_log.ChangeLog()\n    return n\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_gtfs","title":"<code>read_gtfs(path, day, epsg=None)</code>","text":"<p>Reads schedule from GTFS.</p> <p>The resulting services will not have network routes. Input GTFS is assumed to be using the 'epsg:4326' projection.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to GTFS folder or a zip file.</p> <p> TYPE: <code>str</code> </p> <code>day</code> <p>'YYYYMMDD' to use from the GTFS.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the output Schedule, e.g. 'epsg:27700'. If not provided, defaults to 'epsg:4326'. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Schedule</code> <p>schedule_elements.Schedule: GeNet schedule.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_gtfs(path: str, day: str, epsg: Optional[str] = None) -&gt; schedule_elements.Schedule:\n    \"\"\"Reads schedule from GTFS.\n\n    The resulting services will not have network routes.\n    Input GTFS is assumed to be using the 'epsg:4326' projection.\n\n    Args:\n        path (str): Path to GTFS folder or a zip file.\n        day (str): 'YYYYMMDD' to use from the GTFS.\n        epsg (Optional[str], optional):\n            Projection for the output Schedule, e.g. 'epsg:27700'.\n            If not provided, defaults to 'epsg:4326'.\n            Defaults to None.\n\n    Returns:\n        schedule_elements.Schedule: GeNet schedule.\n    \"\"\"\n    logging.info(f\"Reading GTFS from {path}\")\n    schedule_graph = gtfs_reader.read_gtfs_to_schedule_graph(path, day)\n    s = schedule_elements.Schedule(epsg=\"epsg:4326\", _graph=schedule_graph)\n    if epsg is not None:\n        s.reproject(new_epsg=epsg)\n    return s\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_json","title":"<code>read_json(network_path, epsg, schedule_path=None)</code>","text":"<p>Reads Network and, if passed, Schedule JSON files in to a genet.Network.</p> PARAMETER DESCRIPTION <code>network_path</code> <p>path to JSON network file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> <code>schedule_path</code> <p>Path to json schedule file. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>core.Network: GeNet network object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_json(network_path: str, epsg: str, schedule_path: Optional[str] = None) -&gt; core.Network:\n    \"\"\"Reads Network and, if passed, Schedule JSON files in to a genet.Network.\n\n    Args:\n        network_path (str): path to JSON network file.\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n        schedule_path (Optional[str], optional): Path to json schedule file. Defaults to None.\n\n    Returns:\n        core.Network: GeNet network object.\n    \"\"\"\n    n = read_json_network(network_path, epsg)\n    if schedule_path is not None:\n        n.schedule = read_json_schedule(schedule_path, epsg)\n    return n\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_json_network","title":"<code>read_json_network(network_path, epsg)</code>","text":"<p>Reads network JSON file in to a genet.Network.</p> PARAMETER DESCRIPTION <code>network_path</code> <p>path to JSON or GeoJSON network file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>core.Network: GeNet network object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_json_network(network_path: str, epsg: str) -&gt; core.Network:\n    \"\"\"Reads network JSON file in to a genet.Network.\n\n    Args:\n        network_path (str): path to JSON or GeoJSON network file.\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n\n    Returns:\n        core.Network: GeNet network object.\n    \"\"\"\n    logging.info(f\"Reading Network from {network_path}\")\n    with open(network_path) as json_file:\n        json_data = json.load(json_file)\n    for _, data in json_data[\"nodes\"].items():\n        try:\n            del data[\"geometry\"]\n        except KeyError:\n            pass\n\n    for _, data in json_data[\"links\"].items():\n        try:\n            data[\"geometry\"] = spatial.decode_polyline_to_shapely_linestring(data[\"geometry\"])\n        except KeyError:\n            pass\n        try:\n            data[\"modes\"] = set(data[\"modes\"].split(\",\"))\n        except KeyError:\n            pass\n\n    n = core.Network(epsg=epsg)\n    n.add_nodes(json_data[\"nodes\"])\n    n.add_links(json_data[\"links\"])\n    n.change_log = change_log.ChangeLog()\n    return n\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_json_schedule","title":"<code>read_json_schedule(schedule_path, epsg)</code>","text":"<p>Reads Schedule from a JSON file.</p> PARAMETER DESCRIPTION <code>schedule_path</code> <p>path to JSON or GeoJSON schedule file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Schedule</code> <p>schedule_elements.Schedule: GeNet schedule object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_json_schedule(schedule_path: str, epsg: str) -&gt; schedule_elements.Schedule:\n    \"\"\"Reads Schedule from a JSON file.\n\n    Args:\n        schedule_path (str): path to JSON or GeoJSON schedule file.\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n\n    Returns:\n        schedule_elements.Schedule: GeNet schedule object.\n    \"\"\"\n    logging.info(f\"Reading Schedule from {schedule_path}\")\n    with open(schedule_path) as json_file:\n        json_data = json.load(json_file)\n\n    for service_id, service_data in json_data[\"schedule\"][\"services\"].items():\n        routes = []\n        for route_id, route_data in service_data[\"routes\"].items():\n            stops = route_data.pop(\"ordered_stops\")\n            route_data[\"stops\"] = [\n                schedule_elements.Stop(**json_data[\"schedule\"][\"stops\"][stop], epsg=epsg)\n                for stop in stops\n            ]\n            routes.append(schedule_elements.Route(**route_data))\n        service_data[\"routes\"] = routes\n\n    services = [\n        schedule_elements.Service(**service_data)\n        for service_id, service_data in json_data[\"schedule\"][\"services\"].items()\n    ]\n\n    s = schedule_elements.Schedule(\n        epsg=epsg,\n        services=services,\n        vehicles=json_data[\"vehicles\"][\"vehicles\"],\n        vehicle_types=json_data[\"vehicles\"][\"vehicle_types\"],\n    )\n    if \"minimal_transfer_times\" in json_data[\"schedule\"]:\n        s.minimal_transfer_times = json_data[\"schedule\"][\"minimal_transfer_times\"]\n    return s\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_matsim","title":"<code>read_matsim(path_to_network, epsg, path_to_schedule=None, path_to_vehicles=None, force_long_form_attributes=False)</code>","text":"<p>Creates a GeNet Network from MATSim's network.xml and (optionally) schedule.xml and vehicles.xml files.</p> <p>If given, schedule and vehicles files will be used to create a <code>genet.Schedule</code> object, which will be added to the generated <code>genet.Network</code> object. the schedule file needs to be given if the vehicles file is given.</p> PARAMETER DESCRIPTION <code>path_to_network</code> <p>Path to MATSim's <code>network.xml</code> file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> <code>path_to_schedule</code> <p>Path to MATSim's <code>schedule.xml</code> file. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>path_to_vehicles</code> <p>Path to MATSim's <code>vehicles.xml</code> file,. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>force_long_form_attributes</code> <p>If True the additional attributes will be read into verbose format: <pre><code>    {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n</code></pre> where <code>attrib_value</code> is always a python string.</p> <p>If False, defaults to short-form: <pre><code>    {'additional_attrib': attrib_value}\n</code></pre> where the type of <code>attrib_value</code> is mapped to a python type using the declared java class.</p> <p>Note</p> <p>Network level attributes cannot be forced to be read into long form.</p> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>core.Network: GeNet Network object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_matsim(\n    path_to_network: str,\n    epsg: str,\n    path_to_schedule: Optional[str] = None,\n    path_to_vehicles: Optional[str] = None,\n    force_long_form_attributes: bool = False,\n) -&gt; core.Network:\n    \"\"\"Creates a GeNet Network from MATSim's network.xml and (optionally) schedule.xml and vehicles.xml files.\n\n    If given, schedule and vehicles files will be used to create a `genet.Schedule` object, which will be added to the generated `genet.Network` object.\n    the schedule file needs to be given if the vehicles file is given.\n\n    Args:\n        path_to_network (str): Path to MATSim's `network.xml` file.\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n        path_to_schedule (Optional[str], optional): Path to MATSim's `schedule.xml` file. Defaults to None.\n        path_to_vehicles (Optional[str], optional): Path to MATSim's `vehicles.xml` file,. Defaults to None.\n        force_long_form_attributes (bool, optional):\n            If True the additional attributes will be read into verbose format:\n            ```dict\n                {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n            ```\n            where `attrib_value` is always a python string.\n\n            If False, defaults to short-form:\n            ```python\n                {'additional_attrib': attrib_value}\n            ```\n            where the type of `attrib_value` is mapped to a python type using the declared java class.\n\n            !!! note\n                Network level attributes cannot be forced to be read into long form.\n\n            Defaults to False.\n\n    Returns:\n        core.Network: GeNet Network object.\n    \"\"\"\n    n = read_matsim_network(\n        path_to_network=path_to_network,\n        epsg=epsg,\n        force_long_form_attributes=force_long_form_attributes,\n    )\n    if path_to_schedule:\n        n.schedule = read_matsim_schedule(\n            path_to_schedule=path_to_schedule,\n            path_to_vehicles=path_to_vehicles,\n            epsg=epsg,\n            force_long_form_attributes=force_long_form_attributes,\n        )\n    return n\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_matsim_network","title":"<code>read_matsim_network(path_to_network, epsg, force_long_form_attributes=False)</code>","text":"<p>Reads MATSim's network.xml to genet.Network object.</p> PARAMETER DESCRIPTION <code>path_to_network</code> <p>Path to MATSim's <code>network.xml</code> file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> <code>force_long_form_attributes</code> <p>If True the additional attributes will be read into verbose format: <pre><code>    {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n</code></pre> where <code>attrib_value</code> is always a python string.</p> <p>If False, defaults to short-form: <pre><code>    {'additional_attrib': attrib_value}\n</code></pre> where the type of <code>attrib_value</code> is mapped to a python type using the declared java class.</p> <p>Note</p> <p>Network level attributes cannot be forced to be read into long form.</p> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>core.Network: GeNet Network object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_matsim_network(\n    path_to_network: str, epsg: str, force_long_form_attributes: bool = False\n) -&gt; core.Network:\n    \"\"\"Reads MATSim's network.xml to genet.Network object.\n\n    Args:\n        path_to_network (str): Path to MATSim's `network.xml` file.\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n        force_long_form_attributes (bool, optional):\n            If True the additional attributes will be read into verbose format:\n            ```dict\n                {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n            ```\n            where `attrib_value` is always a python string.\n\n            If False, defaults to short-form:\n            ```python\n                {'additional_attrib': attrib_value}\n            ```\n            where the type of `attrib_value` is mapped to a python type using the declared java class.\n\n            !!! note\n                Network level attributes cannot be forced to be read into long form.\n\n            Defaults to False.\n\n    Returns:\n        core.Network: GeNet Network object.\n    \"\"\"\n    n = core.Network(epsg=epsg)\n    (n.graph, n.link_id_mapping, duplicated_nodes, duplicated_links, network_attributes) = (\n        matsim_reader.read_network(\n            path_to_network, n.transformer, force_long_form_attributes=force_long_form_attributes\n        )\n    )\n    n.attributes = dict_support.merge_complex_dictionaries(n.attributes, network_attributes)\n    n.graph.graph[\"crs\"] = n.epsg\n\n    for node_id, duplicated_node_attribs in duplicated_nodes.items():\n        for duplicated_node_attrib in duplicated_node_attribs:\n            n.change_log.remove(\n                object_type=\"node\", object_id=node_id, object_attributes=duplicated_node_attrib\n            )\n    for link_id, reindexed_duplicated_links in duplicated_links.items():\n        for duplicated_link in reindexed_duplicated_links:\n            n.change_log.modify(\n                object_type=\"link\",\n                old_id=link_id,\n                old_attributes=n.link(duplicated_link),\n                new_id=duplicated_link,\n                new_attributes=n.link(duplicated_link),\n            )\n    return n\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_matsim_road_pricing","title":"<code>read_matsim_road_pricing(path_to_file)</code>","text":"<p>TODO: implement</p> PARAMETER DESCRIPTION <code>path_to_file</code> <p>path to MATSim's road_pricing.xml file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Toll</code> <p>genet.Toll: or other if applicable though not yet implemented (eg distance or area tolling)</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_matsim_road_pricing(path_to_file: str) -&gt; \"genet.use.road_pricing.Toll\":\n    \"\"\"TODO: implement\n\n    Args:\n        path_to_file (str): path to MATSim's road_pricing.xml file\n\n    Returns:\n        genet.Toll: or other if applicable though not yet implemented (eg distance or area tolling)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_matsim_schedule","title":"<code>read_matsim_schedule(path_to_schedule, epsg, path_to_vehicles=None, force_long_form_attributes=False)</code>","text":"<p>Reads MATSim's schedule.xml (and possibly vehicles.xml) to genet.Schedule object.</p> PARAMETER DESCRIPTION <code>path_to_schedule</code> <p>Path to MATSim's <code>schedule.xml</code> file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection for the network, e.g. 'epsg:27700'.</p> <p> TYPE: <code>str</code> </p> <code>path_to_vehicles</code> <p>Path to MATSim's <code>vehicles.xml</code> file,. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>force_long_form_attributes</code> <p>If True the additional attributes will be read into verbose format: <pre><code>    {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n</code></pre> where <code>attrib_value</code> is always a python string.</p> <p>If False, defaults to short-form: <pre><code>    {'additional_attrib': attrib_value}\n</code></pre> where the type of <code>attrib_value</code> is mapped to a python type using the declared java class.</p> <p>Note</p> <p>Network level attributes cannot be forced to be read into long form.</p> <p>Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Schedule</code> <p>schedule_elements.Schedule: GeNet Schedule object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_matsim_schedule(\n    path_to_schedule: str,\n    epsg: str,\n    path_to_vehicles: Optional[str] = None,\n    force_long_form_attributes: bool = False,\n) -&gt; schedule_elements.Schedule:\n    \"\"\"Reads MATSim's schedule.xml (and possibly vehicles.xml) to genet.Schedule object.\n\n    Args:\n        path_to_schedule (str): Path to MATSim's `schedule.xml` file.\n        epsg (str): Projection for the network, e.g. 'epsg:27700'.\n        path_to_vehicles (Optional[str], optional): Path to MATSim's `vehicles.xml` file,. Defaults to None.\n        force_long_form_attributes (bool, optional):\n            If True the additional attributes will be read into verbose format:\n            ```dict\n                {'additional_attrib': {'name': 'additional_attrib', 'class': 'java.lang.String', 'text': attrib_value}}\n            ```\n            where `attrib_value` is always a python string.\n\n            If False, defaults to short-form:\n            ```python\n                {'additional_attrib': attrib_value}\n            ```\n            where the type of `attrib_value` is mapped to a python type using the declared java class.\n\n            !!! note\n                Network level attributes cannot be forced to be read into long form.\n\n            Defaults to False.\n\n    Returns:\n        schedule_elements.Schedule: GeNet Schedule object.\n    \"\"\"\n    (services, minimal_transfer_times, transit_stop_id_mapping, schedule_attributes) = (\n        matsim_reader.read_schedule(\n            path_to_schedule, epsg, force_long_form_attributes=force_long_form_attributes\n        )\n    )\n    if path_to_vehicles:\n        vehicles, vehicle_types = matsim_reader.read_vehicles(path_to_vehicles)\n        matsim_schedule = schedule_elements.Schedule(\n            services=services, epsg=epsg, vehicles=vehicles, vehicle_types=vehicle_types\n        )\n    else:\n        matsim_schedule = schedule_elements.Schedule(services=services, epsg=epsg)\n    matsim_schedule.minimal_transfer_times = minimal_transfer_times\n\n    extra_stops = {\n        stop: transit_stop_id_mapping[stop]\n        for stop in set(transit_stop_id_mapping) - set(matsim_schedule.graph().nodes())\n    }\n    for k in extra_stops.keys():\n        extra_stops[k] = schedule_elements.Stop(**extra_stops[k]).__dict__\n        extra_stops[k][\"routes\"] = set()\n        extra_stops[k][\"services\"] = set()\n    matsim_schedule._graph.add_nodes_from(extra_stops)\n    nx.set_node_attributes(matsim_schedule._graph, extra_stops)\n    matsim_schedule.attributes = dict_support.merge_complex_dictionaries(\n        matsim_schedule.attributes, schedule_attributes\n    )\n    return matsim_schedule\n</code></pre>"},{"location":"reference/genet/input/read/#genet.input.read.read_osm","title":"<code>read_osm(osm_file_path, osm_read_config, num_processes=1, epsg='epsg:4326')</code>","text":"<p>Reads OSM data into a graph of the Network object.</p> PARAMETER DESCRIPTION <code>osm_file_path</code> <p>path to .osm or .osm.pbf file</p> <p> TYPE: <code>str</code> </p> <code>osm_read_config</code> <p>Path to config file, which informs e.g., which highway types to read (in case of road network) and what modes to assign to them. See configs folder in genet for examples.</p> <p> TYPE: <code>str</code> </p> <code>num_processes</code> <p>Number of processes to split parallelisable operations across. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>epsg</code> <p>Projection for the output Network, e.g. 'epsg:27700'. Defaults to \"epsg:4326\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'epsg:4326'</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>core.Network: GeNet network object.</p> Source code in <code>src/genet/input/read.py</code> <pre><code>def read_osm(\n    osm_file_path: str, osm_read_config: str, num_processes: int = 1, epsg: str = \"epsg:4326\"\n) -&gt; core.Network:\n    \"\"\"Reads OSM data into a graph of the Network object.\n\n    Args:\n        osm_file_path (str): path to .osm or .osm.pbf file\n        osm_read_config (str):\n            Path to config file, which informs e.g., which highway types to read (in case of road network) and what modes to assign to them.\n            See configs folder in genet for examples.\n        num_processes (int, optional): Number of processes to split parallelisable operations across. Defaults to 1.\n        epsg (Optional[str], optional):\n            Projection for the output Network, e.g. 'epsg:27700'.\n            Defaults to \"epsg:4326\".\n\n    Returns:\n        core.Network: GeNet network object.\n    \"\"\"\n\n    config = osm_reader.Config(osm_read_config)\n    n = core.Network(epsg)\n    nodes, edges = osm_reader.generate_osm_graph_edges_from_file(\n        osm_file_path, config, num_processes\n    )\n\n    nodes_and_attributes = parallel.multiprocess_wrap(\n        data=nodes,\n        split=parallel.split_dict,\n        apply=osm_reader.generate_graph_nodes,\n        combine=parallel.combine_dict,\n        epsg=epsg,\n        processes=num_processes,\n    )\n    reindexing_dict, nodes_and_attributes = n.add_nodes(\n        nodes_and_attributes, ignore_change_log=True\n    )\n\n    edges_attributes = parallel.multiprocess_wrap(\n        data=edges,\n        split=parallel.split_list,\n        apply=osm_reader.generate_graph_edges,\n        combine=parallel.combine_list,\n        reindexing_dict=reindexing_dict,\n        nodes_and_attributes=nodes_and_attributes,\n        config_path=osm_read_config,\n        processes=num_processes,\n    )\n    n.add_edges(edges_attributes, ignore_change_log=True)\n\n    logging.info(\"Deleting isolated nodes which have no edges.\")\n    n.remove_nodes(list(nx.isolates(n.graph)))\n    return n\n</code></pre>"},{"location":"reference/genet/max_stable_set/","title":"genet.max_stable_set","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet","title":"<code>ChangeSet(max_stable_set, df_route_data)</code>","text":"<p>Record of network and schedule changes needed for a solved max stable set</p> Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def __init__(self, max_stable_set, df_route_data):\n    self.routes = set(df_route_data.index)\n    self.services = {\n        max_stable_set.pt_graph.graph[\"route_to_service_map\"][r_id] for r_id in self.routes\n    }\n    self.other_routes_in_service = {\n        r_id\n        for s_id in self.services\n        for r_id in max_stable_set.pt_graph.graph[\"service_to_route_map\"][s_id]\n    } - self.routes\n\n    self.new_links = self.new_network_links(max_stable_set)\n    self.new_nodes = self.new_network_nodes(max_stable_set)\n    self.df_route_data = self.update_df_route_data(df_route_data, max_stable_set)\n    self.additional_links_modes = self.generate_additional_links_modes(max_stable_set)\n    self.new_stops = self.schedule_stops(max_stable_set)\n    self.new_pt_edges = self.schedule_edges(max_stable_set)\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.additional_links_modes","title":"<code>additional_links_modes = self.generate_additional_links_modes(max_stable_set)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.df_route_data","title":"<code>df_route_data = self.update_df_route_data(df_route_data, max_stable_set)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.new_links","title":"<code>new_links = self.new_network_links(max_stable_set)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.new_nodes","title":"<code>new_nodes = self.new_network_nodes(max_stable_set)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.new_pt_edges","title":"<code>new_pt_edges = self.schedule_edges(max_stable_set)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.new_stops","title":"<code>new_stops = self.schedule_stops(max_stable_set)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.other_routes_in_service","title":"<code>other_routes_in_service = {r_id for s_id in self.services for r_id in max_stable_set.pt_graph.graph['service_to_route_map'][s_id]} - self.routes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.routes","title":"<code>routes = set(df_route_data.index)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.services","title":"<code>services = {max_stable_set.pt_graph.graph['route_to_service_map'][r_id] for r_id in self.routes}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.generate_additional_links_modes","title":"<code>generate_additional_links_modes(max_stable_set)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def generate_additional_links_modes(self, max_stable_set):\n    link_ids = {\n        link_id\n        for route_list in self.df_route_data[\"network_links\"].values\n        for link_id in route_list\n    }\n    links = max_stable_set.network_spatial_tree.links.copy()\n    links = links.loc[links[\"link_id\"].isin(link_ids), [\"link_id\", \"modes\"]]\n    links[\"modes\"] = links[\"modes\"].apply(lambda x: set(x) | max_stable_set.service_modes)\n    return links.set_index(\"link_id\").T.to_dict()\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.new_network_links","title":"<code>new_network_links(max_stable_set)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def new_network_links(self, max_stable_set):\n    # generate data needed for the network to add artificial links following a partially viable max stable set\n    return max_stable_set.artificial_links\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.new_network_nodes","title":"<code>new_network_nodes(max_stable_set)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def new_network_nodes(self, max_stable_set):\n    # generate data needed for the network to add artificial nodes following a partially viable max stable set\n    return {\n        s: {\n            k: v\n            for k, v in max_stable_set.pt_graph.nodes[s].items()\n            if k not in [\"routes\", \"services\", \"additional_attributes\", \"epsg\"]\n        }\n        for s in max_stable_set.unsolved_stops\n    }\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.schedule_edges","title":"<code>schedule_edges(max_stable_set)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def schedule_edges(self, max_stable_set):\n    map = max_stable_set.stops_to_artificial_stops_map()\n    new_pt_edges = [\n        (\n            map[u],\n            map[v],\n            {\n                \"routes\": data[\"routes\"] &amp; self.routes,\n                \"services\": data[\"services\"] &amp; self.services,\n            },\n        )\n        for u, v, data in list(max_stable_set.pt_graph.edges(data=True))\n    ]\n    return new_pt_edges\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.schedule_stops","title":"<code>schedule_stops(max_stable_set)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def schedule_stops(self, max_stable_set):\n    # generate data needed for the network to add artificial stops and\n    new_stops = deepcopy(max_stable_set.artificial_stops)\n    for stop, data in new_stops.items():\n        data[\"routes\"] = self.routes\n        data[\"services\"] = self.services\n    return new_stops\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.ChangeSet.update_df_route_data","title":"<code>update_df_route_data(df_route_data, max_stable_set)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def update_df_route_data(self, df_route_data, max_stable_set):\n    # update stops and generate routed paths\n    df_route_data.loc[:, \"network_links\"] = df_route_data.loc[:, \"ordered_stops\"].apply(\n        lambda x: max_stable_set.routed_path(x)\n    )\n    _map = max_stable_set.stops_to_artificial_stops_map()\n    df_route_data.loc[:, \"ordered_stops\"] = df_route_data.loc[:, \"ordered_stops\"].map(\n        lambda x: [_map[stop] for stop in x]\n    )\n    return df_route_data\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet","title":"<code>MaxStableSet(pt_graph, network_spatial_tree, modes, distance_threshold=30, step_size=10)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def __init__(self, pt_graph, network_spatial_tree, modes, distance_threshold=30, step_size=10):\n    self.service_modes = modes\n    self.distance_threshold = distance_threshold\n    self.step_size = step_size\n    self.network_spatial_tree = network_spatial_tree\n    self.pt_graph = pt_graph\n    _gdf = spatial_output.generate_geodataframes(pt_graph)\n    self.stops, self.pt_edges = _gdf[\"nodes\"].to_crs(\"epsg:4326\"), _gdf[\"links\"].to_crs(\n        \"epsg:4326\"\n    )\n    self.edges = self.pt_edges.loc[:, [\"u\", \"v\", \"geometry\"]].copy()\n    self.nodes = self.find_closest_links()\n    if self.nodes.empty or len(set(self.nodes[\"id\"])) == 1:\n        logging.info(\n            \"The problem did not find closest links for enough stops. If partial solution is allowed,\"\n            \"the stops will not be snapped and the routes will be entirely artificial.\"\n        )\n        self.is_partial = True\n        self.problem_graph = nx.DiGraph()\n    else:\n        self.is_partial = False\n        self.problem_graph = self.generate_problem_graph()\n    if not self.is_viable():\n        self.is_partial = self.is_partially_viable()\n        if self.is_partial:\n            logging.warning(\"This Maximum Stable Set Problem is partially viable.\")\n        else:\n            raise InvalidMaxStableSetProblem(\n                \"This Maximum Stable Set Problem has at least one completely connected\"\n                \"catchment and cannot proceed to the solver.\"\n            )\n\n    self.solution = {}\n    self.artificial_stops = {}\n    self.artificial_links = {}\n    self.unsolved_stops = set()\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.artificial_links","title":"<code>artificial_links = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.artificial_stops","title":"<code>artificial_stops = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.distance_threshold","title":"<code>distance_threshold = distance_threshold</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.edges","title":"<code>edges = self.pt_edges.loc[:, ['u', 'v', 'geometry']].copy()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.is_partial","title":"<code>is_partial = True</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.network_spatial_tree","title":"<code>network_spatial_tree = network_spatial_tree</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.nodes","title":"<code>nodes = self.find_closest_links()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.problem_graph","title":"<code>problem_graph = nx.DiGraph()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.pt_graph","title":"<code>pt_graph = pt_graph</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.service_modes","title":"<code>service_modes = modes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.solution","title":"<code>solution = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.step_size","title":"<code>step_size = step_size</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.unsolved_stops","title":"<code>unsolved_stops = set()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.all_stops_have_nearest_links","title":"<code>all_stops_have_nearest_links()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def all_stops_have_nearest_links(self):\n    return not bool(self.stops_missing_nearest_links())\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.all_stops_solved","title":"<code>all_stops_solved()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def all_stops_solved(self):\n    return not bool(self.unsolved_stops)\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.cast_catchment","title":"<code>cast_catchment(df_stops, distance)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def cast_catchment(self, df_stops, distance):\n    return self.network_spatial_tree.closest_links(\n        gdf_points=df_stops, distance_radius=distance\n    ).dropna()\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.fill_in_solution_artificially","title":"<code>fill_in_solution_artificially()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def fill_in_solution_artificially(self):\n    # generate unsnapped stops\n    self.solution = {\n        **self.solution,\n        **{s: self._generate_artificial_link(s, s) for s in self.unsolved_stops},\n    }\n    self.artificial_stops = {\n        **self.artificial_stops,\n        **{\n            f\"{s}.link:{self._generate_artificial_link(s,s)}\": {\n                **self.pt_graph.nodes[s],\n                **{\n                    \"linkRefId\": self._generate_artificial_link(s, s),\n                    \"stop_id\": s,\n                    \"id\": f\"{s}.link:{self._generate_artificial_link(s,s)}\",\n                },\n            }\n            for s in self.unsolved_stops\n        },\n    }\n\n    # fill in the blanks with generated stop-links and\n    if \"shortest_path\" in self.pt_edges.columns:\n        missing_linkref_u_mask = self.pt_edges[\"linkRefId_u\"].isna()\n        self.pt_edges.loc[missing_linkref_u_mask, \"linkRefId_u\"] = self.pt_edges.loc[\n            missing_linkref_u_mask, \"u\"\n        ].map(self.solution)\n        missing_linkref_v_mask = self.pt_edges[\"linkRefId_v\"].isna()\n        self.pt_edges.loc[missing_linkref_v_mask, \"linkRefId_v\"] = self.pt_edges.loc[\n            missing_linkref_v_mask, \"v\"\n        ].map(self.solution)\n        missing_shortest_path_mask = self.pt_edges[\"shortest_path\"].isna()\n        self.pt_edges.loc[missing_shortest_path_mask, \"shortest_path\"] = self.pt_edges.loc[\n            missing_shortest_path_mask\n        ].apply(\n            lambda x: self._generate_artificial_path(\n                from_link=x[\"linkRefId_u\"], to_link=x[\"linkRefId_v\"]\n            ),\n            axis=1,\n        )\n    else:\n        logging.warning(\n            \"Solution is being artificially filled in before the edges were routed. If your problem is\"\n            \"partial, this will result in gaps in routed paths.\"\n        )\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.find_closest_links","title":"<code>find_closest_links()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def find_closest_links(self):\n    # increase distance by step size until all stops have closest links or reached threshold\n    distance = self.step_size\n    nodes = self.cast_catchment(\n        df_stops=self.stops.loc[:, [\"id\", \"geometry\"]].copy(), distance=distance\n    )\n    nodes[\"catchment\"] = distance\n    stops = set(self.stops[\"id\"])\n    while (set(nodes.index) != stops) and (distance &lt; self.distance_threshold):\n        distance += self.step_size\n        _df = self.cast_catchment(\n            df_stops=self.stops.loc[\n                self.stops[\"id\"].isin(stops - set(nodes.index)), [\"id\", \"geometry\"]\n            ].copy(),\n            distance=distance,\n        )\n        _df[\"catchment\"] = distance\n        nodes = pd.concat([nodes, _df])\n    return nodes[~nodes[\"link_id\"].str.match(\"artificial\")]\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.generate_problem_graph","title":"<code>generate_problem_graph()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def generate_problem_graph(self):\n    # build the problem graph\n    # build up the nodes, edges and shortest path lengths (will be used to compute weight coefficient later on)\n    self.nodes.loc[:, \"problem_nodes\"] = (\n        self.nodes.loc[:, \"id\"] + \".link:\" + self.nodes.loc[:, \"link_id\"]\n    )\n    self.edges = self.edges.merge(\n        self.nodes[[\"id\", \"link_id\", \"problem_nodes\"]].rename(\n            columns={\"link_id\": \"link_id_u\", \"problem_nodes\": \"problem_nodes_u\"}\n        ),\n        left_on=\"u\",\n        right_on=\"id\",\n    )\n    self.edges = self.edges.merge(\n        self.nodes[[\"id\", \"link_id\", \"problem_nodes\"]].rename(\n            columns={\"link_id\": \"link_id_v\", \"problem_nodes\": \"problem_nodes_v\"}\n        ),\n        left_on=\"v\",\n        right_on=\"id\",\n    )\n    self.edges = self.network_spatial_tree.shortest_path_lengths(\n        df_pt_edges=self.edges, from_col=\"link_id_u\", to_col=\"link_id_v\", weight=\"length\"\n    )\n\n    # build the problem graph\n    problem_graph = nx.DiGraph()\n    problem_nodes = self.nodes.set_index(\"problem_nodes\").T.to_dict()\n    problem_graph.add_nodes_from(problem_nodes)\n    path_length_components = pd.concat(\n        [\n            self.edges[\"path_lengths\"]\n            .dropna()\n            .groupby(self.edges[f\"problem_nodes_{component}\"])\n            .mean()\n            .to_frame(f\"path_lengths_{component}\")\n            for component in [\"u\", \"v\"]\n        ],\n        axis=1,\n    )\n    path_length_coeff = (1 / path_length_components.mean(axis=1, skipna=True)).to_dict()\n    nx.set_node_attributes(problem_graph, problem_nodes)\n    nx.set_node_attributes(problem_graph, path_length_coeff, \"coeff\")\n\n    problem_edges = self.edges.loc[self.edges[\"path_lengths\"].isna(), :]\n    problem_graph.add_edges_from(\n        zip(problem_edges[\"problem_nodes_u\"], problem_edges[\"problem_nodes_v\"])\n    )\n    # connect all catchment pools\n    [\n        problem_graph.add_edges_from(itertools.combinations(group[\"problem_nodes\"], 2))\n        for name, group in self.nodes.groupby(\"id\")\n    ]\n\n    nodes_without_paths = set(problem_graph.nodes()) - set(\n        graph_operations.extract_on_attributes(\n            problem_graph.nodes(data=True), conditions={\"coeff\": has_attrib}\n        )\n    )\n    problem_graph.remove_nodes_from(nodes_without_paths)\n    return problem_graph\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.has_a_completely_connected_catchment","title":"<code>has_a_completely_connected_catchment()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def has_a_completely_connected_catchment(self):\n    stop_id_groups = self.nodes.groupby(\"id\")\n    for u, v in self.pt_graph.edges():\n        u_group = None\n        v_group = None\n        if u in stop_id_groups.groups:\n            u_group = stop_id_groups.get_group(u)\n        if v in stop_id_groups.groups:\n            v_group = stop_id_groups.get_group(v)\n        if (u_group is not None) and (v_group is not None):\n            node_degrees = [self.in_out_degree(n) for n in u_group[\"problem_nodes\"]]\n            node_degrees += [self.in_out_degree(n) for n in v_group[\"problem_nodes\"]]\n            total_nodes = len(u_group) + len(v_group)\n            if all([node_degree &gt;= total_nodes - 1 for node_degree in node_degrees]):\n                logging.warning(\n                    f\"Two stops: {u} and {v} are completely connected, suggesting that one or more stops has \"\n                    f\"found no viable network links within the specified threshold\"\n                )\n                return True\n    return False\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.in_out_degree","title":"<code>in_out_degree(node)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def in_out_degree(self, node):\n    _out = self.problem_graph.out_degree(node)\n    _in = self.problem_graph.in_degree(node)\n    try:\n        return _out + _in\n    except TypeError:\n        if not isinstance(_out, int):\n            _out = 0\n        if not isinstance(_in, int):\n            _in = 0\n        return _in + _out\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.is_partially_viable","title":"<code>is_partially_viable()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def is_partially_viable(self):\n    # just the catchments are not all completely connected to one another\n    return not self.has_a_completely_connected_catchment()\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.is_viable","title":"<code>is_viable()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def is_viable(self):\n    # all stops have closest links to snap to (catchments)\n    # and the catchments are not all completely connected to one another\n    return self.all_stops_have_nearest_links() and (\n        not self.has_a_completely_connected_catchment()\n    )\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.plot","title":"<code>plot()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def plot(self):\n    minx, miny, maxx, maxy = self.nodes.geometry.total_bounds\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    self.network_spatial_tree.links.plot(ax=ax, color=\"#BFBFBF\", alpha=0.8)\n    self.network_spatial_tree.links[\n        self.network_spatial_tree.links[\"link_id\"].isin(self.nodes[\"link_id\"])\n    ].plot(ax=ax, color=\"#FFD710\")\n    self.nodes.plot(ax=ax, color=\"#F9CACA\", alpha=0.7)\n    self.stops.plot(ax=ax, marker=\"x\", color=\"#F76363\")\n\n    ax.set_xlim(minx - 0.003, maxx + 0.003)\n    ax.set_ylim(miny - 0.003, maxy + 0.003)\n    ax.set_title(\n        \"Stops, their catchments and underlying network for the Max Stable Set Problem\"\n    )\n    return fig, ax\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.plot_routes","title":"<code>plot_routes()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def plot_routes(self):\n    minx, miny, maxx, maxy = self.nodes.geometry.total_bounds\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    self.network_spatial_tree.links.plot(ax=ax, color=\"#BFBFBF\", alpha=0.8)\n    self.network_spatial_tree.links[\n        self.network_spatial_tree.links[\"link_id\"].isin(\n            [item for sublist in self.pt_edges[\"shortest_path\"] for item in sublist]\n        )\n    ].plot(ax=ax, color=\"#E5AF00\")\n    self.nodes.plot(ax=ax, color=\"#F9CACA\", alpha=0.7)\n    self.stops.plot(ax=ax, marker=\"x\", color=\"#F76363\")\n\n    ax.set_xlim(minx - 0.003, maxx + 0.003)\n    ax.set_ylim(miny - 0.003, maxy + 0.003)\n    ax.set_title(\"Stops, their catchments, the underlying network and route\")\n    return fig, ax\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.route_edges","title":"<code>route_edges()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def route_edges(self):\n    self.pt_edges[\"linkRefId_u\"] = self.pt_edges[\"u\"].map(self.solution)\n    self.pt_edges[\"linkRefId_v\"] = self.pt_edges[\"v\"].map(self.solution)\n    pt_edges = self.network_spatial_tree.shortest_paths(\n        df_pt_edges=self.pt_edges.loc[\n            self.pt_edges.notna().all(axis=1), (\"linkRefId_u\", \"linkRefId_v\")\n        ],\n        from_col=\"linkRefId_u\",\n        to_col=\"linkRefId_v\",\n        weight=\"length\",\n    )\n    self.pt_edges = self.pt_edges.merge(\n        pt_edges,\n        left_on=[\"linkRefId_u\", \"linkRefId_v\"],\n        right_on=[\"linkRefId_u\", \"linkRefId_v\"],\n        how=\"left\",\n    )\n    return self.pt_edges\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.routed_path","title":"<code>routed_path(ordered_stops)</code>","text":"<p>Get a routed path based on list of ordered stops.</p> PARAMETER DESCRIPTION <code>ordered_stops</code> <p>list of stops in the route (not artificial/snapped stops).</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Routed path.</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def routed_path(self, ordered_stops: list) -&gt; list:\n    \"\"\"Get a routed path based on list of ordered stops.\n\n    Args:\n        ordered_stops (list): list of stops in the route (not artificial/snapped stops).\n\n    Returns:\n        list: Routed path.\n    \"\"\"\n    path = []\n    for u, v in zip(ordered_stops[:-1], ordered_stops[1:]):\n        pairwise_path = self.pt_edges.loc[\n            (self.pt_edges[\"u\"] == u) &amp; (self.pt_edges[\"v\"] == v), \"shortest_path\"\n        ].tolist()[0]\n        if path:\n            if path[-1] == pairwise_path[0]:\n                path += pairwise_path[1:]\n            else:\n                path += pairwise_path\n        else:\n            path.extend(pairwise_path)\n    return path\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.solve","title":"<code>solve(solver='cbc')</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def solve(self, solver=\"cbc\"):\n    if nx.is_empty(self.problem_graph):\n        logging.info(\"Empty problem graph passed to the solver. No stops will find a solution.\")\n        self.unsolved_stops = set(self.stops[\"id\"])\n    else:\n        # --------------------------------------------------------\n        # Model\n        # --------------------------------------------------------\n\n        model = pe.ConcreteModel()\n\n        # --------------------------------------------------------\n        # Sets/Params\n        # --------------------------------------------------------\n\n        # nodes and edge sets\n        # nodes: network's graph nodes that are closest to stops\n        # edges: connections between nodes if they are in the same\n        #    selection pool or there is no path between them\n        vertices = set(self.problem_graph.nodes)\n        edges = set(self.problem_graph.edges)\n\n        model.vertices = pe.Set(initialize=vertices)\n\n        def spatial_proximity_coefficient_init(model, i):\n            attribs = self.problem_graph.nodes[i]\n            # todo normalise\n            return attribs[\"coeff\"]\n\n        model.c = pe.Param(model.vertices, initialize=spatial_proximity_coefficient_init)\n\n        # --------------------------------------------------------\n        # Variables\n        # --------------------------------------------------------\n\n        model.x = pe.Var(vertices, within=pe.Binary)\n\n        # --------------------------------------------------------\n        # Constraints\n        # --------------------------------------------------------\n\n        model.edge_adjacency = pe.ConstraintList()\n        for u, v in edges:\n            model.edge_adjacency.add(model.x[u] + model.x[v] &lt;= 1)\n\n        # --------------------------------------------------------\n        # Objective\n        # --------------------------------------------------------\n\n        def total_nodes_rule(model):\n            return sum(model.c[i] * model.x[i] for i in model.vertices)\n\n        model.total_nodes = pe.Objective(rule=total_nodes_rule, sense=pe.maximize)\n\n        # --------------------------------------------------------\n        # Solver\n        # --------------------------------------------------------\n\n        logging.info(\"Passing problem to solver\")\n        _solver = pe.SolverFactory(solver)\n        _solver.solve(model)\n\n        # --------------------------------------------------------\n        # Solution parse\n        # --------------------------------------------------------\n\n        selected = get_indices_of_chosen_problem_graph_nodes(model)\n\n        # solution maps Stop IDs to Link IDs\n        self.solution = {\n            self.problem_graph.nodes[node][\"id\"]: self.problem_graph.nodes[node][\"link_id\"]\n            for node in selected\n        }\n        self.artificial_stops = {\n            node: {\n                **self.pt_graph.nodes[self.problem_graph.nodes[node][\"id\"]],\n                **{\n                    \"linkRefId\": self.problem_graph.nodes[node][\"link_id\"],\n                    \"stop_id\": self.problem_graph.nodes[node][\"id\"],\n                    \"id\": node,\n                },\n            }\n            for node in selected\n        }\n        self.unsolved_stops = set(self.stops[\"id\"]) - set(self.solution.keys())\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.stops_missing_nearest_links","title":"<code>stops_missing_nearest_links()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def stops_missing_nearest_links(self):\n    return set(self.stops[\"id\"]) - {\n        stop for problem_node, stop in self.problem_graph.nodes(data=\"id\")\n    }\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.stops_to_artificial_stops_map","title":"<code>stops_to_artificial_stops_map()</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def stops_to_artificial_stops_map(self):\n    return {\n        **{s: s for s in self.unsolved_stops},\n        **{data[\"stop_id\"]: a_s for a_s, data in self.artificial_stops.items()},\n    }\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.MaxStableSet.to_changeset","title":"<code>to_changeset(routes_df)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def to_changeset(self, routes_df):\n    return ChangeSet(self, routes_df)\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.get_indices_of_chosen_problem_graph_nodes","title":"<code>get_indices_of_chosen_problem_graph_nodes(model)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def get_indices_of_chosen_problem_graph_nodes(model: pe.Model):\n    return [\n        v.index()\n        for v in model.component_data_objects(pe.Var)\n        if v.value is not None and float(v.value) == 1.0\n    ]\n</code></pre>"},{"location":"reference/genet/max_stable_set/#genet.max_stable_set.has_attrib","title":"<code>has_attrib(attrib_value)</code>","text":"Source code in <code>src/genet/max_stable_set.py</code> <pre><code>def has_attrib(attrib_value):\n    # used with a method to extract graph elements with a specific attribute key regardless of the value, if the key\n    # exists, this function evaluates to True.\n    return True\n</code></pre>"},{"location":"reference/genet/modify/change_log/","title":"genet.modify.change_log","text":""},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog","title":"<code>ChangeLog(df=None)</code>","text":"<p>               Bases: <code>DataFrame</code></p> <p>Records changes in genet.core.Network in a pandas.DataFrame</p> <p>Change Events: \u2022 Add : \u2022 Modify : \u2022 Remove :</p> PARAMETER DESCRIPTION <code>df</code> <p>If given, initialise with <code>df</code>. If not given, initialise with an empty DataFrame. Defaults to None.</p> <p> TYPE: <code>Optional[DataFrame]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def __init__(self, df: Optional[pd.DataFrame] = None):\n    \"\"\"Records changes in genet.core.Network in a pandas.DataFrame\n\n    Change Events:\n    \u2022 Add :\n    \u2022 Modify :\n    \u2022 Remove :\n\n    Args:\n        df (Optional[pd.DataFrame], optional):\n            If given, initialise with `df`.\n            If not given, initialise with an empty DataFrame.\n            Defaults to None.\n    \"\"\"\n    if df is None:\n        super().__init__(\n            columns=[\n                \"timestamp\",\n                \"change_event\",\n                \"object_type\",\n                \"old_id\",\n                \"new_id\",\n                \"old_attributes\",\n                \"new_attributes\",\n                \"diff\",\n            ]\n        )\n    else:\n        super().__init__(df)\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.add","title":"<code>add(object_type, object_id, object_attributes)</code>","text":"Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def add(self, object_type: str, object_id: Union[int, str], object_attributes: dict):\n    self.loc[self._next_index()] = pd.Series(\n        {\n            \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"change_event\": \"add\",\n            \"object_type\": object_type,\n            \"old_id\": None,\n            \"new_id\": object_id,\n            \"old_attributes\": None,\n            \"new_attributes\": str(object_attributes),\n            \"diff\": self.generate_diff(None, object_id, None, object_attributes),\n        }\n    )\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.add_bunch","title":"<code>add_bunch(object_type, id_bunch, attributes_bunch)</code>","text":"PARAMETER DESCRIPTION <code>object_type</code> <p>GeNet object type.</p> <p> TYPE: <code>str</code> </p> <code>id_bunch</code> <p>same len as <code>attributes_bunch</code>.</p> <p> TYPE: <code>list[Union[int, str]]</code> </p> <code>attributes_bunch</code> <p>same len as <code>id_bunch</code>.</p> <p> TYPE: <code>list[dict]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Existing config concatenated with input bunch.</p> <p> TYPE: <code>Self</code> </p> Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def add_bunch(\n    self, object_type: str, id_bunch: list[Union[int, str]], attributes_bunch: list[dict]\n) -&gt; Self:\n    \"\"\"\n    Args:\n        object_type (str): GeNet object type.\n        id_bunch (list[Union[int, str]]): same len as `attributes_bunch`.\n        attributes_bunch (list[dict]): same len as `id_bunch`.\n\n    Returns:\n        Self: Existing config concatenated with input bunch.\n    \"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return self.__class__(\n        pd.concat(\n            [\n                self,\n                pd.DataFrame(\n                    {\n                        \"timestamp\": [timestamp] * len(id_bunch),\n                        \"change_event\": [\"add\"] * len(id_bunch),\n                        \"object_type\": [object_type] * len(id_bunch),\n                        \"old_id\": None,\n                        \"new_id\": id_bunch,\n                        \"old_attributes\": None,\n                        \"new_attributes\": [str(d) for d in attributes_bunch],\n                        \"diff\": [\n                            self.generate_diff(None, _id, None, attrib)\n                            for _id, attrib in zip(id_bunch, attributes_bunch)\n                        ],\n                    }\n                ),\n            ],\n            ignore_index=True,\n        )\n    )\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.export","title":"<code>export(path)</code>","text":"Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def export(self, path):\n    self.to_csv(path)\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.generate_diff","title":"<code>generate_diff(old_id, new_id, old_attributes_dict, new_attributes_dict)</code>","text":"Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def generate_diff(self, old_id, new_id, old_attributes_dict, new_attributes_dict):\n    if old_attributes_dict is None:\n        old_attributes_dict = {}\n    if new_attributes_dict is None:\n        new_attributes_dict = {}\n\n    diff = list(dictdiffer.diff(old_attributes_dict, new_attributes_dict))\n    if old_id != new_id:\n        if old_id is None:\n            diff.append((\"add\", \"id\", new_id))\n        elif new_id is None:\n            diff.append((\"remove\", \"id\", old_id))\n        else:\n            diff.append((\"change\", \"id\", (old_id, new_id)))\n    return diff\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.merge_logs","title":"<code>merge_logs(other)</code>","text":"Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def merge_logs(self, other):\n    return self.__class__(\n        pd.concat([self, other]).sort_values(by=\"timestamp\").reset_index(drop=True)\n    )\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.modify","title":"<code>modify(object_type, old_id, old_attributes, new_id, new_attributes)</code>","text":"Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def modify(\n    self,\n    object_type: str,\n    old_id: Union[int, str],\n    old_attributes: dict,\n    new_id: Union[int, str],\n    new_attributes: dict,\n):\n    self.loc[self._next_index()] = pd.Series(\n        {\n            \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"change_event\": \"modify\",\n            \"object_type\": object_type,\n            \"old_id\": old_id,\n            \"new_id\": new_id,\n            \"old_attributes\": str(old_attributes),\n            \"new_attributes\": str(new_attributes),\n            \"diff\": self.generate_diff(old_id, new_id, old_attributes, new_attributes),\n        }\n    )\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.modify_bunch","title":"<code>modify_bunch(object_type, old_id_bunch, old_attributes, new_id_bunch, new_attributes)</code>","text":"PARAMETER DESCRIPTION <code>object_type</code> <p>GeNet object type.</p> <p> TYPE: <code>str</code> </p> <code>old_id_bunch</code> <p>Same len as <code>attributes_bunch</code>.</p> <p> TYPE: <code>list[Union[int, str]]</code> </p> <code>old_attributes</code> <p>Same len as <code>id_bunch.</code></p> <p> TYPE: <code>list[dict]</code> </p> <code>new_id_bunch</code> <p>Same len as <code>attributes_bunch</code>.</p> <p> TYPE: <code>list[Union[int, str]]</code> </p> <code>new_attributes</code> <p>Same len as <code>id_bunch.</code></p> <p> TYPE: <code>list[dict]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Existing config concatenated with modified bunch.</p> <p> TYPE: <code>Self</code> </p> Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def modify_bunch(\n    self,\n    object_type: str,\n    old_id_bunch: list[Union[int, str]],\n    old_attributes: list[dict],\n    new_id_bunch: list[Union[int, str]],\n    new_attributes: list[dict],\n) -&gt; Self:\n    \"\"\"\n    Args:\n        object_type (str): GeNet object type.\n        old_id_bunch (list[Union[int, str]]): Same len as `attributes_bunch`.\n        old_attributes (list[dict]): Same len as `id_bunch.`\n        new_id_bunch (list[Union[int, str]]): Same len as `attributes_bunch`.\n        new_attributes (list[dict]): Same len as `id_bunch.`\n\n    Returns:\n        Self: Existing config concatenated with modified bunch.\n    \"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return self.__class__(\n        pd.concat(\n            [\n                self,\n                pd.DataFrame(\n                    {\n                        \"timestamp\": [timestamp] * len(old_id_bunch),\n                        \"change_event\": [\"modify\"] * len(old_id_bunch),\n                        \"object_type\": [object_type] * len(old_id_bunch),\n                        \"old_id\": old_id_bunch,\n                        \"new_id\": new_id_bunch,\n                        \"old_attributes\": [str(d) for d in old_attributes],\n                        \"new_attributes\": [str(d) for d in new_attributes],\n                        \"diff\": [\n                            self.generate_diff(old_id, new_id, old_attrib, new_attrib)\n                            for old_id, new_id, old_attrib, new_attrib in zip(\n                                old_id_bunch, new_id_bunch, old_attributes, new_attributes\n                            )\n                        ],\n                    }\n                ),\n            ],\n            ignore_index=True,\n        )\n    )\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.remove","title":"<code>remove(object_type, object_id, object_attributes)</code>","text":"Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def remove(self, object_type: str, object_id: Union[int, str], object_attributes: dict):\n    self.loc[self._next_index()] = pd.Series(\n        {\n            \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"change_event\": \"remove\",\n            \"object_type\": object_type,\n            \"old_id\": object_id,\n            \"new_id\": None,\n            \"old_attributes\": str(object_attributes),\n            \"new_attributes\": None,\n            \"diff\": self.generate_diff(object_id, None, object_attributes, None),\n        }\n    )\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.remove_bunch","title":"<code>remove_bunch(object_type, id_bunch, attributes_bunch)</code>","text":"PARAMETER DESCRIPTION <code>object_type</code> <p>GeNet object type.</p> <p> TYPE: <code>str</code> </p> <code>id_bunch</code> <p>same len as <code>attributes_bunch</code>.</p> <p> TYPE: <code>list[Union[int, str]]</code> </p> <code>attributes_bunch</code> <p>same len as <code>id_bunch</code>.</p> <p> TYPE: <code>list[dict]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Existing config concatenated with removed bunch.</p> <p> TYPE: <code>Self</code> </p> Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def remove_bunch(\n    self, object_type: str, id_bunch: list[Union[int, str]], attributes_bunch: list[dict]\n) -&gt; Self:\n    \"\"\"\n\n    Args:\n        object_type (str): GeNet object type.\n        id_bunch (list[Union[int, str]]):  same len as `attributes_bunch`.\n        attributes_bunch (list[dict]): same len as `id_bunch`.\n\n    Returns:\n        Self: Existing config concatenated with removed bunch.\n    \"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return self.__class__(\n        pd.concat(\n            [\n                self,\n                pd.DataFrame(\n                    {\n                        \"timestamp\": [timestamp] * len(id_bunch),\n                        \"change_event\": [\"remove\"] * len(id_bunch),\n                        \"object_type\": [object_type] * len(id_bunch),\n                        \"old_id\": id_bunch,\n                        \"new_id\": None,\n                        \"old_attributes\": [str(d) for d in attributes_bunch],\n                        \"new_attributes\": None,\n                        \"diff\": [\n                            self.generate_diff(_id, None, attrib, None)\n                            for _id, attrib in zip(id_bunch, attributes_bunch)\n                        ],\n                    }\n                ),\n            ],\n            ignore_index=True,\n        )\n    )\n</code></pre>"},{"location":"reference/genet/modify/change_log/#genet.modify.change_log.ChangeLog.simplify_bunch","title":"<code>simplify_bunch(old_ids_list_bunch, new_id_bunch, indexed_paths_to_simplify, links_to_add)</code>","text":"<p>Series of ordered lists of indices and attributes to log simplification of links, data prior to simplification and the nodes simplified.</p> PARAMETER DESCRIPTION <code>old_ids_list_bunch</code> <p>old ids list.</p> <p> TYPE: <code>list</code> </p> <code>new_id_bunch</code> <p>new ids list</p> <p> TYPE: <code>list</code> </p> <code>indexed_paths_to_simplify</code> <p>same len as ID bunches</p> <p> TYPE: <code>dict</code> </p> <code>links_to_add</code> <p>Lists of nodes deleted in order. E.g. if path_before = [A, B, C, D] and path_after = [A, D], then path_diff = [B, C]. Dictionary is list of <code>path_diff</code> for all links.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Existing config concatenated with simplified bunch.</p> <p> TYPE: <code>Self</code> </p> Source code in <code>src/genet/modify/change_log.py</code> <pre><code>def simplify_bunch(\n    self,\n    old_ids_list_bunch: list,\n    new_id_bunch: list,\n    indexed_paths_to_simplify: dict,\n    links_to_add: dict,\n) -&gt; Self:\n    \"\"\"Series of ordered lists of indices and attributes to log simplification of links, data prior to simplification and the nodes simplified.\n\n    Args:\n        old_ids_list_bunch (list): old ids list.\n        new_id_bunch (list): new ids list\n        indexed_paths_to_simplify (dict): same len as ID bunches\n        links_to_add (dict):\n            Lists of nodes deleted in order.\n            E.g. if path_before = [A, B, C, D] and path_after = [A, D], then path_diff = [B, C].\n            Dictionary is list of `path_diff` for all links.\n\n    Returns:\n        Self: Existing config concatenated with simplified bunch.\n    \"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return self.__class__(\n        pd.concat(\n            [\n                self,\n                pd.DataFrame(\n                    {\n                        \"timestamp\": [timestamp] * len(new_id_bunch),\n                        \"change_event\": [\"simplify\"] * len(new_id_bunch),\n                        \"object_type\": [\"links\"] * len(new_id_bunch),\n                        \"old_id\": old_ids_list_bunch,\n                        \"new_id\": new_id_bunch,\n                        \"old_attributes\": [\n                            str(indexed_paths_to_simplify[_id][\"link_data\"])\n                            for _id in new_id_bunch\n                        ],\n                        \"new_attributes\": [str(links_to_add[_id]) for _id in new_id_bunch],\n                        \"diff\": [\n                            str(indexed_paths_to_simplify[_id][\"nodes_to_remove\"])\n                            for _id in new_id_bunch\n                        ],\n                    }\n                ),\n            ],\n            ignore_index=True,\n        )\n    )\n</code></pre>"},{"location":"reference/genet/modify/graph/","title":"genet.modify.graph","text":""},{"location":"reference/genet/modify/graph/#genet.modify.graph.reproj","title":"<code>reproj(nodes_dict, from_proj, to_proj)</code>","text":"Source code in <code>src/genet/modify/graph.py</code> <pre><code>def reproj(nodes_dict, from_proj, to_proj):\n    transformer = Transformer.from_crs(from_proj, to_proj, always_xy=True)\n    new_attribs = {}\n    for node, node_attrib in nodes_dict.items():\n        x, y = spatial.change_proj(node_attrib[\"x\"], node_attrib[\"y\"], transformer)\n        new_attribs[node] = {\"x\": x, \"y\": y}\n    return new_attribs\n</code></pre>"},{"location":"reference/genet/modify/schedule/","title":"genet.modify.schedule","text":""},{"location":"reference/genet/modify/schedule/#genet.modify.schedule.reproj_stops","title":"<code>reproj_stops(schedule_element_nodes, new_epsg)</code>","text":"PARAMETER DESCRIPTION <code>schedule_element_nodes</code> <p>stop IDs : stop data including <code>x</code>, <code>y</code>, <code>epsg</code>.</p> <p> TYPE: <code>dict</code> </p> <code>new_epsg</code> <p>the epsg stops are being projected to, e.g. 'epsg:4326'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Stop IDs from <code>schedule_element_nodes</code>: changed stop data in dict format new <code>x</code>, <code>y</code> and <code>epsg</code>.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/modify/schedule.py</code> <pre><code>def reproj_stops(schedule_element_nodes: dict, new_epsg: str) -&gt; dict:\n    \"\"\"\n\n    Args:\n        schedule_element_nodes (dict): stop IDs : stop data including `x`, `y`, `epsg`.\n        new_epsg (str): the epsg stops are being projected to, e.g. 'epsg:4326'.\n\n    Returns:\n        dict: Stop IDs from `schedule_element_nodes`: changed stop data in dict format new `x`, `y` and `epsg`.\n    \"\"\"\n    transformers = {\n        epsg: Transformer.from_crs(epsg, new_epsg, always_xy=True)\n        for epsg in DataFrame(schedule_element_nodes).T[\"epsg\"].unique()\n    }\n\n    reprojected_node_attribs = {}\n    for node_id, node_attribs in schedule_element_nodes.items():\n        x, y = spatial.change_proj(\n            node_attribs[\"x\"], node_attribs[\"y\"], transformers[node_attribs[\"epsg\"]]\n        )\n        reprojected_node_attribs[node_id] = {\"x\": x, \"y\": y, \"epsg\": new_epsg}\n    return reprojected_node_attribs\n</code></pre>"},{"location":"reference/genet/modify/schedule/#genet.modify.schedule.route_pt_graph","title":"<code>route_pt_graph(pt_graph, network_spatial_tree, modes, solver='cbc', allow_partial=False, distance_threshold=30, step_size=10)</code>","text":"Source code in <code>src/genet/modify/schedule.py</code> <pre><code>def route_pt_graph(\n    pt_graph,\n    network_spatial_tree,\n    modes,\n    solver=\"cbc\",\n    allow_partial=False,\n    distance_threshold=30,\n    step_size=10,\n):\n    logging.info(\n        f\"Building Maximum Stable Set for PT graph with {pt_graph.number_of_nodes()} stops and \"\n        f\"{pt_graph.number_of_edges()} edges\"\n    )\n    mss = MaxStableSet(\n        pt_graph=pt_graph,\n        network_spatial_tree=network_spatial_tree,\n        modes=modes,\n        distance_threshold=distance_threshold,\n        step_size=step_size,\n    )\n    if mss.is_partial:\n        if allow_partial:\n            logging.warning(\n                \"Maximum Stable Set problem to snap the PT graph to the network is partially \"\n                \"viable, meaning not all stops have found a link to snap to within the distance_threshold.\"\n                \"Partial snapping is ON, this problem will proceed to the solver.\"\n            )\n        else:\n            raise exceptions.PartialMaxStableSetProblem(\n                \"This Problem is partial. To allow partially snapped \"\n                \"solutions set `allow_partial=True`\"\n            )\n    logging.info(\"Passing problem to solver\")\n    mss.solve(solver=solver)\n    mss.route_edges()\n    if allow_partial and mss.is_partial:\n        logging.info(\n            f\"Successfully snapped {pt_graph.number_of_nodes() - len(mss.unsolved_stops)} stops to network \"\n            \"links.\"\n        )\n    if mss.unsolved_stops:\n        mss.fill_in_solution_artificially()\n    return mss\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_values/","title":"genet.output.matsim_xml_values","text":""},{"location":"reference/genet/output/matsim_xml_values/#genet.output.matsim_xml_values.MATSIM_JOSM_DEFAULTS","title":"<code>MATSIM_JOSM_DEFAULTS = {'motorway': {'permlanes': 2.0, 'freespeed': 33.36, 'capacity': 2000.0}, 'motorway_link': {'permlanes': 1.0, 'freespeed': 22.22, 'capacity': 1500.0}, 'trunk': {'permlanes': 1.0, 'freespeed': 22.22, 'capacity': 2000.0}, 'trunk_link': {'permlanes': 1.0, 'freespeed': 13.89, 'capacity': 1500.0}, 'primary': {'permlanes': 1.0, 'freespeed': 22.22, 'capacity': 1500.0}, 'primary_link': {'permlanes': 1.0, 'freespeed': 16.68, 'capacity': 1500.0}, 'secondary': {'permlanes': 1.0, 'freespeed': 16.68, 'capacity': 1000.0}, 'secondary_link': {'permlanes': 1.0, 'freespeed': 16.68, 'capacity': 1000.0}, 'tertiary': {'permlanes': 1.0, 'freespeed': 12.5, 'capacity': 600.0}, 'tertiary_link': {'permlanes': 1.0, 'freespeed': 12.5, 'capacity': 600.0}, 'minor': {'permlanes': 1.0, 'freespeed': 12.5, 'capacity': 600.0}, 'unclassified': {'permlanes': 1.0, 'freespeed': 12.5, 'capacity': 600.0}, 'residential': {'permlanes': 1.0, 'freespeed': 8.34, 'capacity': 600.0}, 'service': {'permlanes': 1.0, 'freespeed': 4.17, 'capacity': 300.0}, 'living_street': {'permlanes': 1.0, 'freespeed': 4.17, 'capacity': 300.0}, 'pedestrian': {'permlanes': 1.0, 'freespeed': 1.34, 'capacity': 300.0}, 'footway': {'permlanes': 1.0, 'freespeed': 1.34, 'capacity': 300.0}, 'steps': {'permlanes': 1.0, 'freespeed': 1.34, 'capacity': 300.0}, 'railway': {'permlanes': 1.0, 'freespeed': 44.44, 'capacity': 9999.0}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/output/matsim_xml_writer/","title":"genet.output.matsim_xml_writer","text":""},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.EXPECTED_FORMAT_FOR_ADDITIONAL_ATTRIBUTES_MESSAGE","title":"<code>EXPECTED_FORMAT_FOR_ADDITIONAL_ATTRIBUTES_MESSAGE = f'The expected format is either a nested dictionary: `{\"attribute_name\": {\"name\": \"attribute_name\", \"class\": \"java.lang.DTYPE\", \"text\": attribute_value}}`, or`{\"attribute_name\": attribute_value}` with `attribute_value` of supported python format:{list(java_dtypes.PYTHON_DTYPE_MAP)}'</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.can_be_put_in_matsim_format","title":"<code>can_be_put_in_matsim_format(attrib_value)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def can_be_put_in_matsim_format(attrib_value):\n    return type(attrib_value) in java_dtypes.PYTHON_DTYPE_MAP\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.check_additional_attributes","title":"<code>check_additional_attributes(attribs)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def check_additional_attributes(attribs):\n    if \"attributes\" in attribs:\n        if isinstance(attribs[\"attributes\"], dict):\n            attribs_to_delete = []\n            for attrib, value in attribs[\"attributes\"].items():\n                if not (is_of_matsim_format(value) or can_be_put_in_matsim_format(value)):\n                    logging.warning(\n                        f'Data under \"attributes:{attrib}\" key is not of supported format. '\n                        f\"{EXPECTED_FORMAT_FOR_ADDITIONAL_ATTRIBUTES_MESSAGE}\"\n                    )\n                    attribs_to_delete.append(attrib)\n            for attrib in attribs_to_delete:\n                logging.warning(f'Deleting malformed {attrib} under key \"attributes\"')\n                del attribs[\"attributes\"][attrib]\n            if not attribs[\"attributes\"]:\n                logging.warning(\n                    f\"Attributes are not formatted correctly and will be deleted: {attribs}\"\n                )\n                del attribs[\"attributes\"]\n        else:\n            logging.warning(f\"Attributes are not a dictionary: {attribs}\")\n            del attribs[\"attributes\"]\n    return attribs\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.format_to_matsim","title":"<code>format_to_matsim(k, _attrib)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def format_to_matsim(k, _attrib):\n    if is_of_matsim_format(_attrib):\n        return deepcopy(_attrib)\n    elif can_be_put_in_matsim_format(_attrib):\n        return put_in_matsim_format(k, _attrib)\n    else:\n        raise MalformedAdditionalAttributeError(\n            f\"Attribute: {k} with data: {_attrib} is not of the required \"\n            f\"format. {EXPECTED_FORMAT_FOR_ADDITIONAL_ATTRIBUTES_MESSAGE}\"\n        )\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.get_allowable_attributes","title":"<code>get_allowable_attributes(elem_type)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def get_allowable_attributes(elem_type):\n    if elem_type == \"node\":\n        return (\n            variables.OPTIONAL_NETWORK_NODE_ATTRIBUTES + variables.NECESSARY_NETWORK_NODE_ATTRIBUTES\n        )\n    elif elem_type == \"link\":\n        return (\n            variables.OPTIONAL_NETWORK_LINK_ATTRIBUTES\n            + variables.NECESSARY_NETWORK_LINK_ATTRIBUTES\n            + [\"geometry\"]\n        )\n    elif elem_type == \"stopFacility\":\n        return (\n            variables.OPTIONAL_STOP_FACILITY_ATTRIBUTES\n            + variables.NECESSARY_STOP_FACILITY_ATTRIBUTES\n        )\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.get_necessary_attributes","title":"<code>get_necessary_attributes(elem_type)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def get_necessary_attributes(elem_type):\n    if elem_type == \"node\":\n        return variables.NECESSARY_NETWORK_NODE_ATTRIBUTES\n    elif elem_type == \"link\":\n        return variables.NECESSARY_NETWORK_LINK_ATTRIBUTES\n    elif elem_type == \"stopFacility\":\n        return variables.NECESSARY_STOP_FACILITY_ATTRIBUTES\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.is_of_matsim_format","title":"<code>is_of_matsim_format(attribute_value)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def is_of_matsim_format(attribute_value):\n    if isinstance(attribute_value, dict):\n        if {\"name\", \"class\", \"text\"}.issubset(set(attribute_value.keys())):\n            return True\n    return False\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.prepare_attributes","title":"<code>prepare_attributes(attribs, elem_type)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def prepare_attributes(attribs, elem_type):\n    d = deepcopy(attribs)\n    d = check_additional_attributes(d)\n    d = retain_allowed_attributes_for_xml(d, elem_type)\n    validate_attribute_data(d, get_necessary_attributes(elem_type))\n    return d\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.prepare_link_geometry_attribute","title":"<code>prepare_link_geometry_attribute(link_attribs)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def prepare_link_geometry_attribute(link_attribs):\n    link_attributes = deepcopy(link_attribs)\n    if \"geometry\" in link_attribs:\n        geom_attribute = {\n            \"name\": \"geometry\",\n            \"class\": \"java.lang.String\",\n            \"text\": encode_shapely_linestring_to_polyline(link_attributes[\"geometry\"]),\n        }\n        if \"attributes\" in link_attributes:\n            link_attributes[\"attributes\"][\"geometry\"] = geom_attribute\n        else:\n            link_attributes[\"attributes\"] = {\"geometry\": geom_attribute}\n        del link_attributes[\"geometry\"]\n    return link_attributes\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.put_in_matsim_format","title":"<code>put_in_matsim_format(attrib_name, attrib_value)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def put_in_matsim_format(attrib_name, attrib_value):\n    return {\n        \"name\": attrib_name,\n        \"class\": java_dtypes.python_to_java_dtype(type(attrib_value)),\n        \"text\": attrib_value,\n    }\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.retain_allowed_attributes_for_xml","title":"<code>retain_allowed_attributes_for_xml(d, elem_type)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def retain_allowed_attributes_for_xml(d, elem_type):\n    attrib_keys = set(d.keys())\n    allowable_attributes = get_allowable_attributes(elem_type)\n    for attrib in attrib_keys - set(allowable_attributes):\n        del d[attrib]\n    return d\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.save_additional_attributes","title":"<code>save_additional_attributes(attributes, xf)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def save_additional_attributes(attributes, xf):\n    with xf.element(\"attributes\"):\n        for k, _attrib in attributes.items():\n            attrib = format_to_matsim(k, _attrib)\n            text = attrib.pop(\"text\")\n            rec = etree.Element(\"attribute\", attrib)\n            rec.text = str(text)\n            xf.write(rec)\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.save_attributes","title":"<code>save_attributes(attributes, xf, elem_type)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def save_attributes(attributes, xf, elem_type):\n    if \"attributes\" in attributes:\n        save_with_additional_attributes(attributes, xf, elem_type)\n    else:\n        xf.write(etree.Element(elem_type, sanitiser.sanitise_dictionary_for_xml(attributes)))\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.save_with_additional_attributes","title":"<code>save_with_additional_attributes(_attributes, xf, elem_type)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def save_with_additional_attributes(_attributes, xf, elem_type):\n    attributes = deepcopy(_attributes)\n    additional_attributes = attributes.pop(\"attributes\")\n    attributes = sanitiser.sanitise_dictionary_for_xml(attributes)\n    with xf.element(elem_type, attributes):\n        save_additional_attributes(additional_attributes, xf)\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.write_matsim_network","title":"<code>write_matsim_network(output_dir, network)</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def write_matsim_network(output_dir, network):\n    fname = os.path.join(output_dir, \"network.xml\")\n    logging.info(\"Writing {}\".format(fname))\n\n    with open(fname, \"wb\") as f, etree.xmlfile(f, encoding=\"utf-8\") as xf:\n        xf.write_declaration(\n            doctype='&lt;!DOCTYPE network SYSTEM \"http://www.matsim.org/files/dtd/network_v2.dtd\"&gt;'\n        )\n        with xf.element(\"network\"):\n            save_additional_attributes(network.attributes, xf)\n\n            with xf.element(\"nodes\"):\n                for node_id, node_attribs in network.nodes():\n                    node_attributes = prepare_attributes(node_attribs, elem_type=\"node\")\n                    save_attributes(node_attributes, xf, elem_type=\"node\")\n\n            with xf.element(\n                \"links\",\n                {\"capperiod\": \"01:00:00\", \"effectivecellsize\": \"7.5\", \"effectivelanewidth\": \"3.75\"},\n            ):\n                for link_id, link_attribs in network.links():\n                    link_attributes = prepare_attributes(link_attribs, elem_type=\"link\")\n                    link_attributes = prepare_link_geometry_attribute(link_attributes)\n                    save_attributes(link_attributes, xf, elem_type=\"link\")\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.write_matsim_schedule","title":"<code>write_matsim_schedule(output_dir, schedule, reproj_processes=1)</code>","text":"<p>Save to MATSim XML format.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>path to output directory.</p> <p> TYPE: <code>str</code> </p> <code>schedule</code> <p>Schedule object to write.</p> <p> TYPE: <code>Schedule</code> </p> <code>reproj_processes</code> <p>You can set this in case you have a lot of stops and your stops need to be reprojected. It splits the process across given number of processes. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def write_matsim_schedule(output_dir: str, schedule: Schedule, reproj_processes: int = 1):\n    \"\"\"Save to MATSim XML format.\n\n    Args:\n        output_dir (str): path to output directory.\n        schedule (Schedule): Schedule object to write.\n        reproj_processes (int, optional):\n            You can set this in case you have a lot of stops and your stops need to be reprojected.\n            It splits the process across given number of processes.\n            Defaults to 1.\n    \"\"\"\n    fname = os.path.join(output_dir, \"schedule.xml\")\n    logging.info(\"Writing {}\".format(fname))\n\n    with open(fname, \"wb\") as f, etree.xmlfile(f, encoding=\"utf-8\") as xf:\n        xf.write_declaration(\n            doctype=\"&lt;!DOCTYPE transitSchedule \"\n            'SYSTEM \"http://www.matsim.org/files/dtd/transitSchedule_v2.dtd\"&gt;'\n        )\n        with xf.element(\"transitSchedule\"):\n            save_additional_attributes(schedule.attributes, xf)\n\n            with xf.element(\"transitStops\"):\n                if not schedule.stops_have_this_projection(schedule.epsg):\n                    logging.warning(\n                        \"Stops did not have a uniform projection, they will be projected to the Schedule \"\n                        f\"projection: {schedule.epsg}. Re-projection can be ran in parallel, if you have \"\n                        \"a lot of stops consider using `reproj_processes` parameter.\"\n                    )\n                    schedule.reproject(schedule.epsg, processes=reproj_processes)\n                for stop_facility in schedule.stops():\n                    transit_stop_attrib = prepare_attributes(\n                        stop_facility.__dict__, elem_type=\"stopFacility\"\n                    )\n                    save_attributes(transit_stop_attrib, xf, elem_type=\"stopFacility\")\n\n            # minimalTransferTimes, if present\n            if schedule.minimal_transfer_times:\n                with xf.element(\"minimalTransferTimes\"):\n                    for from_stop, val in schedule.minimal_transfer_times.items():\n                        for to_stop, transfer_time in val.items():\n                            minimal_transfer_times_attribs = {\n                                \"fromStop\": str(from_stop),\n                                \"toStop\": str(to_stop),\n                                \"transferTime\": str(transfer_time),\n                            }\n                            xf.write(etree.Element(\"relation\", minimal_transfer_times_attribs))\n\n            for service in schedule.services():\n                transit_line_attribs = {\"id\": service.id, \"name\": str(service.name)}\n\n                with xf.element(\"transitLine\", transit_line_attribs):\n                    if service.has_attrib(\"attributes\"):\n                        save_additional_attributes(service.attributes, xf)\n                    for route in service.routes():\n                        transit_route_attribs = {\"id\": route.id}\n\n                        with xf.element(\"transitRoute\", transit_route_attribs):\n                            if route.has_attrib(\"attributes\"):\n                                save_additional_attributes(route.attributes, xf)\n\n                            rec = etree.Element(\"transportMode\")\n                            rec.text = route.mode\n                            xf.write(rec)\n\n                            with xf.element(\"routeProfile\"):\n                                for j in range(len(route.ordered_stops)):\n                                    stop_attribs = {\"refId\": str(route.ordered_stops[j])}\n\n                                    if not (route.departure_offsets and route.arrival_offsets):\n                                        logging.warning(\n                                            \"The stop(s) along your route don't have arrival and departure offsets. \"\n                                            \"This is likely a route with one stop - consider validating your schedule.\"\n                                        )\n                                    else:\n                                        if j == 0:\n                                            stop_attribs[\"departureOffset\"] = (\n                                                route.departure_offsets[j]\n                                            )\n                                        elif j == len(route.ordered_stops) - 1:\n                                            stop_attribs[\"arrivalOffset\"] = route.arrival_offsets[j]\n                                        else:\n                                            stop_attribs[\"departureOffset\"] = (\n                                                route.departure_offsets[j]\n                                            )\n                                            stop_attribs[\"arrivalOffset\"] = route.arrival_offsets[j]\n\n                                        if route.await_departure:\n                                            stop_attribs[\"awaitDeparture\"] = str(\n                                                route.await_departure[j]\n                                            ).lower()\n                                    xf.write(etree.Element(\"stop\", stop_attribs))\n\n                            if not route.network_links:\n                                logging.warning(\n                                    \"Route needs to have a network route composed of a list of network links that \"\n                                    \"the vehicle on this route traverses. If read the Schedule from GTFS, the \"\n                                    \"resulting Route objects will not have reference to the network route taken.\"\n                                )\n                            else:\n                                with xf.element(\"route\"):\n                                    for link_id in route.network_links:\n                                        route_attribs = {\"refId\": str(link_id)}\n                                        xf.write(etree.Element(\"link\", route_attribs))\n\n                            with xf.element(\"departures\"):\n                                for trip_id, trip_dep_time, veh_id in zip(\n                                    route.trips[\"trip_id\"],\n                                    route.trips[\"trip_departure_time\"],\n                                    route.trips[\"vehicle_id\"],\n                                ):\n                                    trip_attribs = {\n                                        \"id\": trip_id,\n                                        \"departureTime\": trip_dep_time,\n                                        \"vehicleRefId\": veh_id,\n                                    }\n                                    xf.write(etree.Element(\"departure\", trip_attribs))\n</code></pre>"},{"location":"reference/genet/output/matsim_xml_writer/#genet.output.matsim_xml_writer.write_vehicles","title":"<code>write_vehicles(output_dir, vehicles, vehicle_types, file_name='vehicles.xml')</code>","text":"Source code in <code>src/genet/output/matsim_xml_writer.py</code> <pre><code>def write_vehicles(output_dir, vehicles, vehicle_types, file_name=\"vehicles.xml\"):\n    fname = os.path.join(output_dir, file_name)\n    logging.info(\"Writing {}\".format(fname))\n\n    with open(fname, \"wb\") as f, etree.xmlfile(f, encoding=\"utf-8\") as xf:\n        xf.write_declaration()\n        vehicleDefinitions_attribs = {\n            \"xmlns\": \"http://www.matsim.org/files/dtd\",\n            \"xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n            \"xsi:schemaLocation\": \"http://www.matsim.org/files/dtd \"\n            \"http://www.matsim.org/files/dtd/vehicleDefinitions_v1.0.xsd\",\n        }\n        with xf.element(\"vehicleDefinitions\", vehicleDefinitions_attribs):\n            unique_veh_types = DataFrame(vehicles).T[\"type\"].unique()\n            for vehicle_type in unique_veh_types:\n                if vehicle_type in vehicle_types:\n                    vehicle_type_attribs = {\"id\": vehicle_type}\n                    veh_type_vals = vehicle_types[vehicle_type]\n                    with xf.element(\"vehicleType\", vehicle_type_attribs):\n                        with xf.element(\"capacity\"):\n                            xf.write(etree.Element(\"seats\", veh_type_vals[\"capacity\"][\"seats\"]))\n                            xf.write(\n                                etree.Element(\n                                    \"standingRoom\", veh_type_vals[\"capacity\"][\"standingRoom\"]\n                                )\n                            )\n                        xf.write(etree.Element(\"length\", veh_type_vals[\"length\"]))\n                        xf.write(etree.Element(\"width\", veh_type_vals[\"width\"]))\n                        xf.write(etree.Element(\"accessTime\", veh_type_vals[\"accessTime\"]))\n                        xf.write(etree.Element(\"egressTime\", veh_type_vals[\"egressTime\"]))\n                        xf.write(etree.Element(\"doorOperation\", veh_type_vals[\"doorOperation\"]))\n                        xf.write(\n                            etree.Element(\n                                \"passengerCarEquivalents\", veh_type_vals[\"passengerCarEquivalents\"]\n                            )\n                        )\n                else:\n                    raise NotImplementedError(\n                        f\"No Vehicle Type info available for mode {vehicle_type}, \"\n                        f\"you will need to add it to configs/vehicles/vehicle_definitions.yml, \"\n                        f\"or the schedule\"\n                    )\n            for veh_id, data in vehicles.items():\n                xf.write(etree.Element(\"vehicle\", {\"id\": veh_id, \"type\": data[\"type\"]}))\n</code></pre>"},{"location":"reference/genet/output/sanitiser/","title":"genet.output.sanitiser","text":""},{"location":"reference/genet/output/sanitiser/#genet.output.sanitiser.sanitise_dictionary","title":"<code>sanitise_dictionary(d)</code>","text":"Source code in <code>src/genet/output/sanitiser.py</code> <pre><code>def sanitise_dictionary(d):\n    for k, v in d.items():\n        if isinstance(v, (set, list)):\n            d[k] = sanitise_list(v)\n        if isinstance(v, dict):\n            sanitise_dictionary(v)\n    return d\n</code></pre>"},{"location":"reference/genet/output/sanitiser/#genet.output.sanitiser.sanitise_dictionary_for_xml","title":"<code>sanitise_dictionary_for_xml(d)</code>","text":"Source code in <code>src/genet/output/sanitiser.py</code> <pre><code>def sanitise_dictionary_for_xml(d):\n    for k, v in d.items():\n        if isinstance(v, (set, list)):\n            d[k] = sanitise_list(v)\n        if isinstance(v, (int, float)):\n            d[k] = str(v)\n        if isinstance(v, dict):\n            sanitise_dictionary_for_xml(v)\n    return d\n</code></pre>"},{"location":"reference/genet/output/sanitiser/#genet.output.sanitiser.sanitise_geodataframe","title":"<code>sanitise_geodataframe(gdf)</code>","text":"Source code in <code>src/genet/output/sanitiser.py</code> <pre><code>def sanitise_geodataframe(gdf):\n    if isinstance(gdf, GeoSeries):\n        gdf = GeoDataFrame(gdf)\n    object_columns = gdf.select_dtypes([\"object\"]).columns\n    for col in object_columns:\n        not_missing_mask = gdf[col].notna()\n        if gdf[col].apply(lambda x: isinstance(x, (set, list))).any():\n            gdf.loc[not_missing_mask, col] = gdf.loc[not_missing_mask, col].apply(\n                lambda x: \",\".join(x) if isinstance(x, (list, set)) else x\n            )\n        elif gdf[col].apply(lambda x: isinstance(x, dict)).any():\n            gdf.loc[not_missing_mask, col] = gdf.loc[not_missing_mask, col].apply(lambda x: str(x))\n    for col in gdf.select_dtypes(include=number).columns.tolist():\n        if (gdf[col] &gt; sys.maxsize).any():\n            gdf[col] = gdf[col].apply(lambda x: str(x))\n    return gdf\n</code></pre>"},{"location":"reference/genet/output/sanitiser/#genet.output.sanitiser.sanitise_list","title":"<code>sanitise_list(x)</code>","text":"Source code in <code>src/genet/output/sanitiser.py</code> <pre><code>def sanitise_list(x):\n    try:\n        return \",\".join(x)\n    except TypeError:\n        return \",\".join(map(str, x))\n</code></pre>"},{"location":"reference/genet/output/spatial/","title":"genet.output.spatial","text":""},{"location":"reference/genet/output/spatial/#genet.output.spatial.generate_geodataframes","title":"<code>generate_geodataframes(graph)</code>","text":"Source code in <code>src/genet/output/spatial.py</code> <pre><code>def generate_geodataframes(graph):\n    def line_geometry():\n        from_node = nodes.loc[_u, :]\n        to_node = nodes.loc[_v, :]\n        return LineString(\n            [\n                (float(from_node[\"x\"]), float(from_node[\"y\"])),\n                (float(to_node[\"x\"]), float(to_node[\"y\"])),\n            ]\n        )\n\n    crs = graph.graph[\"crs\"]\n\n    node_ids, data = zip(*graph.nodes(data=True))\n    geometry = [Point(float(d[\"x\"]), float(d[\"y\"])) for d in data]\n    nodes = gpd.GeoDataFrame(data, index=node_ids, crs=crs, geometry=geometry)\n    nodes.index = nodes.index.set_names([\"index\"])\n\n    u, v, data = zip(*graph.edges(data=True))\n    geometry = []\n    for _u, _v, d in zip(u, v, data):\n        try:\n            geom = d[\"geometry\"]\n        except KeyError:\n            geom = line_geometry()\n        geometry.append(geom)\n    links = gpd.GeoDataFrame(data, crs=crs, geometry=geometry)\n    links[\"u\"] = u\n    links[\"v\"] = v\n    if \"id\" in links.columns:\n        links = links.set_index(\"id\", drop=False)\n    links.index = links.index.set_names([\"index\"])\n\n    return {\"nodes\": nodes, \"links\": links}\n</code></pre>"},{"location":"reference/genet/output/spatial/#genet.output.spatial.generate_headway_geojson","title":"<code>generate_headway_geojson(n, gdf, output_dir, filename_suffix)</code>","text":"Source code in <code>src/genet/output/spatial.py</code> <pre><code>def generate_headway_geojson(n, gdf, output_dir, filename_suffix):\n    headways = n.schedule.headway_stats()\n    headways_gdf = gdf[[\"route_id\", \"geometry\"]].merge(headways, how=\"right\", on=\"route_id\")\n    save_geodataframe(headways_gdf.to_crs(EPSG4326), f\"headway_stats_{filename_suffix}\", output_dir)\n</code></pre>"},{"location":"reference/genet/output/spatial/#genet.output.spatial.generate_speed_geojson","title":"<code>generate_speed_geojson(n, gdf, output_dir, filename_suffix)</code>","text":"Source code in <code>src/genet/output/spatial.py</code> <pre><code>def generate_speed_geojson(n, gdf, output_dir, filename_suffix):\n    speeds = n.schedule.speed_geodataframe()\n    # fill infinity by large number to show up in visualisations\n    speeds.loc[speeds[\"speed\"] == math.inf, \"speed\"] = 9999\n\n    speeds = (\n        speeds.groupby([\"service_id\", \"route_id\", \"route_name\", \"mode\"])\n        .max()[\"speed\"]\n        .reset_index()\n    )\n    speeds_gdf = gdf[[\"route_id\", \"geometry\"]].merge(speeds, how=\"right\", on=\"route_id\")\n    save_geodataframe(speeds_gdf.to_crs(EPSG4326), f\"max_speeds_{filename_suffix}\", output_dir)\n</code></pre>"},{"location":"reference/genet/output/spatial/#genet.output.spatial.generate_standard_outputs","title":"<code>generate_standard_outputs(n, output_dir, gtfs_day='19700101', filetype='parquet', schedule_network_factor=1.3)</code>","text":"<p>Generates spatial files that can be used for generating standard visualisations.</p> PARAMETER DESCRIPTION <code>n</code> <p>Schedule to generate outputs for.</p> <p> TYPE: <code>Network</code> </p> <code>output_dir</code> <p>Path to folder where to save the file.</p> <p> TYPE: <code>str</code> </p> <code>gtfs_day</code> <p>Day in format YYYYMMDD for the network's schedule for consistency in visualisations, Defaults to \"19700101\" (1970-01-01).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> <code>filetype</code> <p>The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported. Defaults to parquet format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parquet'</code> </p> <code>schedule_network_factor</code> <p>Factor to apply to beeline distances between Schedule stops when computing speed.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.3</code> </p> Source code in <code>src/genet/output/spatial.py</code> <pre><code>def generate_standard_outputs(\n    n, output_dir, gtfs_day=\"19700101\", filetype: str = \"parquet\", schedule_network_factor=1.3\n):\n    \"\"\"Generates spatial files that can be used for generating standard visualisations.\n\n    Args:\n        n (genet.Network): Schedule to generate outputs for.\n        output_dir (str): Path to folder where to save the file.\n        gtfs_day (str, optional):\n            Day in format YYYYMMDD for the network's schedule for consistency in visualisations,\n            Defaults to \"19700101\" (1970-01-01).\n        filetype (str, optional):\n            The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported.\n            Defaults to parquet format.\n        schedule_network_factor (float, optional):\n            Factor to apply to beeline distances between Schedule stops when computing speed.\n    \"\"\"\n    logging.info(f\"Generating spatial outputs for the entire network in {output_dir}\")\n    n.write_spatial(output_dir, epsg=\"epsg:4326\", filetype=filetype)\n\n    graph_links = n.to_geodataframe()[\"links\"].to_crs(\"epsg:4326\")\n\n    logging.info(\"Generating geojson outputs for car/driving modal subgraph\")\n    graph_output_dir = os.path.join(output_dir, \"graph\")\n    gdf_car = graph_links.loc[graph_links.apply(lambda x: modal_subset(x, {\"car\"}), axis=1), :]\n    for attribute in [\"freespeed\", \"capacity\", \"permlanes\"]:\n        try:\n            save_geodataframe(\n                gdf_car[[attribute, \"geometry\", \"id\"]],\n                filename=f\"car_{attribute}_subgraph\",\n                output_dir=graph_output_dir,\n                filetype=filetype,\n            )\n        except KeyError:\n            logging.warning(f\"Your network is missing a vital attribute {attribute}\")\n\n    logging.info(\"Generating geojson outputs for different highway tags in car modal subgraph\")\n    highway_tags = n.link_attribute_data_under_key({\"attributes\": \"osm:way:highway\"})\n    highway_tags = set(chain.from_iterable(highway_tags.apply(lambda x: persistence.setify(x))))\n    for tag in highway_tags:\n        tag_links = n.extract_links_on_edge_attributes(\n            conditions={\"attributes\": {\"osm:way:highway\": tag}}, mixed_dtypes=True\n        )\n        save_geodataframe(\n            graph_links[graph_links[\"id\"].isin(tag_links)],\n            filename=f\"car_osm_highway_{tag}\",\n            output_dir=graph_output_dir,\n            filetype=filetype,\n        )\n\n    for mode in n.modes():\n        logging.info(f\"Generating geometry-only geojson outputs for {mode} modal subgraph\")\n        gdf = graph_links[graph_links.apply(lambda x: modal_subset(x, {mode}), axis=1)]\n        save_geodataframe(\n            gdf[[\"geometry\", \"id\"]],\n            filename=f\"subgraph_geometry_{mode}\",\n            output_dir=os.path.join(graph_output_dir, \"geometry_only_subgraphs\"),\n            filetype=filetype,\n        )\n\n    # schedule outputs\n    if n.schedule:\n        generate_standard_outputs_for_schedule(\n            n.schedule,\n            output_dir=os.path.join(output_dir, \"schedule\"),\n            gtfs_day=gtfs_day,\n            filetype=filetype,\n            schedule_network_factor=schedule_network_factor,\n            gdf_network_links=graph_links,\n        )\n\n        logging.info(\"Generating PT network routes\")\n        gdf_routes = n.schedule_network_routes_geodataframe().to_crs(\"epsg:4326\")\n        save_geodataframe(\n            gdf_routes,\n            filename=\"schedule_network_routes_geodataframe\",\n            output_dir=os.path.join(output_dir, \"routing\"),\n            filetype=filetype,\n        )\n\n    summary_report = n.summary_report()\n    with open(os.path.join(output_dir, \"summary_report.json\"), \"w\", encoding=\"utf-8\") as f:\n        json.dump(sanitiser.sanitise_dictionary(summary_report), f, ensure_ascii=False, indent=4)\n</code></pre>"},{"location":"reference/genet/output/spatial/#genet.output.spatial.generate_standard_outputs_for_schedule","title":"<code>generate_standard_outputs_for_schedule(schedule, output_dir, gtfs_day='19700101', filetype='parquet', schedule_network_factor=1.3, gdf_network_links=None)</code>","text":"<p>Generates spatial files that can be used for generating standard visualisations.</p> PARAMETER DESCRIPTION <code>schedule</code> <p>Schedule to generate outputs for.</p> <p> TYPE: <code>Schedule</code> </p> <code>output_dir</code> <p>Path to folder where to save the file.</p> <p> TYPE: <code>str</code> </p> <code>gtfs_day</code> <p>Day in format YYYYMMDD for the network's schedule for consistency in visualisations, Defaults to \"19700101\" (1970-01-01).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> <code>filetype</code> <p>The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported. Defaults to parquet format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parquet'</code> </p> <code>schedule_network_factor</code> <p>Factor to apply to beeline distances between stops when computing speed.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.3</code> </p> <code>gdf_network_links</code> <p>GeoDataFrame of network links that are referenced in the Schedule.</p> <p> TYPE: <code>GeoDataFrame</code> DEFAULT: <code>None</code> </p> Source code in <code>src/genet/output/spatial.py</code> <pre><code>def generate_standard_outputs_for_schedule(\n    schedule,\n    output_dir: str,\n    gtfs_day: str = \"19700101\",\n    filetype: str = \"parquet\",\n    schedule_network_factor=1.3,\n    gdf_network_links=None,\n):\n    \"\"\"Generates spatial files that can be used for generating standard visualisations.\n\n    Args:\n        schedule (genet.Schedule): Schedule to generate outputs for.\n        output_dir (str): Path to folder where to save the file.\n        gtfs_day (str, optional):\n            Day in format YYYYMMDD for the network's schedule for consistency in visualisations,\n            Defaults to \"19700101\" (1970-01-01).\n        filetype (str, optional):\n            The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported.\n            Defaults to parquet format.\n        schedule_network_factor (float, optional):\n            Factor to apply to beeline distances between stops when computing speed.\n        gdf_network_links (gpd.GeoDataFrame):\n            GeoDataFrame of network links that are referenced in the Schedule.\n    \"\"\"\n    logging.info(\"Generating spatial standard outputs for schedule\")\n    schedule_links = schedule.to_geodataframe()[\"links\"].to_crs(\"epsg:4326\")\n    df = schedule.trips_with_stops_to_dataframe(gtfs_day=gtfs_day)\n    df_all_modes_vph = None\n\n    vph_dir = os.path.join(output_dir, \"vehicles_per_hour\")\n    subgraph_dir = os.path.join(output_dir, \"subgraphs\")\n    graph_mode_map = schedule.mode_graph_map()\n    for mode in schedule.modes():\n        logging.info(f\"Generating vehicles per hour for {mode}\")\n        df_vph = use_schedule.generate_edge_vph_geodataframe(df[df[\"mode\"] == mode], schedule_links)\n        save_geodataframe(\n            df_vph, filename=f\"vehicles_per_hour_{mode}\", output_dir=vph_dir, filetype=filetype\n        )\n\n        if df_all_modes_vph is None:\n            df_vph[\"mode\"] = mode\n            df_all_modes_vph = df_vph\n        else:\n            df_vph[\"mode\"] = mode\n            df_all_modes_vph = pd.concat([df_all_modes_vph, df_vph])\n\n        logging.info(f\"Generating schedule graph for {mode}\")\n        schedule_subgraph = generate_geodataframes(schedule.subgraph(graph_mode_map[mode]))\n        save_geodataframe(\n            schedule_subgraph[\"links\"].to_crs(\"epsg:4326\"),\n            filename=f\"schedule_subgraph_links_{mode}\",\n            output_dir=subgraph_dir,\n            filetype=filetype,\n        )\n        save_geodataframe(\n            schedule_subgraph[\"nodes\"].to_crs(\"epsg:4326\"),\n            filename=f\"schedule_subgraph_nodes_{mode}\",\n            output_dir=subgraph_dir,\n            filetype=filetype,\n        )\n\n    logging.info(\"Saving vehicles per hour for all PT modes\")\n    save_geodataframe(\n        df_all_modes_vph,\n        filename=\"vehicles_per_hour_all_modes\",\n        output_dir=vph_dir,\n        filetype=filetype,\n    )\n    logging.info(\"Saving vehicles per hour for all PT modes for selected hour slices\")\n    for h in [7, 8, 9, 13, 16, 17, 18]:\n        save_geodataframe(\n            df_all_modes_vph[pd.to_datetime(df_all_modes_vph[\"hour\"]).dt.hour == h],\n            filename=f\"vph_all_modes_within_{h - 1}_30-{h}_30\",\n            output_dir=vph_dir,\n            filetype=filetype,\n        )\n\n    logging.info(\n        f\"Generating stop-to-stop speed outputs with network_factor={schedule_network_factor}\"\n    )\n    speed_dir = os.path.join(output_dir, \"speed\")\n    speeds_gdf = schedule.speed_geodataframe(\n        network_factor=schedule_network_factor, gdf_network_links=gdf_network_links\n    )\n    save_geodataframe(\n        speeds_gdf[\n            [\"service_id\", \"route_id\", \"mode\", \"from_stop\", \"to_stop\", \"routed_speed\", \"geometry\"]\n        ],\n        filename=\"pt_network_speeds\",\n        output_dir=speed_dir,\n        filetype=filetype,\n    )\n    speeds_gdf = gpd.GeoDataFrame(\n        pd.merge(\n            speeds_gdf.drop(\"geometry\", axis=1),\n            schedule_links[[\"u\", \"v\", \"geometry\"]],\n            left_on=[\"from_stop\", \"to_stop\"],\n            right_on=[\"u\", \"v\"],\n        ),\n        crs=schedule_links.crs,\n    )\n    save_geodataframe(\n        speeds_gdf[[\"service_id\", \"route_id\", \"mode\", \"from_stop\", \"to_stop\", \"speed\", \"geometry\"]],\n        filename=\"pt_speeds\",\n        output_dir=speed_dir,\n        filetype=filetype,\n    )\n\n    logging.info(\"Generating csv for vehicles per hour for each service\")\n    use_schedule.vehicles_per_hour(\n        df,\n        aggregate_by=[\"service_id\", \"service_name\", \"mode\"],\n        output_path=os.path.join(vph_dir, \"vph_per_service.csv\"),\n    )\n\n    logging.info(\"Generating csv for vehicles per hour per stop\")\n    use_schedule.vehicles_per_hour(\n        df,\n        aggregate_by=[\"from_stop\", \"from_stop_name\", \"mode\"],\n        output_path=os.path.join(vph_dir, \"vph_per_stop_departing_from.csv\"),\n    )\n    use_schedule.vehicles_per_hour(\n        df,\n        aggregate_by=[\"to_stop\", \"to_stop_name\", \"mode\"],\n        output_path=os.path.join(vph_dir, \"vph_per_stop_arriving_at.csv\"),\n    )\n\n    logging.info(\"Generating csvs for trips per day\")\n    use_schedule.trips_per_day_per_service(df, output_dir=output_dir)\n    df_trips_per_route = use_schedule.trips_per_day_per_route(df, output_dir=output_dir)\n\n    # stop-to-stop trips per day aggregation\n    aggregated_per_stops = use_schedule.aggregate_trips_per_day_per_route_by_end_stop_pairs(\n        schedule, df_trips_per_route\n    )\n    aggregated_per_stops.to_csv(\n        os.path.join(output_dir, \"trips_per_day_per_route_aggregated_per_stop_id_pair.csv\")\n    )\n    use_schedule.aggregate_by_stop_names(aggregated_per_stops).to_csv(\n        os.path.join(output_dir, \"trips_per_day_per_route_aggregated_per_stop_name_pair.csv\")\n    )\n</code></pre>"},{"location":"reference/genet/output/spatial/#genet.output.spatial.modal_subset","title":"<code>modal_subset(row, modes)</code>","text":"Source code in <code>src/genet/output/spatial.py</code> <pre><code>def modal_subset(row, modes):\n    row_modes = set(row[\"modes\"])\n    if modes &amp; row_modes:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/","title":"genet.schedule_elements","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.SPATIAL_TOLERANCE","title":"<code>SPATIAL_TOLERANCE = 8</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route","title":"<code>Route(route_short_name, mode, arrival_offsets, departure_offsets, trips=None, headway_spec=None, network_links=None, route_long_name='', id='', await_departure=None, stops=None, **kwargs)</code>","text":"<p>               Bases: <code>ScheduleElement</code></p> <p>A Route is an object which contains information about the trips, times and offsets, mode and name of the route which forms a part of a Service.</p> <p>Note</p> <p>Not providing some of the optional parameters may result in the object failing validation.</p> PARAMETER DESCRIPTION <code>route_short_name</code> <p>route's short name.</p> <p> TYPE: <code>str</code> </p> <code>mode</code> <p>mode.</p> <p> TYPE: <code>str</code> </p> <code>arrival_offsets</code> <p>list of 'HH:MM:SS' temporal offsets for each of the stops_mapping.</p> <p> TYPE: <code>list[str]</code> </p> <code>departure_offsets</code> <p>list of 'HH:MM:SS' temporal offsets for each of the stops_mapping.</p> <p> TYPE: <code>list[str]</code> </p> <code>trips</code> <p>Provide either detailed trip information of headway specification dictionary with keys: 'trip_id', 'trip_departure_time', 'vehicle_id'. Each value is a list e.g. : <pre><code>{\n    'trip_id': ['trip_1', 'trip_2'],  # IDs of trips, unique within the Route\n    'trip_departure_time': ['HH:MM:SS', 'HH:MM:SS'],  # departure time from first stop for each trip_id\n    'vehicle_id': [veh_1, veh_2]} # vehicle IDs for each trip_id, don't need to be unique (i.e. vehicles can be shared between trips, but it's up to you to make this physically possible).\n}\n</code></pre> Defaults to None.</p> <p> TYPE: <code>Optional[dict[str, list[str]]]</code> DEFAULT: <code>None</code> </p> <code>headway_spec</code> <p>Dictionary with tuple keys: (from time, to time) and headway values in minutes: <code>{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}</code>. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>network_links</code> <p>Network link_ids traversed by the vehicles in this Route instance. Defaults to None.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>route_long_name</code> <p>Verbose name for the route if exists. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>id</code> <p>Unique identifier for the route if available, if not given, will be generated. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>await_departure</code> <p>List of bools of length stops param, whether to await departure at each stop. Defaults to None.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>stops</code> <p>Ordered list of Stop class objects or Stop IDs already present in a Schedule, if generating a Route to add. Defaults to None.</p> <p> TYPE: <code>Optional[list[Union[Stop, str]]]</code> DEFAULT: <code>None</code> </p> <p>Keyword Args: Additional attributes which will be attached to the class.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def __init__(\n    self,\n    route_short_name: str,\n    mode: str,\n    arrival_offsets: list[str],\n    departure_offsets: list[str],\n    trips: Optional[dict[str, list[str]]] = None,\n    headway_spec: Optional[dict] = None,\n    network_links: Optional[list] = None,\n    route_long_name: str = \"\",\n    id: str = \"\",\n    await_departure: Optional[list] = None,\n    stops: Optional[list[Union[Stop, str]]] = None,\n    **kwargs,\n):\n    \"\"\"A Route is an object which contains information about the trips, times and offsets, mode and name of the route which forms a part of a Service.\n\n    !!! note\n        Not providing some of the optional parameters may result in the object failing validation.\n\n    Args:\n        route_short_name (str): route's short name.\n        mode (str):  mode.\n        arrival_offsets (list[str]): list of 'HH:MM:SS' temporal offsets for each of the stops_mapping.\n        departure_offsets (list[str]): list of 'HH:MM:SS' temporal offsets for each of the stops_mapping.\n        trips (Optional[dict[str, list[str]]], optional):\n            Provide either detailed trip information of headway specification dictionary with keys: 'trip_id', 'trip_departure_time', 'vehicle_id'.\n            Each value is a list e.g. :\n            ```python\n            {\n                'trip_id': ['trip_1', 'trip_2'],  # IDs of trips, unique within the Route\n                'trip_departure_time': ['HH:MM:SS', 'HH:MM:SS'],  # departure time from first stop for each trip_id\n                'vehicle_id': [veh_1, veh_2]} # vehicle IDs for each trip_id, don't need to be unique (i.e. vehicles can be shared between trips, but it's up to you to make this physically possible).\n            }\n            ```\n            Defaults to None.\n        headway_spec (Optional[dict], optional):\n            Dictionary with tuple keys: (from time, to time) and headway values in minutes:\n            `{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}`.\n            Defaults to None.\n        network_links (Optional[list], optional):\n            Network link_ids traversed by the vehicles in this Route instance. Defaults to None.\n        route_long_name (str, optional):\n            Verbose name for the route if exists. Defaults to \"\".\n        id (str, optional):\n            Unique identifier for the route if available, if not given, will be generated. Defaults to \"\".\n        await_departure (Optional[list], optional):\n            List of bools of length stops param, whether to await departure at each stop. Defaults to None.\n        stops (Optional[list[Union[Stop, str]]], optional):\n            Ordered list of Stop class objects or Stop IDs already present in a Schedule, if generating a Route to add.\n            Defaults to None.\n\n    Keyword Args: Additional attributes which will be attached to the class.\n\n    \"\"\"\n    self.route_short_name = route_short_name\n    self.mode = mode\n    self.arrival_offsets = arrival_offsets\n    self.departure_offsets = departure_offsets\n    self.route_long_name = route_long_name\n    self.id = id\n    ordered_stops = None\n    _graph = None\n    if trips is not None:\n        self.trips = trips\n    elif headway_spec is not None:\n        self.generate_trips_from_headway(headway_spec)\n    else:\n        raise RouteInitialisationError(\n            \"Please provide trip or headway information to initialise Route object\"\n        )\n\n    if network_links is None:\n        self.network_links = []\n    else:\n        self.network_links = network_links\n    if await_departure is None:\n        self.await_departure = []\n    else:\n        self.await_departure = await_departure\n    if kwargs:\n        if \"ordered_stops\" in kwargs:\n            ordered_stops = kwargs.pop(\"ordered_stops\")\n        if \"_graph\" in kwargs:\n            _graph = kwargs.pop(\"_graph\")\n        self.add_additional_attributes(kwargs)\n\n    if ordered_stops is not None:\n        if _graph is not None:\n            # check graph type and schema\n            verify_graph_schema(_graph)\n            self._graph = _graph\n        else:\n            raise RouteInitialisationError(\n                \"When passing `ordered_stops` you are expected to pass `_graph` too. \"\n                \"You may prefer to pass a list of Stop objects to `stops` instead\"\n            )\n        # check all stops in _graph\n        if not self._stop_ids_in_graph(ordered_stops):\n            raise RouteInitialisationError(\n                \"Some stop IDs passed in `ordered_stops` are missing from the _graph \"\n                \"object passed\"\n            )\n        self.ordered_stops = ordered_stops\n    elif stops is not None:\n        try:\n            self.ordered_stops = [stop.id for stop in stops]\n        except AttributeError:\n            self.ordered_stops = stops\n        self._graph = self._build_graph(stops=stops)\n    else:\n        raise RouteInitialisationError(\n            \"You need to either pass `ordered_stops` with a valid `_graph` or \"\n            \"a list of Stop objects to `stops`\"\n        )\n    super().__init__()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.arrival_offsets","title":"<code>arrival_offsets = arrival_offsets</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.await_departure","title":"<code>await_departure = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.departure_offsets","title":"<code>departure_offsets = departure_offsets</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.id","title":"<code>id = id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.mode","title":"<code>mode = mode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.network_links","title":"<code>network_links = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.ordered_stops","title":"<code>ordered_stops = [stop.id for stop in stops]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.route_long_name","title":"<code>route_long_name = route_long_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.route_short_name","title":"<code>route_short_name = route_short_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.trips","title":"<code>trips = trips</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.crowfly_distance","title":"<code>crowfly_distance()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def crowfly_distance(self):\n    distance = 0\n    for prev_stop, next_stop in zip(self.ordered_stops[:-1], self.ordered_stops[1:]):\n        # todo replace by accessing graph nodes\n        distance += spatial.distance_between_s2cellids(\n            self.stop(prev_stop).s2_id, self.stop(next_stop).s2_id\n        )\n    return distance\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.divide_network_links_between_stops","title":"<code>divide_network_links_between_stops()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def divide_network_links_between_stops(self):\n    if self.has_network_links():\n        stops_linkrefids = [self._graph.nodes[i][\"linkRefId\"] for i in self.ordered_stops]\n        if not stops_linkrefids:\n            raise RuntimeError(\n                \"This Stops in this Route are not snapped to the network via `linkRefId` attribute\"\n            )\n        return use_schedule.divide_network_route(self.network_links, stops_linkrefids)\n    else:\n        raise RuntimeError(\"This Route does not have a network route to divide\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.generate_trips_from_headway","title":"<code>generate_trips_from_headway(headway_spec)</code>","text":"<p>Generates new trips for the route.</p> <p>All newly generated trips get unique vehicles with this method.</p> PARAMETER DESCRIPTION <code>headway_spec</code> <p>dictionary with tuple keys: (from time, to time) and headway values in minutes: <code>{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}</code>.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def generate_trips_from_headway(self, headway_spec: dict):\n    \"\"\"Generates new trips for the route.\n\n    All newly generated trips get unique vehicles with this method.\n\n    Args:\n        headway_spec (dict):\n            dictionary with tuple keys: (from time, to time) and headway values in minutes:\n            `{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}`.\n    \"\"\"\n    new_trip_departures = list(generate_trip_departures_from_headway(headway_spec))\n    new_trip_departures.sort()\n    new_trip_departures = [t.strftime(\"%H:%M:%S\") for t in new_trip_departures]\n\n    trips = {\n        \"trip_id\": [f\"{self.id}_{t}\" for t in new_trip_departures],\n        \"trip_departure_time\": new_trip_departures,\n        \"vehicle_id\": [f\"veh_{self.mode}_{self.id}_{t}\" for t in new_trip_departures],\n    }\n    if \"trips\" in self.__dict__:\n        self._graph.graph[\"routes\"][self.id][\"trips\"] = trips\n        self._graph.graph[\"change_log\"] = self.change_log().modify(\n            object_type=\"route\",\n            old_id=self.id,\n            old_attributes=self.trips,\n            new_id=self.id,\n            new_attributes=trips,\n        )\n    self.trips = trips\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.has_correctly_ordered_route","title":"<code>has_correctly_ordered_route()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_correctly_ordered_route(self):\n    if self.has_network_links():\n        stops_linkrefids = [\n            self._graph.nodes[i][\"linkRefId\"]\n            for i in self.ordered_stops\n            if \"linkRefId\" in self._graph.nodes[i]\n        ]\n        if len(stops_linkrefids) != len(self.ordered_stops):\n            logging.warning(\"Not all stops reference network link ids.\")\n            return False\n        divided_route = self.divide_network_links_between_stops()\n        if not divided_route:\n            return False\n        reassembled_route = sum(divided_route, [])\n        reassembled_route = [reassembled_route[0]] + [\n            reassembled_route[i]\n            for i in range(1, len(reassembled_route))\n            if reassembled_route[i - 1] != reassembled_route[i]\n        ]\n        if (len(stops_linkrefids) - 1) == len(divided_route) and (\n            reassembled_route == self.network_links\n        ):\n            return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.has_id","title":"<code>has_id()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_id(self):\n    return self.id\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.has_more_than_one_stop","title":"<code>has_more_than_one_stop()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_more_than_one_stop(self):\n    if len(self.ordered_stops) &gt; 1:\n        return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.has_network_links","title":"<code>has_network_links()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_network_links(self) -&gt; bool:\n    return bool(self.network_links)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.has_self_loops","title":"<code>has_self_loops()</code>","text":"<p>Means that there are two consecutive stops that are the same</p> RETURNS DESCRIPTION <code>list</code> <p>All self-loops.</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_self_loops(self) -&gt; list:\n    \"\"\"Means that there are two consecutive stops that are the same\n\n    Returns:\n        list: All self-loops.\n    \"\"\"\n    return list(nx.nodes_with_selfloops(self.graph()))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.has_valid_offsets","title":"<code>has_valid_offsets()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_valid_offsets(self):\n    if not self.arrival_offsets or not self.departure_offsets:\n        return False\n    elif len(self.arrival_offsets) != len(self.ordered_stops) or len(\n        self.departure_offsets\n    ) != len(self.ordered_stops):\n        return False\n    for arr_offset, dep_offset in zip(self.arrival_offsets, self.departure_offsets):\n        dt_arr_offset = datetime.strptime(arr_offset, \"%H:%M:%S\")\n        dt_dep_offset = datetime.strptime(dep_offset, \"%H:%M:%S\")\n        if dt_arr_offset &gt; dt_dep_offset:\n            return False\n    for next_arr_offset, prev_dep_offset in zip(\n        self.arrival_offsets[1:], self.departure_offsets[:-1]\n    ):\n        dt_next_arr_offset = datetime.strptime(next_arr_offset, \"%H:%M:%S\")\n        dt_prev_dep_offset = datetime.strptime(prev_dep_offset, \"%H:%M:%S\")\n        if dt_next_arr_offset &lt; dt_prev_dep_offset:\n            return False\n    return True\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.info","title":"<code>info()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def info(self):\n    return \"{} ID: {}\\nName: {}\\nNumber of stops: {}\\nNumber of trips: {}\".format(\n        self.__class__.__name__,\n        self.id,\n        self.route_short_name,\n        len(self.ordered_stops),\n        len(self.trips[\"trip_id\"]),\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.is_exact","title":"<code>is_exact(other)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_exact(self, other):\n    same_route_name = self.route_short_name == other.route_short_name\n    same_mode = self.mode.lower() == other.mode.lower()\n    same_stops = list(self.stops()) == list(other.stops())\n    same_trips = self.trips == other.trips\n    same_arrival_offsets = self.arrival_offsets == other.arrival_offsets\n    same_departure_offsets = self.departure_offsets == other.departure_offsets\n\n    statement = (\n        same_route_name\n        and same_mode\n        and same_stops\n        and same_trips\n        and same_arrival_offsets\n        and same_departure_offsets\n    )\n    return statement\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.is_strongly_connected","title":"<code>is_strongly_connected()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_strongly_connected(self):\n    if nx.number_strongly_connected_components(self.graph()) == 1:\n        return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.is_valid_route","title":"<code>is_valid_route(return_reason=False)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_valid_route(self, return_reason=False):\n    invalid_stages = []\n    valid = True\n\n    if not self.has_more_than_one_stop():\n        valid = False\n        invalid_stages.append(\"not_has_more_than_one_stop\")\n\n    if not bool(self.has_correctly_ordered_route()):\n        valid = False\n        invalid_stages.append(\"not_has_correctly_ordered_route\")\n\n    if not bool(self.has_valid_offsets()):\n        valid = False\n        invalid_stages.append(\"not_has_valid_offsets\")\n\n    if bool(self.has_self_loops()):\n        valid = False\n        invalid_stages.append(\"has_self_loops\")\n\n    if return_reason:\n        return valid, invalid_stages\n    return valid\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.isin_exact","title":"<code>isin_exact(routes)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def isin_exact(self, routes: list):\n    for other in routes:\n        if self.is_exact(other):\n            return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.modes","title":"<code>modes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def modes(self):\n    return {self.mode}\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.plot","title":"<code>plot(output_dir='', data=False)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def plot(self, output_dir: str = \"\", data: Union[bool, set] = False) -&gt; KeplerGl:\n    return self.kepler_map(output_dir, f\"route_{self.id}_map\", data=data)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.print","title":"<code>print()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def print(self):\n    print(self.info())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.reference_edges","title":"<code>reference_edges()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reference_edges(self):\n    return self.route_reference_edges(self.id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.reference_nodes","title":"<code>reference_nodes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reference_nodes(self):\n    return self.route_reference_nodes(self.id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.reindex","title":"<code>reindex(new_id)</code>","text":"<p>Changes the current index of the object to <code>new_id</code>.</p> PARAMETER DESCRIPTION <code>new_id</code> <p>desired value of the new index</p> <p> TYPE: <code>Union[str, int]</code> </p> RAISES DESCRIPTION <code>RouteIndexError</code> <p>New ID cannot already exist.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reindex(self, new_id: Union[str, int]):\n    \"\"\"Changes the current index of the object to `new_id`.\n\n    Args:\n        new_id (Union[str, int]): desired value of the new index\n\n    Raises:\n        RouteIndexError: New ID cannot already exist.\n    \"\"\"\n    if not self._index_unique(new_id):\n        raise RouteIndexError(f\"Route of index {new_id} already exists\")\n    if self.id != new_id:\n        # change data on graph\n        nodes = self.reference_nodes()\n        self._remove_routes_from_nodes(nodes=nodes, route_ids={self.id})\n        self._add_routes_to_nodes(nodes=nodes, route_ids={new_id})\n        edges = self.reference_edges()\n        self._remove_routes_from_edges(edges=edges, route_ids={self.id})\n        self._add_routes_to_edges(edges=edges, route_ids={new_id})\n        self._graph.graph[\"routes\"][new_id] = self._graph.graph[\"routes\"][self.id]\n        self._graph.graph[\"routes\"][new_id][\"id\"] = new_id\n        del self._graph.graph[\"routes\"][self.id]\n\n        if \"route_to_service_map\" in self._graph.graph:\n            # if route is tied to a service, update the indexing\n            corresponding_service_id = self._graph.graph[\"route_to_service_map\"][self.id]\n            self._graph.graph[\"service_to_route_map\"][corresponding_service_id] = list(\n                set(self._graph.graph[\"service_to_route_map\"][corresponding_service_id])\n                - {self.id}\n                | {new_id}\n            )\n            self._graph.graph[\"route_to_service_map\"][new_id] = corresponding_service_id\n            del self._graph.graph[\"route_to_service_map\"][self.id]\n\n        self._graph.graph[\"change_log\"].modify(\n            object_type=\"route\",\n            old_id=self.id,\n            new_id=new_id,\n            old_attributes={\"id\": self.id},\n            new_attributes={\"id\": new_id},\n        )\n        logging.info(f\"Reindexed Route from {self.id} to {new_id}\")\n        self.id = new_id\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.route","title":"<code>route(route_id)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route(self, route_id: Union[str, int]) -&gt; \"Route\":\n    if route_id == self.id:\n        return self\n    else:\n        raise IndexError(f\"{route_id} does not match Route's id: {self.id}\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.route_attribute_data","title":"<code>route_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_attribute_data(\n    self, keys: Union[list, str], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    return graph_operations.build_attribute_dataframe(\n        iterator=[(self.id, self.__dict__)], keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.routes","title":"<code>routes()</code>","text":"<p>This iterator is on the same level as the object and yields itself</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def routes(self):\n    \"\"\"\n    This iterator is on the same level as the object and yields itself\n    \"\"\"\n    yield self\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.service_attribute_data","title":"<code>service_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_attribute_data(\n    self, keys: Union[list, str], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    raise ServiceIndexError(\"A Route cannot generate a DataFrame with Services data\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.stop_attribute_data","title":"<code>stop_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stop_attribute_data(\n    self, keys: Union[list, str], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    return graph_operations.build_attribute_dataframe(\n        iterator=[(s.id, s.__dict__) for s in self.stops()], keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.stops","title":"<code>stops()</code>","text":"YIELDS DESCRIPTION <code>Stop</code> <p>Iterable returns Stop objects in the Route in order of travel</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stops(self) -&gt; Iterator[\"Stop\"]:\n    \"\"\"\n    Yields:\n        Iterable returns Stop objects in the Route in order of travel\n    \"\"\"\n    for s in self.ordered_stops:\n        yield self.stop(s)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.trips_to_dataframe","title":"<code>trips_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def trips_to_dataframe(self, gtfs_day=\"19700101\"):\n    df = pd.DataFrame(self.trips)\n\n    df[\"route_id\"] = self.id\n    df[\"trip_departure_time\"] = df[\"trip_departure_time\"].apply(\n        lambda x: use_schedule.sanitise_time(x, gtfs_day)\n    )\n    df[\"mode\"] = self.mode\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.trips_with_stops_to_dataframe","title":"<code>trips_with_stops_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def trips_with_stops_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    df = None\n    _df = DataFrame(\n        {\n            \"departure_time\": [\n                use_schedule.get_offset(self.departure_offsets[i])\n                for i in range(len(self.ordered_stops) - 1)\n            ],\n            \"arrival_time\": [\n                use_schedule.get_offset(self.arrival_offsets[i])\n                for i in range(1, len(self.ordered_stops))\n            ],\n            \"from_stop\": self.ordered_stops[:-1],\n            \"to_stop\": self.ordered_stops[1:],\n        }\n    )\n    for trip_id, trip_dep_time, veh_id in zip(\n        self.trips[\"trip_id\"], self.trips[\"trip_departure_time\"], self.trips[\"vehicle_id\"]\n    ):\n        trip_df = _df.copy()\n        trip_df[\"trip_id\"] = trip_id\n        trip_df[\"vehicle_id\"] = veh_id\n        trip_dep_time = use_schedule.sanitise_time(trip_dep_time, gtfs_day=gtfs_day)\n        trip_df[\"departure_time\"] = trip_dep_time + trip_df[\"departure_time\"]\n        trip_df[\"arrival_time\"] = trip_dep_time + trip_df[\"arrival_time\"]\n        if df is None:\n            df = trip_df\n        else:\n            df = pd.concat([df, trip_df])\n    df[\"route_id\"] = self.id\n    df[\"route_name\"] = self.route_short_name.replace(\"\\\\\", \"_\").replace(\"/\", \"_\")\n    df[\"mode\"] = self.mode\n    df[\"from_stop_name\"] = df[\"from_stop\"].apply(\n        lambda x: self.stop(x).name.replace(\"\\\\\", \"_\").replace(\"/\", \"_\")\n    )\n    df[\"to_stop_name\"] = df[\"to_stop\"].apply(\n        lambda x: self.stop(x).name.replace(\"\\\\\", \"_\").replace(\"/\", \"_\")\n    )\n    df = df.reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Route.vehicles","title":"<code>vehicles()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def vehicles(self):\n    return set(self.trips[\"vehicle_id\"])\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule","title":"<code>Schedule(epsg='', services=None, _graph=None, minimal_transfer_times=None, vehicles=None, vehicle_types=importlib_resources.files('genet') / 'configs' / 'vehicles' / 'vehicle_definitions.yml'.as_posix(), **kwargs)</code>","text":"<p>               Bases: <code>ScheduleElement</code></p> <p>Class to provide methods and structure for transit schedules.</p> PARAMETER DESCRIPTION <code>epsg</code> <p>Projection for the schedule (each stop has its own epsg), e.g. 'epsg:4326'. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>services</code> <p>list of Service class objects. Defaults to None.</p> <p> TYPE: <code>Optional[list[Service]]</code> DEFAULT: <code>None</code> </p> <code>_graph</code> <p>Schedule graph, used for re-instantiating the object, passed without <code>services</code>. Defaults to None.</p> <p> TYPE: <code>Optional[DiGraph]</code> DEFAULT: <code>None</code> </p> <code>minimal_transfer_times</code> <p>Seconds to transfer between <code>stop_id_1</code> and <code>stop_id_2</code>, e.g.: <code>{'stop_id_1': {'stop_id_2': 0.0}}</code>. Defaults to None.</p> <p> TYPE: <code>Optional[dict[str, dict[str, float]]]</code> DEFAULT: <code>None</code> </p> <code>vehicles</code> <p>Dictionary of vehicle IDs from Route objects, mapping them to vehicle types in vehicle_types. Looks like this: <code>{veh_id : {'type': 'bus'}}</code>. Defaults to None and generates itself from the vehicles IDs in Routes, maps to the mode of the Route. Checks if those modes are defined in the vehicle_types.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>vehicle_types</code> <p>YAML file based on <code>genet/configs/vehicles/vehicle_definitions.yml</code> or dictionary of vehicle types and their specification. Indexed by the vehicle type that vehicles in the <code>vehicles</code> attribute are referring to. <pre><code>{'bus' : {\n    'capacity': {'seats': {'persons': '70'}, 'standingRoom': {'persons': '0'}},\n    'length': {'meter': '18.0'},\n    'width': {'meter': '2.5'},\n    'accessTime': {'secondsPerPerson': '0.5'},\n    'egressTime': {'secondsPerPerson': '0.5'},\n    'doorOperation': {'mode': 'serial'},\n    'passengerCarEquivalents': {'pce': '2.8'}}}\n</code></pre> Defaults to reading <code>genet/configs/vehicles/vehicle_definitions.yml</code>.</p> <p> TYPE: <code>Union[str, dict]</code> DEFAULT: <code>as_posix()</code> </p> RAISES DESCRIPTION <code>UndefinedCoordinateSystemError</code> <p>A coordinate reference system must be defined by <code>epsg</code> or within <code>_graph</code>.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def __init__(\n    self,\n    epsg: str = \"\",\n    services: Optional[list[Service]] = None,\n    _graph: Optional[nx.DiGraph] = None,\n    minimal_transfer_times: Optional[dict[str, dict[str, float]]] = None,\n    vehicles: Optional[dict] = None,\n    vehicle_types: Union[str, dict] = (\n        importlib_resources.files(\"genet\") / \"configs\" / \"vehicles\" / \"vehicle_definitions.yml\"\n    ).as_posix(),\n    **kwargs,\n):\n    \"\"\"Class to provide methods and structure for transit schedules.\n\n    Args:\n        epsg (str, optional): Projection for the schedule (each stop has its own epsg), e.g. 'epsg:4326'. Defaults to \"\".\n        services (Optional[list[Service]], optional): list of Service class objects. Defaults to None.\n        _graph (Optional[nx.DiGraph], optional): Schedule graph, used for re-instantiating the object, passed without `services`. Defaults to None.\n        minimal_transfer_times (Optional[dict[str, dict[str, float]]], optional):\n            Seconds to transfer between `stop_id_1` and `stop_id_2`, e.g.: `{'stop_id_1': {'stop_id_2': 0.0}}`.\n            Defaults to None.\n        vehicles (Optional[dict], optional):\n            Dictionary of vehicle IDs from Route objects, mapping them to vehicle types in vehicle_types.\n            Looks like this: `{veh_id : {'type': 'bus'}}`.\n            Defaults to None and generates itself from the vehicles IDs in Routes, maps to the mode of the Route.\n            Checks if those modes are defined in the vehicle_types.\n        vehicle_types (Union[str, dict], optional):\n            YAML file based on `genet/configs/vehicles/vehicle_definitions.yml` or dictionary of vehicle types and their specification.\n            Indexed by the vehicle type that vehicles in the `vehicles` attribute are referring to.\n            ```python\n            {'bus' : {\n                'capacity': {'seats': {'persons': '70'}, 'standingRoom': {'persons': '0'}},\n                'length': {'meter': '18.0'},\n                'width': {'meter': '2.5'},\n                'accessTime': {'secondsPerPerson': '0.5'},\n                'egressTime': {'secondsPerPerson': '0.5'},\n                'doorOperation': {'mode': 'serial'},\n                'passengerCarEquivalents': {'pce': '2.8'}}}\n            ```\n            Defaults to reading `genet/configs/vehicles/vehicle_definitions.yml`.\n\n    Raises:\n        UndefinedCoordinateSystemError: A coordinate reference system must be defined by `epsg` or within `_graph`.\n    \"\"\"\n    if isinstance(vehicle_types, dict):\n        self.vehicle_types = vehicle_types\n    else:\n        self.vehicle_types = read_vehicle_types(vehicle_types)\n\n    if _graph is not None:\n        # check graph type and schema\n        verify_graph_schema(_graph)\n        self._graph = _graph\n        if epsg == \"\":\n            try:\n                epsg = self._graph.graph[\"crs\"]\n            except KeyError:\n                raise UndefinedCoordinateSystemError(\n                    \"You need to specify the coordinate system for the schedule\"\n                )\n    else:\n        if epsg == \"\":\n            raise UndefinedCoordinateSystemError(\n                \"You need to specify the coordinate system for the schedule\"\n            )\n        used_service_indices = []\n        used_route_indices = set()\n        if services is not None:\n            for service in services:\n                idx = service.id\n                route_ids = set(service.route_ids())\n                if idx in used_service_indices:\n                    i = 0\n                    new_idx = idx\n                    while new_idx in used_service_indices:\n                        new_idx = f\"{idx}_{i}\"\n                        i += 1\n                    service.reindex(new_idx)\n                    logging.warning(\n                        f\"Service has been re-indexed from {idx} to {new_idx} due to an ID clash\"\n                    )\n                    idx = new_idx\n                clashing_route_ids = route_ids &amp; used_route_indices\n                for r_id in clashing_route_ids:\n                    # Services index their routes uniquely within themselves\n                    service.route(r_id).reindex(f\"{idx}_{r_id}\")\n                used_route_indices |= set(service.route_ids())\n                used_service_indices.append(idx)\n        else:\n            services = []\n        self._graph = self._build_graph(services)\n    self.init_epsg = epsg\n    self.attributes = {\"crs\": epsg}\n    self.transformer = Transformer.from_crs(epsg, \"epsg:4326\", always_xy=True)\n    if minimal_transfer_times is not None:\n        self.minimal_transfer_times = minimal_transfer_times\n    else:\n        self.minimal_transfer_times = {}\n    if vehicles is None:\n        self.vehicles = {}\n        self.generate_vehicles()\n    else:\n        self.vehicles = vehicles\n    self.validate_vehicle_definitions()\n\n    if kwargs:\n        self.add_additional_attributes(kwargs)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.attributes","title":"<code>attributes = {'crs': epsg}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.init_epsg","title":"<code>init_epsg = epsg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.minimal_transfer_times","title":"<code>minimal_transfer_times = minimal_transfer_times</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.transformer","title":"<code>transformer = Transformer.from_crs(epsg, 'epsg:4326', always_xy=True)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.vehicle_types","title":"<code>vehicle_types = vehicle_types</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.vehicles","title":"<code>vehicles = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.add","title":"<code>add(other, overwrite=True)</code>","text":"<p>Adds another Schedule in-place.</p> <p>They have to be separable! I.e. the keys in services cannot overlap with the ones already present.</p> <p>TODO: add merging complicated schedules, parallels to the merging gtfs work.</p> PARAMETER DESCRIPTION <code>other</code> <p>the other Schedule object to add</p> <p> TYPE: <code>Schedule</code> </p> <code>overwrite</code> <p>If True: overwrites overlapping vehicle types data currently in the Schedule, adds vehicles as they are,     overwriting in case of clash If False: adds vehicles and vehicle types from other that do not clash with those already stored in the Schedule. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>Schedules must not have overlapping services.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def add(self, other: \"Schedule\", overwrite: bool = True):\n    \"\"\"Adds another Schedule in-place.\n\n    They have to be separable! I.e. the keys in services cannot overlap with the ones already present.\n\n    TODO: add merging complicated schedules, parallels to the merging gtfs work.\n\n    Args:\n        other (Schedule): the other Schedule object to add\n        overwrite (bool, optional):\n            If True: overwrites overlapping vehicle types data currently in the Schedule, adds vehicles as they are,\n                overwriting in case of clash\n            If False: adds vehicles and vehicle types from other that do not clash with those already stored in the Schedule.\n            Defaults to True.\n\n    Raises:\n        NotImplementedError: Schedules must not have overlapping services.\n    \"\"\"\n    if not self.is_separable_from(other):\n        # have left and right indicies\n        raise NotImplementedError(\"This method only supports adding non overlapping services.\")\n    elif self.epsg != other.epsg:\n        other.reproject(self.epsg)\n\n    self._graph.graph[\"services\"] = dict_support.merge_complex_dictionaries(\n        other._graph.graph[\"services\"], self._graph.graph[\"services\"]\n    )\n    self._graph.graph[\"routes\"] = dict_support.merge_complex_dictionaries(\n        other._graph.graph[\"routes\"], self._graph.graph[\"routes\"]\n    )\n    self._graph.graph[\"route_to_service_map\"] = {\n        **self._graph.graph[\"route_to_service_map\"],\n        **other._graph.graph[\"route_to_service_map\"],\n    }\n    self._graph.graph[\"service_to_route_map\"] = {\n        **self._graph.graph[\"service_to_route_map\"],\n        **other._graph.graph[\"service_to_route_map\"],\n    }\n    self.minimal_transfer_times = dict_support.merge_complex_dictionaries(\n        other.minimal_transfer_times, self.minimal_transfer_times\n    )\n    # todo assuming separate schedules, with non conflicting ids, nodes and edges\n    _ = deepcopy(self._graph.graph)\n    self._graph.update(other._graph)\n    self._graph.graph = _\n\n    # merge change_log DataFrames\n    self._graph.graph[\"change_log\"] = self.change_log().merge_logs(other.change_log())\n\n    # merge vehicles\n    self.update_vehicles(other.vehicles, other.vehicle_types, overwrite=overwrite)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.add_route","title":"<code>add_route(service_id, route, force=False)</code>","text":"<p>Adds route to a service already in the Schedule.</p> PARAMETER DESCRIPTION <code>service_id</code> <p>service id in the Schedule to add the route to.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>route</code> <p>Route object to add.</p> <p> TYPE: <code>Route</code> </p> <code>force</code> <p>force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule. This will force the Service to be added, the stops data of currently in the Schedule will persist. If you want to change the data for stops use <code>apply_attributes_to_stops</code> or <code>apply_function_to_stops</code>. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def add_route(self, service_id: Union[str, int], route: Route, force: bool = False):\n    \"\"\"Adds route to a service already in the Schedule.\n\n    Args:\n        service_id (Union[str, int]): service id in the Schedule to add the route to.\n        route (Route): Route object to add.\n        force (bool, optional):\n            force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule.\n            This will force the Service to be added, the stops data of currently in the Schedule will persist.\n            If you want to change the data for stops use `apply_attributes_to_stops` or `apply_function_to_stops`.\n            Defaults to False.\n    \"\"\"\n    self.add_routes(routes_dict={service_id: [route]}, force=force)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.add_routes","title":"<code>add_routes(routes_dict, force=False)</code>","text":"<p>Adds routes to services already present in the Schedule.</p> PARAMETER DESCRIPTION <code>routes_dict</code> <p>dictionary specifying service IDs and list of routes (Route objects) to add to them.</p> <p> TYPE: <code>dict[str, list[Route]]</code> </p> <code>force</code> <p>force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule. This will force the Service to be added, the stops data of currently in the Schedule will persist. If you want to change the data for stops use <code>apply_attributes_to_stops</code> or <code>apply_function_to_stops</code>. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def add_routes(self, routes_dict: dict[str, list[Route]], force: bool = False):\n    \"\"\"Adds routes to services already present in the Schedule.\n\n    Args:\n        routes_dict (dict[str, list[Route]]): dictionary specifying service IDs and list of routes (Route objects) to add to them.\n        force (bool, optional):\n            force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule.\n            This will force the Service to be added, the stops data of currently in the Schedule will persist.\n            If you want to change the data for stops use `apply_attributes_to_stops` or `apply_function_to_stops`.\n            Defaults to False.\n    \"\"\"\n    missing_services = []\n    route_ids = []\n    for service_id, routes in routes_dict.items():\n        if not self.has_service(service_id):\n            missing_services.append(service_id)\n        else:\n            for route in routes:\n                if self.has_route(route.id):\n                    service = self[service_id]\n                    logging.warning(\n                        f\"Route with ID `{route.id}` for Service {service_id} within already exists \"\n                        \"in the Schedule. This Route will be reindexed to \"\n                        f\"`{service_id}_{len(service) + 1}`\"\n                    )\n                    route.reindex(f\"{service_id}_{len(service) + 1}\")\n                route_ids.append(route.id)\n    if missing_services:\n        raise ServiceIndexError(\n            f\"Services with IDs `{missing_services}` do not exist in the Schedule. \"\n            \"You must add Routes to an existing Service, or add a new Service\"\n        )\n\n    for service_id, routes in routes_dict.items():\n        for route in routes:\n            g = route.graph()\n            stops_without_data, stops_with_conflicting_data = self._compare_stops_data(g)\n            if stops_without_data:\n                logging.warning(f\"The following stops are missing data: {stops_without_data}\")\n            if stops_with_conflicting_data:\n                if force:\n                    logging.warning(\n                        f\"The following stops will inherit the data currently stored under those Stop IDs in \"\n                        f\"the Schedule: {stops_with_conflicting_data}.\"\n                    )\n                else:\n                    raise ConflictingStopData(\n                        \"The following stops would inherit data currently stored under those \"\n                        f\"Stop IDs in the Schedule: {stops_with_conflicting_data}. Use `force=True` \"\n                        \"to continue with this operation in this manner. If you want to change the \"\n                        \"data for stops use `apply_attributes_to_stops` or \"\n                        \"`apply_function_to_stops`.\"\n                    )\n            nx.set_edge_attributes(\n                g, {edge: {\"services\": {service_id}} for edge in set(g.edges())}\n            )\n            nx.set_node_attributes(\n                g, {node: {\"services\": {service_id}} for node in set(g.nodes())}\n            )\n            nodes = dict_support.merge_complex_dictionaries(\n                dict(g.nodes(data=True)), dict(self._graph.nodes(data=True))\n            )\n            edges = dict_support.combine_edge_data_lists(\n                list(g.edges(data=True)), list(self._graph.edges(data=True))\n            )\n            graph_routes = dict_support.merge_complex_dictionaries(\n                g.graph[\"routes\"], self._graph.graph[\"routes\"]\n            )\n            self._graph.graph[\"route_to_service_map\"][route.id] = service_id\n            self._graph.graph[\"service_to_route_map\"][service_id].append(route.id)\n\n            self._graph.add_nodes_from(nodes)\n            self._graph.add_edges_from(edges)\n            nx.set_node_attributes(self._graph, nodes)\n            self._graph.graph[\"routes\"] = graph_routes\n\n    route_data = [self._graph.graph[\"routes\"][rid] for rid in route_ids]\n    self._graph.graph[\"change_log\"] = self._graph.graph[\"change_log\"].add_bunch(\n        object_type=\"route\", id_bunch=route_ids, attributes_bunch=route_data\n    )\n    logging.info(\n        f\"Added Routes with IDs {route_ids}, to Services `{list(routes_dict.keys())}` within the \"\n        f\"Schedule\"\n    )\n    for service_id, routes in routes_dict.items():\n        for route in routes:\n            route._graph = self._graph\n    self.generate_vehicles(overwrite=False)\n    return routes_dict\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.add_service","title":"<code>add_service(service, force=False)</code>","text":"<p>Adds a service to Schedule.</p> PARAMETER DESCRIPTION <code>service</code> <p>genet.Service object, must have index unique w.r.t. Services already in the Schedule.</p> <p> TYPE: <code>Service</code> </p> <code>force</code> <p>force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule. This will force the Service to be added, the stops data of currently in the Schedule will persist. If you want to change the data for stops use <code>apply_attributes_to_stops</code> or <code>apply_function_to_stops</code>. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def add_service(self, service: Service, force: bool = False):\n    \"\"\"Adds a service to Schedule.\n\n    Args:\n        service (Service): genet.Service object, must have index unique w.r.t. Services already in the Schedule.\n        force (bool, optional):\n            force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule.\n            This will force the Service to be added, the stops data of currently in the Schedule will persist.\n            If you want to change the data for stops use `apply_attributes_to_stops` or `apply_function_to_stops`.\n            Defaults to False.\n    \"\"\"\n    self.add_services(services=[service], force=force)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.add_services","title":"<code>add_services(services, force=False)</code>","text":"<p>Adds multiple services to Schedule.</p> PARAMETER DESCRIPTION <code>services</code> <p>genet.Service objects, must have index unique w.r.t. Services already in the Schedule.</p> <p> TYPE: <code>list[Service]</code> </p> <code>force</code> <p>force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule. This will force the Service to be added, the stops data of currently in the Schedule will persist. If you want to change the data for stops use <code>apply_attributes_to_stops</code> or <code>apply_function_to_stops</code>. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Returns:     list[Service]: <code>service</code> with graph updates.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def add_services(self, services: list[Service], force: bool = False) -&gt; list[Service]:\n    \"\"\"Adds multiple services to Schedule.\n\n    Args:\n        services (list[Service]): genet.Service objects, must have index unique w.r.t. Services already in the Schedule.\n        force (bool, optional):\n            force the add, even if the stops in the Service have data conflicting with the stops of the same IDs that are already in the Schedule.\n            This will force the Service to be added, the stops data of currently in the Schedule will persist.\n            If you want to change the data for stops use `apply_attributes_to_stops` or `apply_function_to_stops`.\n            Defaults to False.\n    Returns:\n        list[Service]: `service` with graph updates.\n    \"\"\"\n    clashing_ids = []\n    for service in services:\n        if self.has_service(service.id):\n            clashing_ids.append(service.id)\n    if clashing_ids:\n        raise ServiceIndexError(\n            f\"Services with IDs {clashing_ids} already exist in the Schedule.\"\n        )\n    for service in services:\n        for route in service.routes():\n            if self.has_route(route.id):\n                logging.warning(\n                    f\"Route with ID `{route.id}` within this Service `{service.id}` already exists in the \"\n                    f\"Schedule. This Route will be reindexed to `{service.id}_{route.id}`\"\n                )\n                route.reindex(f\"{service.id}_{route.id}\")\n\n    for service in services:\n        g = service.graph()\n        stops_without_data, stops_with_conflicting_data = self._compare_stops_data(g)\n        if stops_without_data:\n            logging.warning(f\"The following stops are missing data: {stops_without_data}\")\n        if stops_with_conflicting_data:\n            if force:\n                logging.warning(\n                    f\"The following stops will inherit the data currently stored under those Stop IDs in \"\n                    f\"the Schedule: {stops_with_conflicting_data}.\"\n                )\n            else:\n                raise ConflictingStopData(\n                    \"The following stops would inherit data currently stored under those \"\n                    f\"Stop IDs in the Schedule: {stops_with_conflicting_data}. Use `force=True` \"\n                    \"to continue with this operation in this manner. If you want to change the \"\n                    \"data for stops use `apply_attributes_to_stops` or \"\n                    \"`apply_function_to_stops`.\"\n                )\n        nodes = dict_support.merge_complex_dictionaries(\n            dict(g.nodes(data=True)), dict(self._graph.nodes(data=True))\n        )\n        edges = dict_support.combine_edge_data_lists(\n            list(g.edges(data=True)), list(self._graph.edges(data=True))\n        )\n\n        route_ids_to_add = list(service.route_ids())\n        self._graph.add_nodes_from(nodes)\n        self._graph.add_edges_from(edges)\n        nx.set_node_attributes(self._graph, nodes)\n        for route_id in route_ids_to_add:\n            self._graph.graph[\"routes\"][route_id] = g.graph[\"routes\"][route_id]\n            self._graph.graph[\"route_to_service_map\"][route_id] = g.graph[\n                \"route_to_service_map\"\n            ][route_id]\n        self._graph.graph[\"services\"][service.id] = g.graph[\"services\"][service.id]\n        self._graph.graph[\"service_to_route_map\"][service.id] = g.graph[\"service_to_route_map\"][\n            service.id\n        ]\n\n    service_ids = [service.id for service in services]\n    service_data = [self._graph.graph[\"services\"][sid] for sid in service_ids]\n    route_ids = [list(service.route_ids()) for service in services]\n    self._graph.graph[\"change_log\"] = self._graph.graph[\"change_log\"].add_bunch(\n        object_type=\"service\", id_bunch=service_ids, attributes_bunch=service_data\n    )\n    logging.info(f\"Added Services with IDs `{service_ids}` and Routes: {route_ids}\")\n    for service in services:\n        service._graph = self._graph\n    self.generate_vehicles(overwrite=False)\n    return services\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.apply_attributes_to_routes","title":"<code>apply_attributes_to_routes(new_attributes)</code>","text":"<p>Adds, or changes if already present, the attributes in new_attributes.</p> <p>Doesn't replace the dictionary stored for the Routes presently, so no data is lost, unless it is being overwritten. Changing IDs this way with result in an error. Use Route's <code>reindex</code> method instead.</p> PARAMETER DESCRIPTION <code>new_attributes</code> <p>keys are Service IDs and values are dictionaries of data to add/replace if present.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def apply_attributes_to_routes(self, new_attributes: dict):\n    \"\"\"Adds, or changes if already present, the attributes in new_attributes.\n\n    Doesn't replace the dictionary stored for the Routes presently, so no data is lost, unless it is being overwritten.\n    Changing IDs this way with result in an error.\n    Use Route's `reindex` method instead.\n\n    Args:\n        new_attributes (dict): keys are Service IDs and values are dictionaries of data to add/replace if present.\n    \"\"\"\n    self._verify_no_id_change(new_attributes)\n    # check for stop changes\n    stop_changes = {\n        id\n        for id, change_dict in new_attributes.items()\n        if (\"ordered_stops\" in change_dict)\n        and (change_dict[\"ordered_stops\"] != self._graph.graph[\"routes\"][id][\"ordered_stops\"])\n    }\n    if stop_changes:\n        logging.warning(f\"Stop ID changes detected for Routes: {stop_changes}\")\n        nodes = {n for id in stop_changes for n in self.route_reference_nodes(id)}\n        edges = {e for id in stop_changes for e in self.route_reference_edges(id)}\n        self._remove_routes_from_nodes(nodes=nodes, route_ids=stop_changes)\n        self._remove_routes_from_edges(edges=edges, route_ids=stop_changes)\n        all_new_nodes = set()\n        all_new_edges = set()\n        for id in stop_changes:\n            new_nodes = set(new_attributes[id][\"ordered_stops\"])\n            all_new_nodes |= new_nodes\n            new_edges = {\n                (u, v)\n                for u, v in zip(\n                    new_attributes[id][\"ordered_stops\"][:-1],\n                    new_attributes[id][\"ordered_stops\"][1:],\n                )\n            }\n            all_new_edges |= new_edges\n            self._add_routes_to_nodes(nodes=new_nodes, route_ids={id})\n            self._add_routes_to_edges(edges=new_edges, route_ids={id})\n        self._generate_services_on_nodes(all_new_nodes | nodes)\n        self._generate_services_on_edges(all_new_edges | edges)\n\n    routes = list(new_attributes.keys())\n    old_attribs = [deepcopy(self._graph.graph[\"routes\"][route]) for route in routes]\n    new_attribs = [\n        dict_support.set_nested_value(self._graph.graph[\"routes\"][route], new_attributes[route])\n        for route in routes\n    ]\n\n    self._graph.graph[\"change_log\"] = self.change_log().modify_bunch(\n        \"route\", routes, old_attribs, routes, new_attribs\n    )\n\n    for route, new_route_attribs in zip(routes, new_attribs):\n        self._graph.graph[\"routes\"][route] = new_route_attribs\n    logging.info(f\"Changed Route attributes for {len(routes)} routes\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.apply_attributes_to_services","title":"<code>apply_attributes_to_services(new_attributes)</code>","text":"<p>Adds, or changes if already present, the attributes in new_attributes.</p> <p>Doesn't replace the dictionary stored for the Services presently, so no data is lost, unless it is being overwritten. Changing IDs this way with result in an error. Use Service's <code>reindex</code> method instead.</p> PARAMETER DESCRIPTION <code>new_attributes</code> <p>keys are Service IDs and values are dictionaries of data to add/replace if present.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def apply_attributes_to_services(self, new_attributes: dict):\n    \"\"\"Adds, or changes if already present, the attributes in new_attributes.\n\n    Doesn't replace the dictionary stored for the Services presently, so no data is lost, unless it is being overwritten.\n    Changing IDs this way with result in an error.\n    Use Service's `reindex` method instead.\n\n    Args:\n        new_attributes (dict): keys are Service IDs and values are dictionaries of data to add/replace if present.\n    \"\"\"\n    self._verify_no_id_change(new_attributes)\n    services = list(new_attributes.keys())\n    old_attribs = [deepcopy(self._graph.graph[\"services\"][service]) for service in services]\n    new_attribs = [\n        dict_support.set_nested_value(\n            self._graph.graph[\"services\"][service], new_attributes[service]\n        )\n        for service in services\n    ]\n\n    self._graph.graph[\"change_log\"] = self.change_log().modify_bunch(\n        \"service\", services, old_attribs, services, new_attribs\n    )\n\n    for service, new_service_attribs in zip(services, new_attribs):\n        self._graph.graph[\"services\"][service] = new_service_attribs\n    logging.info(f\"Changed Service attributes for {len(services)} services\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.apply_attributes_to_stops","title":"<code>apply_attributes_to_stops(new_attributes)</code>","text":"<p>Adds, or changes if already present, the attributes in new_attributes.</p> <p>Doesn't replace the dictionary stored for the Stops presently, so no data is lost, unless it is being overwritten. Changing IDs this way with result in an error. Use Stop's <code>reindex</code> method instead.</p> PARAMETER DESCRIPTION <code>new_attributes</code> <p>keys are Service IDs and values are dictionaries of data to add/replace if present.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def apply_attributes_to_stops(self, new_attributes: dict):\n    \"\"\"Adds, or changes if already present, the attributes in new_attributes.\n\n    Doesn't replace the dictionary stored for the Stops presently, so no data is lost, unless it is being overwritten.\n    Changing IDs this way with result in an error.\n    Use Stop's `reindex` method instead.\n\n    Args:\n        new_attributes (dict): keys are Service IDs and values are dictionaries of data to add/replace if present.\n    \"\"\"\n    self._verify_no_id_change(new_attributes)\n    stops = list(new_attributes.keys())\n    old_attribs = [deepcopy(self._graph.nodes[stop]) for stop in stops]\n    new_attribs = [\n        dict_support.set_nested_value(self._graph.nodes[stop], new_attributes[stop])\n        for stop in stops\n    ]\n\n    self._graph.graph[\"change_log\"] = self.change_log().modify_bunch(\n        \"stop\", stops, old_attribs, stops, new_attribs\n    )\n\n    nx.set_node_attributes(self._graph, dict(zip(stops, new_attribs)))\n    logging.info(f\"Changed Stop attributes for {len(stops)} stops\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.apply_function_to_routes","title":"<code>apply_function_to_routes(function, location)</code>","text":"<p>Applies a function or mapping to Routes within the Schedule.</p> <p>Fails silently, if the keys referred to by the function are not present, they will not be considered. The function will only be applied where it is possible.</p> PARAMETER DESCRIPTION <code>function</code> <p>Function of Service attributes dictionary returning a value that should be stored under <code>location</code> or a dictionary mapping. In the case of a dictionary all values stored under <code>location</code> will be mapped to new values given by the mapping, if they are present.</p> <p> TYPE: <code>Union[dict, Callable]</code> </p> <code>location</code> <p>where to save the results: string defining the key in the Service attributes dictionary</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def apply_function_to_routes(self, function: Union[dict, Callable], location: str):\n    \"\"\"Applies a function or mapping to Routes within the Schedule.\n\n    Fails silently, if the keys referred to by the function are not present, they will not be considered.\n    The function will only be applied where it is possible.\n\n    Args:\n        function (Union[dict, Callable]):\n            Function of Service attributes dictionary returning a value that should be stored under `location` or a dictionary mapping.\n            In the case of a dictionary all values stored under `location` will be mapped to new values given by the mapping, if they are present.\n\n        location (str): where to save the results: string defining the key in the Service attributes dictionary\n    \"\"\"\n    new_attributes = graph_operations.apply_to_attributes(\n        self._graph.graph[\"routes\"].items(), function, location\n    )\n    self.apply_attributes_to_routes(new_attributes)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.apply_function_to_services","title":"<code>apply_function_to_services(function, location)</code>","text":"<p>Applies a function or mapping to Services within the Schedule.</p> <p>Fails silently, if the keys referred to by the function are not present, they will not be considered. The function will only be applied where it is possible.</p> PARAMETER DESCRIPTION <code>function</code> <p>Function of Service attributes dictionary returning a value that should be stored under <code>location</code> or a dictionary mapping. In the case of a dictionary all values stored under <code>location</code> will be mapped to new values given by the mapping, if they are present.</p> <p> TYPE: <code>Callable</code> </p> <code>location</code> <p>where to save the results: string defining the key in the Service attributes dictionary</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def apply_function_to_services(self, function: Callable, location: str):\n    \"\"\"Applies a function or mapping to Services within the Schedule.\n\n    Fails silently, if the keys referred to by the function are not present, they will not be considered.\n    The function will only be applied where it is possible.\n\n    Args:\n        function (Callable):\n            Function of Service attributes dictionary returning a value that should be stored under `location` or a dictionary mapping.\n            In the case of a dictionary all values stored under `location` will be mapped to new values given by the mapping, if they are present.\n\n        location (str): where to save the results: string defining the key in the Service attributes dictionary\n    \"\"\"\n    new_attributes = graph_operations.apply_to_attributes(\n        self._graph.graph[\"services\"].items(), function, location\n    )\n    self.apply_attributes_to_services(new_attributes)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.apply_function_to_stops","title":"<code>apply_function_to_stops(function, location)</code>","text":"<p>Applies a function or mapping to Stops within the Schedule.</p> <p>Fails silently, if the keys referred to by the function are not present, they will not be considered. The function will only be applied where it is possible.</p> PARAMETER DESCRIPTION <code>function</code> <p>Function of Service attributes dictionary returning a value that should be stored under <code>location</code> or a dictionary mapping. In the case of a dictionary all values stored under <code>location</code> will be mapped to new values given by the mapping, if they are present.</p> <p> TYPE: <code>Union[dict, Callable]</code> </p> <code>location</code> <p>where to save the results: string defining the key in the Service attributes dictionary</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def apply_function_to_stops(self, function: Union[dict, Callable], location: str):\n    \"\"\"Applies a function or mapping to Stops within the Schedule.\n\n    Fails silently, if the keys referred to by the function are not present, they will not be considered.\n    The function will only be applied where it is possible.\n\n    Args:\n        function (Union[dict, Callable]):\n            Function of Service attributes dictionary returning a value that should be stored under `location` or a dictionary mapping.\n            In the case of a dictionary all values stored under `location` will be mapped to new values given by the mapping, if they are present.\n\n        location (str): where to save the results: string defining the key in the Service attributes dictionary\n    \"\"\"\n    new_attributes = graph_operations.apply_to_attributes(\n        self._graph.nodes(data=True), function, location\n    )\n    self.apply_attributes_to_stops(new_attributes)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.check_vehicle_uniqueness","title":"<code>check_vehicle_uniqueness()</code>","text":"<p>In MATSim, trips can share vehicles, but his may or may not be intended, e.g. it could result from a scenario change and be undesirable, leading to simulation not working correctly. This method checks if a vehicle ID is being used by two or more different trips, and then returns a dictionary of vehicle IDs together with trips for which they are being used. It also logs a warning which says whether any vehicles are being used for multiple trips.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def check_vehicle_uniqueness(self):\n    \"\"\"\n    In MATSim, trips can share vehicles, but his may or may not be intended, e.g. it could result from a\n    scenario change and be undesirable, leading to simulation not working correctly.\n    This method checks if a vehicle ID is being used by two or more different trips, and then returns\n    a dictionary of vehicle IDs together with trips for which they are being used.\n    It also logs a warning which says whether any vehicles are being used for multiple trips.\n    \"\"\"\n    trips_df = self.trips_to_dataframe()\n    trips_df = trips_df[[\"trip_id\", \"vehicle_id\"]]\n\n    trips_dict = trips_df.set_index(\"trip_id\")[\"vehicle_id\"].to_dict()\n\n    # finding duplicate values from dictionary by flipping keys and values\n    flipped = {}\n    not_unique_list = []\n\n    for trip_id, vehicle_id in trips_dict.items():\n        if vehicle_id not in flipped:\n            flipped[vehicle_id] = [trip_id]\n        else:\n            not_unique_list.append(vehicle_id)\n            flipped[vehicle_id].append(trip_id)\n\n    duplicates_dict = {}\n    for vehicle_id in not_unique_list:\n        trip_ids = flipped[vehicle_id]\n        duplicates_dict[vehicle_id] = []\n        for id in trip_ids:\n            duplicates_dict[vehicle_id].append(id)\n\n    if len(duplicates_dict) == 0:\n        logging.info(\"No vehicles being used for multiple trips have been found.\")\n    else:\n        logging.warning(\n            \"Vehicles being used for multiple trips: {}\".format(list(duplicates_dict.keys()))\n        )\n\n    return duplicates_dict\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.extract_route_ids_on_attributes","title":"<code>extract_route_ids_on_attributes(conditions, how=any, mixed_dtypes=True)</code>","text":"<p>Extracts IDs of Routes stored in the Schedule based on values of their attributes.</p> <p>Fails silently, assumes not all Routes have those attributes.</p> <p>In the case were the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered in case of iterable value, if not empty, it is deemed successful by default. To disable this behaviour set mixed_dtypes to False.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: list of ids in the schedule satisfying conditions.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def extract_route_ids_on_attributes(\n    self, conditions: Union[list, dict], how: Callable = any, mixed_dtypes: bool = True\n) -&gt; list[str]:\n    \"\"\"Extracts IDs of Routes stored in the Schedule based on values of their attributes.\n\n    Fails silently, assumes not all Routes have those attributes.\n\n    In the case were the attributes stored are a list or set,\n    like in the case of a simplified network (there will be a mix of objects that are sets and not),\n    an intersection of values satisfying condition(s) is considered in case of iterable value,\n    if not empty, it is deemed successful by default.\n    To disable this behaviour set mixed_dtypes to False.\n\n    Args:\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n\n    Returns:\n        list[str]: list of ids in the schedule satisfying conditions.\n    \"\"\"\n    return graph_operations.extract_on_attributes(\n        self._graph.graph[\"routes\"].items(),\n        conditions=conditions,\n        how=how,\n        mixed_dtypes=mixed_dtypes,\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.extract_service_ids_on_attributes","title":"<code>extract_service_ids_on_attributes(conditions, how=any, mixed_dtypes=True)</code>","text":"<p>Extracts IDs of Services stored in the Schedule based on values of their attributes.</p> <p>Fails silently, assumes not all Services have those attributes.</p> <p>In the case were the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered in case of iterable value, if not empty, it is deemed successful by default. To disable this behaviour set mixed_dtypes to False.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: list of ids in the schedule satisfying conditions.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def extract_service_ids_on_attributes(\n    self, conditions: Union[list, dict], how: Callable = any, mixed_dtypes: bool = True\n) -&gt; list[str]:\n    \"\"\"Extracts IDs of Services stored in the Schedule based on values of their attributes.\n\n    Fails silently, assumes not all Services have those attributes.\n\n    In the case were the attributes stored are a list or set,\n    like in the case of a simplified network (there will be a mix of objects that are sets and not),\n    an intersection of values satisfying condition(s) is considered in case of iterable value,\n    if not empty, it is deemed successful by default.\n    To disable this behaviour set mixed_dtypes to False.\n\n    Args:\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n\n    Returns:\n        list[str]: list of ids in the schedule satisfying conditions.\n\n    \"\"\"\n    return graph_operations.extract_on_attributes(\n        self._graph.graph[\"services\"].items(),\n        conditions=conditions,\n        how=how,\n        mixed_dtypes=mixed_dtypes,\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.extract_stop_ids_on_attributes","title":"<code>extract_stop_ids_on_attributes(conditions, how=any, mixed_dtypes=True)</code>","text":"<p>Extracts IDs of Stops stored in the Schedule based on values of their attributes.</p> <p>Fails silently, assumes not all Routes have those attributes.</p> <p>In the case were the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered in case of iterable value, if not empty, it is deemed successful by default. To disable this behaviour set mixed_dtypes to False.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: list of ids in the schedule satisfying conditions.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def extract_stop_ids_on_attributes(\n    self, conditions: Union[list, dict], how: Callable = any, mixed_dtypes: bool = True\n) -&gt; list[str]:\n    \"\"\"Extracts IDs of Stops stored in the Schedule based on values of their attributes.\n\n    Fails silently, assumes not all Routes have those attributes.\n\n    In the case were the attributes stored are a list or set,\n    like in the case of a simplified network (there will be a mix of objects that are sets and not),\n    an intersection of values satisfying condition(s) is considered in case of iterable value,\n    if not empty, it is deemed successful by default.\n    To disable this behaviour set mixed_dtypes to False.\n\n    Args:\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n\n    Returns:\n        list[str]: list of ids in the schedule satisfying conditions.\n    \"\"\"\n    return graph_operations.extract_on_attributes(\n        self._graph.nodes(data=True), conditions=conditions, how=how, mixed_dtypes=mixed_dtypes\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.find_epsg","title":"<code>find_epsg()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def find_epsg(self):\n    return self.init_epsg\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.fix_infinite_speeds","title":"<code>fix_infinite_speeds()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def fix_infinite_speeds(self):\n    df_speeds = self.speed_geodataframe()\n    df_speeds_inf = df_speeds[(df_speeds[\"speed\"] == math.inf)]\n    if not df_speeds_inf.empty:\n        affected_routes = set(df_speeds_inf[\"route_id\"])\n        logging.info(\n            f\"Found {len(affected_routes)} routes with infinite speeds. \"\n            f\"{len(set(df_speeds_inf['service_id']))} out of {len(set(df_speeds['service_id']))} \"\n            \"services are affected. \"\n            \"These will now be dropped as though they are duplicates of other trips, \"\n            \"thus resulting in zero headway between them\"\n        )\n        new_route_attributes_dict = {}\n        for route_id in affected_routes:\n            df_route_speeds = df_speeds[df_speeds[\"route_id\"] == route_id]\n            df_route_speeds[\"length\"] = [1.3 * x.length for x in df_route_speeds[\"geometry\"]]\n\n            old_arrival_offsets = self.route(route_id).__dict__[\"arrival_offsets\"]\n            old_departure_offsets = self.route(route_id).__dict__[\"departure_offsets\"]\n            updated_arrival_offsets = [\"00:00:00\"]\n            updated_departure_offsets = [\"00:00:00\"]\n\n            avg_speed = df_route_speeds[df_route_speeds[\"speed\"] != math.inf][\"speed\"].mean()\n            distances = df_route_speeds[\"length\"].to_list()\n\n            for i in range(1, len(old_arrival_offsets)):\n                # if the offset is the same as previous (i.e. GTFS error),\n                # OR if the previous offset got infilled with a value bigger than the current offset\n                if datetime.strptime(\n                    updated_departure_offsets[i - 1], \"%H:%M:%S\"\n                ) &gt;= datetime.strptime(old_arrival_offsets[i], \"%H:%M:%S\"):\n                    time = round(distances[i - 1] / avg_speed, 0)\n                    previous_offset = datetime.strptime(\n                        updated_departure_offsets[i - 1], \"%H:%M:%S\"\n                    )\n                    current_offset = previous_offset + timedelta(seconds=time)\n                    str_current_offset = datetime.strftime(current_offset, \"%H:%M:%S\")\n                    updated_arrival_offsets.append(str_current_offset)\n                    updated_departure_offsets.append(str_current_offset)\n                else:\n                    updated_arrival_offsets.append(old_arrival_offsets[i])\n                    updated_departure_offsets.append(old_departure_offsets[i])\n            new_route_attributes_dict[route_id] = {\n                \"arrival_offsets\": updated_arrival_offsets,\n                \"departure_offsets\": updated_departure_offsets,\n            }\n        self.apply_attributes_to_routes(new_attributes=new_route_attributes_dict)\n    else:\n        logging.info(\"No routes with infinite speeds were found. Nothing to do.\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.fix_trips_with_zero_headways","title":"<code>fix_trips_with_zero_headways()</code>","text":"<p>Deletes trips that have zero headways and thus deemed duplicates</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def fix_trips_with_zero_headways(self):\n    \"\"\"\n    Deletes trips that have zero headways and thus deemed duplicates\n    \"\"\"\n    trip_headways_df = self.trips_headways()\n    zero_headways = trip_headways_df[(trip_headways_df[\"headway_mins\"] == 0)]\n\n    if not zero_headways.empty:\n        logging.info(\n            f\"Found {len(zero_headways)} trips with zero headways. \"\n            f\"{len(set(zero_headways['route_id']))} out of {len(set(trip_headways_df['route_id']))} \"\n            f\"routes and {len(set(zero_headways['service_id']))} out of \"\n            f\"{len(set(trip_headways_df['service_id']))} services are affected. \"\n            \"These will now be dropped as though they are duplicates of other trips, \"\n            \"thus resulting in zero headway between them\"\n        )\n        new_trips = trip_headways_df[trip_headways_df[\"headway_mins\"] != 0].drop(\n            [\"headway_mins\", \"headway\"], axis=1\n        )\n        new_trips_for_affected_routes = new_trips.loc[\n            new_trips[\"route_id\"].isin(set(zero_headways[\"route_id\"])), :\n        ]\n        self.set_trips_dataframe(new_trips_for_affected_routes.copy())\n        self.generate_vehicles(overwrite=True)\n        # check\n        _trip_headways_df = self.trips_headways()\n        _zero_headways = _trip_headways_df[(_trip_headways_df[\"headway_mins\"] == 0)]\n        logging.info(\n            f\"Checks after alterations result in {len(_zero_headways)} trips with zero headway\"\n        )\n    else:\n        logging.info(\"No trips with zero headway found. Nothing to do.\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.generate_standard_outputs","title":"<code>generate_standard_outputs(output_dir, gtfs_day='19700101', filetype='parquet')</code>","text":"<p>Generates geojsons that can be used for generating standard kepler visualisations.</p> <p>These can also be used for validating network for example inspecting link capacity, freespeed, number of lanes, the shape of modal subgraphs.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>path to folder where to save resulting geojsons.</p> <p> TYPE: <code>str</code> </p> <code>gtfs_day</code> <p>Day in format YYYYMMDD for the network's schedule for consistency in visualisations, Defaults to \"19700101\" (1970-01-01).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> <code>filetype</code> <p>The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported. Defaults to parquet format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parquet'</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def generate_standard_outputs(self, output_dir, gtfs_day=\"19700101\", filetype: str = \"parquet\"):\n    \"\"\"Generates geojsons that can be used for generating standard kepler visualisations.\n\n    These can also be used for validating network for example inspecting link capacity, freespeed, number of lanes, the shape of modal subgraphs.\n\n    Args:\n        output_dir (str): path to folder where to save resulting geojsons.\n        gtfs_day (str, optional):\n            Day in format YYYYMMDD for the network's schedule for consistency in visualisations,\n            Defaults to \"19700101\" (1970-01-01).\n        filetype (str, optional):\n            The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported.\n            Defaults to parquet format.\n    \"\"\"\n    spatial_output.generate_standard_outputs_for_schedule(\n        self, output_dir=output_dir, gtfs_day=gtfs_day, filetype=filetype\n    )\n    logging.info(\"Finished generating standard outputs. Zipping folder.\")\n    persistence.zip_folder(output_dir)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.generate_trips_dataframe_from_headway","title":"<code>generate_trips_dataframe_from_headway(route_id, headway_spec)</code>","text":"<p>Generates new trips and vehicles for the specified route.</p> <p>Inherits one of the existing vehicle types. If the vehicle types vary for a route, you will need to generate your own trips dataframe and add those vehicles yourself.</p> <p>All newly generated trips get unique vehicles with this method.</p> PARAMETER DESCRIPTION <code>route_id</code> <p>existing route</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>headway_spec</code> <p>dictionary with tuple keys: (from time, to time) and headway values in minutes: <code>{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}</code>.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Trips.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def generate_trips_dataframe_from_headway(\n    self, route_id: Union[str, int], headway_spec: dict\n) -&gt; pd.DataFrame:\n    \"\"\"Generates new trips and vehicles for the specified route.\n\n    Inherits one of the existing vehicle types.\n    If the vehicle types vary for a route, you will need to generate your own trips dataframe and add those vehicles yourself.\n\n    All newly generated trips get unique vehicles with this method.\n\n    Args:\n        route_id (Union[str, int]): existing route\n        headway_spec (dict):\n            dictionary with tuple keys: (from time, to time) and headway values in minutes:\n            `{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}`.\n\n    Returns:\n        pd.DataFrame: Trips.\n    \"\"\"\n    veh_type = self.vehicles[self.route(route_id).trips[\"vehicle_id\"][0]]\n    new_trip_departures = list(generate_trip_departures_from_headway(headway_spec))\n    new_trip_departures.sort()\n\n    new_trips = pd.DataFrame(\n        {\n            \"trip_id\": [f'{route_id}_{t.strftime(\"%H:%M:%S\")}' for t in new_trip_departures],\n            \"trip_departure_time\": new_trip_departures,\n            \"vehicle_id\": [\n                f'veh_{veh_type[\"type\"]}_{route_id}_{t.strftime(\"%H:%M:%S\")}'\n                for t in new_trip_departures\n            ],\n        }\n    )\n    new_trips[\"route_id\"] = route_id\n    new_trips[\"service_id\"] = self._graph.graph[\"route_to_service_map\"][route_id]\n    return new_trips\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.generate_trips_from_headway","title":"<code>generate_trips_from_headway(route_id, headway_spec)</code>","text":"<p>Generates new trips and vehicles for the specified route.</p> <p>Inherits one of the existing vehicle type. If the vehicle types vary for a route, you will need to generate your own trips dataframe and add those vehicles yourself.</p> <p>All newly generated trips get unique vehicles with this method.</p> PARAMETER DESCRIPTION <code>route_id</code> <p>existing route</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>headway_spec</code> <p>dictionary with tuple keys: (from time, to time) and headway values in minutes: <code>{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}</code>.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def generate_trips_from_headway(self, route_id: Union[str, int], headway_spec: dict):\n    \"\"\"Generates new trips and vehicles for the specified route.\n\n    Inherits one of the existing vehicle type.\n    If the vehicle types vary for a route, you will need to generate your own trips dataframe and add those vehicles yourself.\n\n    All newly generated trips get unique vehicles with this method.\n\n    Args:\n        route_id (Union[str, int]): existing route\n        headway_spec (dict):\n            dictionary with tuple keys: (from time, to time) and headway values in minutes:\n            `{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}`.\n    \"\"\"\n    veh_type = self.vehicles[self.route(route_id).trips[\"vehicle_id\"][0]]\n    old_vehicles = set(self.route(route_id).trips[\"vehicle_id\"])\n    new_trips = self.generate_trips_dataframe_from_headway(route_id, headway_spec)\n    self.set_trips_dataframe(new_trips)\n    self.vehicles = {\n        **{veh_id: veh_type for veh_id in new_trips[\"vehicle_id\"]},\n        **self.vehicles,\n    }\n    list(map(self.vehicles.pop, old_vehicles - set(new_trips[\"vehicle_id\"])))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.generate_validation_report","title":"<code>generate_validation_report()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def generate_validation_report(self):\n    return schedule_validation.generate_validation_report(schedule=self)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.generate_vehicles","title":"<code>generate_vehicles(overwrite=False)</code>","text":"<p>Generate vehicles for the Schedule.</p> <p>Returns dictionary of vehicle IDs from Route objects, mapping them to vehicle types in vehicle_types. Looks like this: <code>{veh_id : {'type': 'bus'}}</code>. Generates itself from the vehicles IDs which exist in Routes, maps to the mode of the Route.</p> PARAMETER DESCRIPTION <code>overwrite</code> <p>If False, does not overwrite the types of vehicles currently in the schedule. If True, generates completely new vehicle types for all vehicles in the schedule based on Route modes. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>InconsistentVehicleModeError</code> <p>There should be no modal inconsistencies between vehicles and schedules.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def generate_vehicles(self, overwrite: bool = False):\n    \"\"\"Generate vehicles for the Schedule.\n\n    Returns dictionary of vehicle IDs from Route objects, mapping them to vehicle types in vehicle_types.\n    Looks like this: `{veh_id : {'type': 'bus'}}`.\n    Generates itself from the vehicles IDs which exist in Routes, maps to the mode of the Route.\n\n    Args:\n        overwrite (bool, optional):\n            If False, does not overwrite the types of vehicles currently in the schedule.\n            If True, generates completely new vehicle types for all vehicles in the schedule based on Route modes.\n            Defaults to False.\n\n    Raises:\n        InconsistentVehicleModeError: There should be no modal inconsistencies between vehicles and schedules.\n    \"\"\"\n    if self:\n        # generate vehicles using Services and Routes upon init\n        df = self.trips_to_dataframe()[[\"route_id\", \"vehicle_id\"]]\n        df[\"type\"] = df.apply(\n            lambda x: self._graph.graph[\"routes\"][x[\"route_id\"]][\"mode\"], axis=1\n        )\n        df = df.drop(columns=\"route_id\")\n        # check mode consistency\n        vehicles_to_modes = df.groupby(\"vehicle_id\").apply(lambda x: list(x[\"type\"].unique()))\n        if (vehicles_to_modes.str.len() &gt; 1).any():\n            # there are vehicles which are shared across routes with different modes\n            raise InconsistentVehicleModeError(\n                \"Modal inconsistencies found while generating vehicles for Schedule.\"\n                \" Vehicles and modes in question: \"\n                f\"{vehicles_to_modes[(vehicles_to_modes.str.len() &gt; 1)].to_dict()}\"\n            )\n        df = df.set_index(\"vehicle_id\")\n        if overwrite:\n            self.vehicles = df.T.to_dict()\n            self.validate_vehicle_definitions()\n        else:\n            self.vehicles = {**df.T.to_dict(), **self.vehicles}\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.get_missing_vehicle_information","title":"<code>get_missing_vehicle_information()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def get_missing_vehicle_information(self):\n    df_vehicles = graph_operations.build_attribute_dataframe(\n        iterator=self.vehicles.items(), keys=[\"type\"]\n    )\n    missing_vehicle_types = set(df_vehicles[\"type\"]) - set(self.vehicle_types.keys())\n    vehicles_affected = df_vehicles[df_vehicles[\"type\"].isin(missing_vehicle_types)].T.to_dict()\n\n    missing = {}\n    missing[\"missing_vehicle_types\"] = missing_vehicle_types\n    missing[\"vehicles_affected\"] = vehicles_affected\n\n    return missing\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.graph","title":"<code>graph()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def graph(self):\n    return self._graph\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_infinite_speeds","title":"<code>has_infinite_speeds()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_infinite_speeds(self):\n    pt_speeds = self.speed_geodataframe()\n    pt_speeds_inf = pt_speeds[(pt_speeds[\"speed\"] == math.inf)]\n    return not bool(pt_speeds_inf.empty)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_intermodal_access_egress_connections","title":"<code>has_intermodal_access_egress_connections()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_intermodal_access_egress_connections(self):\n    return bool(self.intermodal_access_egress_attribute_keys())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_route","title":"<code>has_route(route_id)</code>","text":"<p>Returns True if a route with ID <code>route_id</code> exists in the Schedule, False otherwise</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_route(self, route_id):\n    \"\"\"\n    Returns True if a route with ID `route_id` exists in the Schedule, False otherwise\n    \"\"\"\n    return route_id in self._graph.graph[\"routes\"].keys()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_self_loops","title":"<code>has_self_loops()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_self_loops(self):\n    return list(nx.nodes_with_selfloops(self.graph()))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_service","title":"<code>has_service(service_id)</code>","text":"<p>Returns True if a service with ID <code>service_id</code> exists in the Schedule, False otherwise</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_service(self, service_id):\n    \"\"\"\n    Returns True if a service with ID `service_id` exists in the Schedule, False otherwise\n    \"\"\"\n    return service_id in self.service_ids()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_stop","title":"<code>has_stop(stop_id)</code>","text":"<p>Returns True if a stop with ID <code>stop_id</code> exists in the Schedule, False otherwise</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_stop(self, stop_id):\n    \"\"\"\n    Returns True if a stop with ID `stop_id` exists in the Schedule, False otherwise\n    \"\"\"\n    return self._graph.has_node(stop_id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_trips_with_zero_headways","title":"<code>has_trips_with_zero_headways()</code>","text":"<p>Deletes trips that have zero headways and thus deemed duplicates.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if any trips have zero headway.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_trips_with_zero_headways(self) -&gt; bool:\n    \"\"\"Deletes trips that have zero headways and thus deemed duplicates.\n\n    Returns:\n        bool: True if any trips have zero headway.\n    \"\"\"\n    trip_headways_df = self.trips_headways()\n    zero_headways = trip_headways_df[(trip_headways_df[\"headway_mins\"] == 0)]\n    return not bool(zero_headways.empty)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.has_valid_services","title":"<code>has_valid_services()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_valid_services(self):\n    return all(self.validity_of_services())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.info","title":"<code>info()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def info(self):\n    return (\n        \"Schedule:\\nNumber of services: {}\\nNumber of routes: {}\\nNumber of stops: {}\".format(\n            self.__len__(), self.number_of_routes(), len(self.reference_nodes())\n        )\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.intermodal_access_egress_attribute_keys","title":"<code>intermodal_access_egress_attribute_keys()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def intermodal_access_egress_attribute_keys(self):\n    return [\n        node.name\n        for node in graph_operations.get_attribute_schema(\n            self._graph.nodes(data=True), data=False\n        ).leaves\n        if \"accessLinkId\" in node.name\n    ]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.intermodal_access_egress_connections","title":"<code>intermodal_access_egress_connections()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def intermodal_access_egress_connections(self):\n    attribute_keys = self.intermodal_access_egress_attribute_keys()\n    df = self.stop_attribute_data(keys=[{\"attributes\": key} for key in attribute_keys])\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.invalid_services","title":"<code>invalid_services()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def invalid_services(self):\n    return [service for service in self.services() if not service.is_valid_service()]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.is_separable_from","title":"<code>is_separable_from(other)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_separable_from(self, other):\n    unique_service_ids = set(other.service_ids()) &amp; set(self.service_ids()) == set()\n    unique_route_ids = set(other.route_ids()) &amp; set(self.route_ids()) == set()\n    unique_nodes = other.reference_nodes() &amp; self.reference_nodes() == set()\n    unique_edges = other.reference_edges() &amp; self.reference_edges() == set()\n    return unique_service_ids and unique_route_ids and unique_nodes and unique_edges\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.is_strongly_connected","title":"<code>is_strongly_connected()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_strongly_connected(self):\n    if nx.number_strongly_connected_components(self.graph()) == 1:\n        return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.is_valid_schedule","title":"<code>is_valid_schedule(return_reason=False)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_valid_schedule(self, return_reason=False):\n    invalid_stages = []\n    valid = True\n\n    if not self.has_valid_services():\n        valid = False\n        invalid_stages.append(\"not_has_valid_services\")\n\n    if return_reason:\n        return valid, invalid_stages\n    return valid\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.mode_graph_map","title":"<code>mode_graph_map()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def mode_graph_map(self):\n    mode_map = {}\n    mode_to_routes_map = self.mode_to_routes_map()\n    for mode, route_ids in mode_to_routes_map.items():\n        mode_map[mode] = set(\n            graph_operations.extract_on_attributes(\n                iterator=[((u, v), data) for u, v, data in self._graph.edges(data=True)],\n                conditions={\"routes\": route_ids},\n            )\n        )\n    return mode_map\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.mode_to_routes_map","title":"<code>mode_to_routes_map()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def mode_to_routes_map(self):\n    df = self.route_attribute_data(keys=[\"mode\"], index_name=\"route_id\").reset_index()\n    return df.groupby(\"mode\")[\"route_id\"].apply(list).to_dict()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.modes","title":"<code>modes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def modes(self):\n    return set(self.route_attribute_data(keys=\"mode\")[\"mode\"].unique())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.number_of_routes","title":"<code>number_of_routes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def number_of_routes(self):\n    return len(self._graph.graph[\"routes\"])\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.overlapping_vehicle_ids","title":"<code>overlapping_vehicle_ids(vehicles)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def overlapping_vehicle_ids(self, vehicles: dict) -&gt; set:\n    return set(self.vehicles.keys()) &amp; set(vehicles.keys())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.overlapping_vehicle_types","title":"<code>overlapping_vehicle_types(vehicle_types)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def overlapping_vehicle_types(self, vehicle_types: dict) -&gt; set:\n    return set(self.vehicle_types.keys()) &amp; set(vehicle_types.keys())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.plot","title":"<code>plot(output_dir='', data=False)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def plot(self, output_dir: str = \"\", data: Union[bool, set] = False) -&gt; KeplerGl:\n    return self.kepler_map(output_dir, \"schedule_map\", data=data)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.print","title":"<code>print()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def print(self):\n    print(self.info())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.reference_edges","title":"<code>reference_edges()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reference_edges(self):\n    return set(self._graph.edges())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.reference_nodes","title":"<code>reference_nodes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reference_nodes(self):\n    return set(self._graph.nodes())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.reindex","title":"<code>reindex(new_id)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reindex(self, new_id):\n    if isinstance(self, Schedule):\n        raise NotImplementedError(\"Schedule is not currently an indexed object\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_route","title":"<code>remove_route(route_id)</code>","text":"<p>Removes Route under index <code>route_id</code>.</p> PARAMETER DESCRIPTION <code>route_id</code> <p>route ID to remove</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_route(self, route_id: str):\n    \"\"\"Removes Route under index `route_id`.\n\n    Args:\n        route_id (str): route ID to remove\n\n    \"\"\"\n    self.remove_routes(route_ids=[route_id])\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_routes","title":"<code>remove_routes(route_ids)</code>","text":"<p>Removes Route under index <code>route_id</code>.</p> PARAMETER DESCRIPTION <code>route_ids</code> <p>route IDs to remove.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_routes(self, route_ids: list[str]):\n    \"\"\"Removes Route under index `route_id`.\n\n    Args:\n        route_ids (list[str]): route IDs to remove.\n    \"\"\"\n    route_ids = persistence.listify(route_ids)\n    missing_ids = []\n    for route_id in route_ids:\n        if not self.has_route(route_id):\n            missing_ids.append(route_id)\n    if missing_ids:\n        raise RouteIndexError(\n            f\"Routes with IDs {missing_ids} do not exist in the Schedule. \"\n            \"Cannot remove Routes that aren't present.\"\n        )\n\n    route_data = []\n    service_ids = set()\n    route_ref_nodes = set()\n    route_ref_edges = set()\n    for route_id in route_ids:\n        route_data.append(self._graph.graph[\"routes\"][route_id])\n        service_id = self._graph.graph[\"route_to_service_map\"][route_id]\n        service_ids.add(service_id)\n        route_ref_nodes |= self.route_reference_nodes(route_id)\n        route_ref_edges |= self.route_reference_edges(route_id)\n\n    self._remove_routes_from_nodes(nodes=route_ref_nodes, route_ids=set(route_ids))\n    self._remove_routes_from_edges(edges=route_ref_edges, route_ids=set(route_ids))\n\n    service_ref_nodes = set()\n    service_ref_edges = set()\n    for service_id in service_ids:\n        for node in route_ref_nodes:\n            if not (\n                self._graph.nodes[node][\"routes\"]\n                &amp; set(self._graph.graph[\"service_to_route_map\"][service_id])\n            ):\n                service_ref_nodes.add(node)\n        for u, v in route_ref_edges:\n            if not (\n                self._graph[u][v][\"routes\"]\n                &amp; set(self._graph.graph[\"service_to_route_map\"][service_id])\n            ):\n                service_ref_edges.add((u, v))\n    self._remove_services_from_nodes(nodes=service_ref_nodes, service_ids=service_ids)\n    self._remove_services_from_edges(edges=service_ref_edges, service_ids=service_ids)\n\n    for route_id in route_ids:\n        service_id = self._graph.graph[\"route_to_service_map\"][route_id]\n        self._graph.graph[\"service_to_route_map\"][service_id].remove(route_id)\n        del self._graph.graph[\"route_to_service_map\"][route_id]\n        del self._graph.graph[\"routes\"][route_id]\n        if not self._graph.graph[\"service_to_route_map\"][service_id]:\n            logging.warning(\n                f\"Removal of Routes led to a whole service {service_id} being removed\"\n            )\n            del self._graph.graph[\"service_to_route_map\"][service_id]\n            del self._graph.graph[\"services\"][service_id]\n\n    self._graph.graph[\"change_log\"] = self._graph.graph[\"change_log\"].remove_bunch(\n        object_type=\"route\", id_bunch=route_ids, attributes_bunch=route_data\n    )\n\n    # update vehicles\n    old_vehicles = deepcopy(self.vehicles)\n    self.vehicles = {}\n    self.generate_vehicles()\n    self.vehicles = {\n        **self.vehicles,\n        **{k: v for k, v in old_vehicles.items() if k in self.vehicles},\n    }\n    logging.info(f\"Removed Routes with IDs {route_ids}, to Services `{service_id}`.\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_service","title":"<code>remove_service(service_id)</code>","text":"<p>Removes Service under given index <code>service_id</code>.</p> PARAMETER DESCRIPTION <code>service_id</code> <p>Service ID to remove.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_service(self, service_id: str):\n    \"\"\"Removes Service under given index `service_id`.\n\n    Args:\n        service_id (str): Service ID to remove.\n    \"\"\"\n    self.remove_services(service_ids=[service_id])\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_services","title":"<code>remove_services(service_ids)</code>","text":"<p>Removes Services with given indices.</p> PARAMETER DESCRIPTION <code>service_ids</code> <p>List of service IDs to remove.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_services(self, service_ids: list[str]):\n    \"\"\"Removes Services with given indices.\n\n    Args:\n        service_ids (list[str]): List of service IDs to remove.\n    \"\"\"\n    service_ids = persistence.listify(service_ids)\n    missing_ids = []\n    for service_id in service_ids:\n        if not self.has_service(service_id):\n            missing_ids.append(service_id)\n    if missing_ids:\n        raise ServiceIndexError(\n            f\"Services with IDs {missing_ids} do not exist in the Schedule. \"\n            \"Cannot remove Services that aren't present.\"\n        )\n    service_data = []\n    route_ids = set()\n    ref_nodes = set()\n    ref_edges = set()\n    for service_id in service_ids:\n        service_data.append(self._graph.graph[\"services\"][service_id])\n        route_ids |= set(self._graph.graph[\"service_to_route_map\"][service_id])\n        ref_nodes |= self.service_reference_nodes(service_id)\n        ref_edges |= self.service_reference_edges(service_id)\n\n    self._remove_routes_from_nodes(nodes=ref_nodes, route_ids=route_ids)\n    self._remove_services_from_nodes(nodes=ref_nodes, service_ids=set(service_ids))\n    self._remove_routes_from_edges(edges=ref_edges, route_ids=route_ids)\n    self._remove_services_from_edges(edges=ref_edges, service_ids=set(service_ids))\n\n    for service_id in service_ids:\n        del self._graph.graph[\"services\"][service_id]\n        del self._graph.graph[\"service_to_route_map\"][service_id]\n    for r_id in route_ids:\n        del self._graph.graph[\"route_to_service_map\"][r_id]\n        del self._graph.graph[\"routes\"][r_id]\n\n    self._graph.graph[\"change_log\"] = self._graph.graph[\"change_log\"].remove_bunch(\n        object_type=\"service\", id_bunch=service_ids, attributes_bunch=service_data\n    )\n\n    # update vehicles\n    old_vehicles = deepcopy(self.vehicles)\n    self.vehicles = {}\n    self.generate_vehicles()\n    self.vehicles = {\n        **self.vehicles,\n        **{k: v for k, v in old_vehicles.items() if k in self.vehicles},\n    }\n    logging.info(f\"Removed Services with IDs `{service_id}`, and Routes: {route_ids}\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_stop","title":"<code>remove_stop(stop_id)</code>","text":"<p>Removes Stop under index <code>stop_id</code>.</p> PARAMETER DESCRIPTION <code>stop_id</code> <p>Stop ID to remove.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_stop(self, stop_id: str):\n    \"\"\"Removes Stop under index `stop_id`.\n\n    Args:\n        stop_id (str): Stop ID to remove.\n    \"\"\"\n    self.remove_stops([stop_id])\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_stops","title":"<code>remove_stops(stop_ids)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_stops(self, stop_ids: Union[list, set]):\n    stop_ids = persistence.listify(set(stop_ids))\n    for stop_id in stop_ids:\n        if not self.has_stop(stop_id):\n            stop_ids.pop(stop_id)\n            raise StopIndexError(\n                f\"Stop with ID `{stop_id}` does not exist in the Schedule. \"\n                \"Cannot remove a Stop that isn't present.\"\n            )\n\n    stop_data = [data for _id, data in self._graph.nodes(data=True) if _id in stop_ids]\n    routes_affected = set().union(*[data.pop(\"routes\") for data in stop_data])\n    services_affected = set().union(*[data.pop(\"services\") for data in stop_data])\n    self._graph.remove_nodes_from(stop_ids)\n    self.remove_stops_from_minimal_transfer_times(stop_ids)\n\n    self._graph.graph[\"change_log\"] = self._graph.graph[\"change_log\"].remove_bunch(\n        object_type=\"stop\", id_bunch=stop_ids, attributes_bunch=stop_data\n    )\n    logging.info(\n        f\"Removed Stops with indices `{stop_ids}`.\"\n        f\"Routes affected: {routes_affected}. Services affected: {services_affected}.\"\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_stops_from_minimal_transfer_times","title":"<code>remove_stops_from_minimal_transfer_times(stop_ids)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_stops_from_minimal_transfer_times(self, stop_ids):\n    # first level keys of the min transfer times\n    # 'stop_to_remove' : {'stop_1': 10}\n    [self.minimal_transfer_times.pop(s) for s in stop_ids if s in self.minimal_transfer_times]\n    # second level, stops the keys are mapping to\n    # 'stop_1' : {'stop_to_remove': 10}\n    [\n        [val.pop(s) for s in stop_ids if s in val]\n        for k, val in self.minimal_transfer_times.items()\n    ]\n    # clean up empties in the second level\n    # 'stop_1' : {}\n    empties = [s for s, val in self.minimal_transfer_times.items() if not val]\n    [self.minimal_transfer_times.pop(s) for s in empties if s in self.minimal_transfer_times]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_unsused_stops","title":"<code>remove_unsused_stops()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_unsused_stops(self):\n    logging.warning(\n        \"This method has been replaced due to incorrect spelling and is now deprecated. \"\n        \"It will be removed in future versions. Please use `remove_unused_stops` instead.\"\n    )\n    self.remove_unused_stops()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.remove_unused_stops","title":"<code>remove_unused_stops()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def remove_unused_stops(self):\n    stops_to_remove = set()\n    for stop, data in self._graph.nodes(data=\"routes\"):\n        if not data:\n            stops_to_remove.add(stop)\n    # but leave those stops that have transfers\n    stops_to_remove = stops_to_remove - set().union(\n        *[{from_s} | set(val.keys()) for from_s, val in self.minimal_transfer_times.items()]\n    )\n    if stops_to_remove:\n        self.remove_stops(stops_to_remove)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.reproject","title":"<code>reproject(new_epsg, processes=1)</code>","text":"<p>Changes projection of the element to <code>new_epsg</code>.</p> PARAMETER DESCRIPTION <code>new_epsg</code> <p>New projection, e.g., \"epsg:1234\".</p> <p> TYPE: <code>str</code> </p> <code>processes</code> <p>Number of parallel processes to use when reprojecting. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reproject(self, new_epsg: str, processes: int = 1):\n    \"\"\"Changes projection of the element to `new_epsg`.\n\n    Args:\n        new_epsg (str):\n            New projection, e.g., \"epsg:1234\".\n        processes (int, optional):\n            Number of parallel processes to use when reprojecting. Defaults to 1.\n    \"\"\"\n    ScheduleElement.reproject(self, new_epsg, processes=processes)\n    self._graph.graph[\"crs\"] = new_epsg\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.route","title":"<code>route(route_id)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route(self, route_id: Union[str, int]) -&gt; \"Route\":\n    return self._get_route_from_graph(route_id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.route_attribute_data","title":"<code>route_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_attribute_data(self, keys: Union[list, str], index_name: Optional[str] = None):\n    return graph_operations.build_attribute_dataframe(\n        iterator=self._graph.graph[\"routes\"].items(), keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.route_attribute_summary","title":"<code>route_attribute_summary(data=False)</code>","text":"<p>Parses through data stored for Routes in the Schedule and gives a summary tree.</p> PARAMETER DESCRIPTION <code>data</code> <p>If True, shows also up to 5 unique values stored under such keys. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_attribute_summary(self, data: bool = False):\n    \"\"\"Parses through data stored for Routes in the Schedule and gives a summary tree.\n\n    Args:\n        data (bool, optional): If True, shows also up to 5 unique values stored under such keys. Defaults to False.\n    \"\"\"\n    root = graph_operations.get_attribute_schema(self._graph.graph[\"routes\"].items(), data=data)\n    graph_operations.render_tree(root, data)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.route_ids","title":"<code>route_ids()</code>","text":"<p>Returns list of route ids in the Schedule</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_ids(self):\n    \"\"\"\n    Returns list of route ids in the Schedule\n    \"\"\"\n    return list(self._graph.graph[\"routes\"].keys())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.route_to_service_map","title":"<code>route_to_service_map()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_to_service_map(self):\n    return self._graph.graph[\"route_to_service_map\"]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.routes","title":"<code>routes()</code>","text":"<p>Iterator for Route objects in the Services of the Schedule</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def routes(self):\n    \"\"\"\n    Iterator for Route objects in the Services of the Schedule\n    \"\"\"\n    for route_id in self.route_ids():\n        yield self._get_route_from_graph(route_id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.routes_on_modal_condition","title":"<code>routes_on_modal_condition(modes)</code>","text":"<p>Finds Route IDs with modes or singular mode given in <code>modes</code></p> PARAMETER DESCRIPTION <code>modes</code> <p>string mode e.g. 'bus' or a list of such modes e.g. ['bus', 'rail'].</p> <p> TYPE: <code>Union[str, list]</code> </p> RETURNS DESCRIPTION <code>list</code> <p>list of Route IDs</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def routes_on_modal_condition(self, modes: Union[str, list]) -&gt; list:\n    \"\"\"\n    Finds Route IDs with modes or singular mode given in `modes`\n\n    Args:\n        modes (Union[str, list]):  string mode e.g. 'bus' or a list of such modes e.g. ['bus', 'rail'].\n\n    Returns:\n        list: list of Route IDs\n    \"\"\"\n    conditions = {\"mode\": modes}\n    return self.extract_route_ids_on_attributes(conditions=conditions)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.routes_on_spatial_condition","title":"<code>routes_on_spatial_condition(region_input, how='intersect')</code>","text":"<p>Returns Route IDs which intersect region_input, by default, or are contained within region_input if how='within'.</p> PARAMETER DESCRIPTION <code>region_input</code> <ul> <li>path to a geojson file, can have multiple features.</li> <li>string with comma separated hex tokens of Google's S2 geometry. A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/. E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.</li> <li>shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.</li> </ul> <p> TYPE: <code>Union[str, BaseGeometry]</code> </p> <code>how</code> <p>Defaults to \"intersect\". - 'intersect' will return IDs of the Services whose at least one Stop intersects the <code>region_input</code>. - 'within' will return IDs of the Services whose all of the Stops are contained within the <code>region_input</code>.</p> <p> TYPE: <code>Literal[intersect, within]</code> DEFAULT: <code>'intersect'</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Route IDs</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def routes_on_spatial_condition(\n    self,\n    region_input: Union[str, BaseGeometry],\n    how: Literal[\"interact\", \"within\"] = \"intersect\",\n) -&gt; list:\n    \"\"\"\n    Returns Route IDs which intersect region_input, by default, or are contained within region_input if how='within'.\n\n    Args:\n        region_input (Union[str, BaseGeometry]):\n            - path to a geojson file, can have multiple features.\n            - string with comma separated hex tokens of Google's S2 geometry.\n            A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/.\n            E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.\n            - shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.\n        how (Literal[intersect, within], optional):\n            Defaults to \"intersect\".\n            - 'intersect' will return IDs of the Services whose at least one Stop intersects the `region_input`.\n            - 'within' will return IDs of the Services whose all of the Stops are contained within the `region_input`.\n\n    Returns:\n        list: Route IDs\n    \"\"\"\n    stops_intersecting = set(self.stops_on_spatial_condition(region_input))\n    if how == \"intersect\":\n        return list(\n            {\n                item\n                for sublist in [self._graph.nodes[x][\"routes\"] for x in stops_intersecting]\n                for item in sublist\n            }\n        )\n    elif how == \"within\":\n        return self.extract_route_ids_on_attributes(\n            conditions={\"ordered_stops\": lambda x: set(x).issubset(stops_intersecting)},\n            mixed_dtypes=False,\n        )\n    else:\n        raise NotImplementedError(\"Only `intersect` and `within` options for `how` param.\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.scale_vehicle_capacity","title":"<code>scale_vehicle_capacity(capacity_scale, pce_scale, output_dir)</code>","text":"<p>This method scales the vehicle capacities and pce to user defined scales and writes a new vehicle.xml.</p> PARAMETER DESCRIPTION <code>capacity_scale</code> <p>vehicle capacity scale</p> <p> TYPE: <code>float</code> </p> <code>pce_scale</code> <p>passenger car equivalents scale</p> <p> TYPE: <code>float</code> </p> <code>output_dir</code> <p>Directory to save <code>vehicle.xml</code></p> <p> TYPE: <code>str</code> </p> Example <p>For 5%: <code>!#python scale_vehicle_capacity(0.05, 0.05,\"\")</code></p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def scale_vehicle_capacity(self, capacity_scale: float, pce_scale: float, output_dir: str):\n    \"\"\"This method scales the vehicle capacities and pce to user defined scales and writes a new vehicle.xml.\n\n    Args:\n        capacity_scale (float): vehicle capacity scale\n        pce_scale (float):  passenger car equivalents scale\n        output_dir (str): Directory to save `vehicle.xml`\n\n    Example:\n        For 5%: `!#python scale_vehicle_capacity(0.05, 0.05,\"\")`\n    \"\"\"\n    # save copy of existing vehicle data\n    vehicle_types_dict = deepcopy(self.vehicle_types)\n\n    # scale capacity and pce to defined scale\n    for mode, mode_dict in self.vehicle_types.items():\n        mode_dict[\"capacity\"][\"seats\"][\"persons\"] = str(\n            round(float(mode_dict[\"capacity\"][\"seats\"][\"persons\"]) * capacity_scale)\n        )\n        mode_dict[\"capacity\"][\"standingRoom\"][\"persons\"] = str(\n            round(float(mode_dict[\"capacity\"][\"standingRoom\"][\"persons\"]) * capacity_scale)\n        )\n        mode_dict[\"passengerCarEquivalents\"][\"pce\"] = str(\n            round(float(mode_dict[\"passengerCarEquivalents\"][\"pce\"]) * pce_scale, 3)\n        )\n\n    # export scaled vehicles xml\n    persistence.ensure_dir(output_dir)\n    matsim_xml_writer.write_vehicles(\n        output_dir,\n        self.vehicles,\n        self.vehicle_types,\n        f\"{int(capacity_scale * 100)}_perc_vehicles.xml\",\n    )\n\n    self.vehicle_types = vehicle_types_dict\n\n    logging.info(\n        f\"Created scaled vehicle file for {int(capacity_scale * 100)}% capacity &amp; \"\n        f\"{int(pce_scale * 100)}% pce.\"\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.service_attribute_data","title":"<code>service_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_attribute_data(\n    self, keys: Union[list, str], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    return graph_operations.build_attribute_dataframe(\n        iterator=self._graph.graph[\"services\"].items(), keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.service_attribute_summary","title":"<code>service_attribute_summary(data=False)</code>","text":"<p>Parses through data stored for Services in the Schedule and prints a summary tree.</p> PARAMETER DESCRIPTION <code>data</code> <p>If True, shows also up to 5 unique values stored under such keys. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_attribute_summary(self, data: bool = False):\n    \"\"\"Parses through data stored for Services in the Schedule and prints a summary tree.\n\n    Args:\n        data (bool, optional): If True, shows also up to 5 unique values stored under such keys. Defaults to False.\n    \"\"\"\n    root = graph_operations.get_attribute_schema(\n        self._graph.graph[\"services\"].items(), data=data\n    )\n    graph_operations.render_tree(root, data)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.service_ids","title":"<code>service_ids()</code>","text":"<p>Returns list of service ids in the Schedule</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_ids(self):\n    \"\"\"\n    Returns list of service ids in the Schedule\n    \"\"\"\n    return list(self._graph.graph[\"services\"].keys())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.service_to_route_map","title":"<code>service_to_route_map()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_to_route_map(self):\n    return self._graph.graph[\"service_to_route_map\"]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.services","title":"<code>services()</code>","text":"<p>Iterator for Service objects in the Services of the Schedule</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def services(self):\n    \"\"\"\n    Iterator for Service objects in the Services of the Schedule\n    \"\"\"\n    for service_id in self.service_ids():\n        yield self._get_service_from_graph(service_id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.services_on_modal_condition","title":"<code>services_on_modal_condition(modes)</code>","text":"<p>Finds Service IDs which hold Routes with modes or singular mode given in <code>modes</code>. Note that a Service can have Routes with different modes.</p> PARAMETER DESCRIPTION <code>modes</code> <p>string mode e.g. 'bus' or a list of such modes e.g. ['bus', 'rail'].</p> <p> TYPE: <code>Union[str, list]</code> </p> RETURNS DESCRIPTION <code>list</code> <p>list of Service IDs</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def services_on_modal_condition(self, modes: Union[str, list]) -&gt; list:\n    \"\"\"\n    Finds Service IDs which hold Routes with modes or singular mode given in `modes`.\n    Note that a Service can have Routes with different modes.\n\n    Args:\n        modes (Union[str, list]):  string mode e.g. 'bus' or a list of such modes e.g. ['bus', 'rail'].\n\n    Returns:\n        list: list of Service IDs\n    \"\"\"\n    route_ids = self.routes_on_modal_condition(modes=modes)\n    return list({self._graph.graph[\"route_to_service_map\"][r_id] for r_id in route_ids})\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.services_on_spatial_condition","title":"<code>services_on_spatial_condition(region_input, how='intersect')</code>","text":"<p>Returns Service IDs which intersect region_input, by default, or are contained within region_input if how='within'.</p> PARAMETER DESCRIPTION <code>region_input</code> <ul> <li>path to a geojson file, can have multiple features.</li> <li>string with comma separated hex tokens of Google's S2 geometry. A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/. E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.</li> <li>shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.</li> </ul> <p> TYPE: <code>Union[str, BaseGeometry]</code> </p> <code>how</code> <p>Defaults to \"intersect\". - 'intersect' will return IDs of the Services whose at least one Stop intersects the <code>region_input</code>. - 'within' will return IDs of the Services whose all of the Stops are contained within the <code>region_input</code>.</p> <p> TYPE: <code>Literal[intersect, within]</code> DEFAULT: <code>'intersect'</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Service IDs</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def services_on_spatial_condition(\n    self,\n    region_input: Union[str, BaseGeometry],\n    how: Literal[\"interact\", \"within\"] = \"intersect\",\n) -&gt; list:\n    \"\"\"Returns Service IDs which intersect region_input, by default, or are contained within region_input if how='within'.\n\n    Args:\n        region_input (Union[str, BaseGeometry]):\n            - path to a geojson file, can have multiple features.\n            - string with comma separated hex tokens of Google's S2 geometry.\n            A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/.\n            E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.\n            - shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.\n        how (Literal[intersect, within], optional):\n            Defaults to \"intersect\".\n            - 'intersect' will return IDs of the Services whose at least one Stop intersects the `region_input`.\n            - 'within' will return IDs of the Services whose all of the Stops are contained within the `region_input`.\n\n    Returns:\n        list: Service IDs\n    \"\"\"\n    if how == \"intersect\":\n        stops_intersecting = self.stops_on_spatial_condition(region_input)\n        return list(\n            {\n                item\n                for sublist in [self._graph.nodes[x][\"services\"] for x in stops_intersecting]\n                for item in sublist\n            }\n        )\n    elif how == \"within\":\n        routes_contained = set(self.routes_on_spatial_condition(region_input, how=\"within\"))\n        return [\n            service_id\n            for service_id, route_ids in self._graph.graph[\"service_to_route_map\"].items()\n            if set(route_ids).issubset(routes_contained)\n        ]\n    else:\n        raise NotImplementedError(\"Only `intersect` and `within` options for `how` param.\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.set_route_trips_dataframe","title":"<code>set_route_trips_dataframe(df)</code>","text":"<p>This method exists for backwards compatibility only Please use set_trips_dataframe</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def set_route_trips_dataframe(self, df):\n    \"\"\"\n    This method exists for backwards compatibility only\n    Please use set_trips_dataframe\n    \"\"\"\n    logging.warning(\n        \"`set_route_trips_dataframe` method is deprecated and will be replaced by `set_trips_dataframe`\"\n        \"in later versions.\"\n    )\n    return self.set_trips_dataframe(df)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.set_trips_dataframe","title":"<code>set_trips_dataframe(df)</code>","text":"<p>Option to replace trips data currently stored under routes by an updated <code>trips_to_dataframe</code>.</p> <p>Need not be exhaustive in terms of routes. I.e. trips for some of the routes can be omitted if no changes are required. Needs to be exhaustive in terms of trips. I.e. if there are changes to a route, all of the trips required to be in that trip need to be present, it overwrites route.trips attribute.</p> PARAMETER DESCRIPTION <code>df</code> <p>generated by <code>trips_to_dataframe</code> (or of the same format)</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def set_trips_dataframe(self, df: pd.DataFrame):\n    \"\"\"Option to replace trips data currently stored under routes by an updated `trips_to_dataframe`.\n\n    Need not be exhaustive in terms of routes. I.e. trips for some of the routes can be omitted if no changes are\n    required. Needs to be exhaustive in terms of trips. I.e. if there are changes to a route, all of the trips\n    required to be in that trip need to be present, it overwrites route.trips attribute.\n\n    Args:\n        df (pd.DataFrame): generated by `trips_to_dataframe` (or of the same format)\n    \"\"\"\n    # convert route trips dataframe to apply dictionary shape and give to apply to routes method\n    df[\"trip_departure_time\"] = df[\"trip_departure_time\"].dt.strftime(\"%H:%M:%S\")\n    df = df.groupby(\"route_id\").apply(\n        lambda x: Series(\n            {\n                \"trips\": {\n                    k: x[k].to_list() for k in [\"trip_id\", \"trip_departure_time\", \"vehicle_id\"]\n                }\n            }\n        )\n    )\n    self.apply_attributes_to_routes(df.T.to_dict())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.stop_attribute_data","title":"<code>stop_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stop_attribute_data(self, keys: Union[list, str], index_name: Optional[str] = None):\n    return graph_operations.build_attribute_dataframe(\n        iterator=self._graph.nodes(data=True), keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.stop_attribute_summary","title":"<code>stop_attribute_summary(data=False)</code>","text":"<p>Parses through data stored for Stops in the Schedule and gives a summary tree.</p> PARAMETER DESCRIPTION <code>data</code> <p>If True, shows also up to 5 unique values stored under such keys. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stop_attribute_summary(self, data: bool = False):\n    \"\"\"Parses through data stored for Stops in the Schedule and gives a summary tree.\n\n    Args:\n        data (bool, optional): If True, shows also up to 5 unique values stored under such keys. Defaults to False.\n    \"\"\"\n    root = graph_operations.get_attribute_schema(self._graph.nodes(data=True), data=data)\n    graph_operations.render_tree(root, data)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.stops_on_modal_condition","title":"<code>stops_on_modal_condition(modes)</code>","text":"<p>Finds Stop IDs used by Routes with modes or singular mode given in <code>modes</code></p> PARAMETER DESCRIPTION <code>modes</code> <p>string mode e.g. 'bus' or a list of such modes e.g. ['bus', 'rail'].</p> <p> TYPE: <code>Union[str, list]</code> </p> RETURNS DESCRIPTION <code>list</code> <p>list of Stop IDs</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stops_on_modal_condition(self, modes: Union[str, list]) -&gt; list:\n    \"\"\"\n    Finds Stop IDs used by Routes with modes or singular mode given in `modes`\n\n    Args:\n        modes (Union[str, list]):  string mode e.g. 'bus' or a list of such modes e.g. ['bus', 'rail'].\n\n    Returns:\n        list: list of Stop IDs\n    \"\"\"\n    route_ids = self.routes_on_modal_condition(modes=modes)\n    return self.extract_stop_ids_on_attributes(conditions={\"routes\": route_ids})\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.stops_on_spatial_condition","title":"<code>stops_on_spatial_condition(region_input)</code>","text":"<p>Returns Stop IDs which intersect region_input.</p> PARAMETER DESCRIPTION <code>region_input</code> <ul> <li>path to a geojson file, can have multiple features.</li> <li>string with comma separated hex tokens of Google's S2 geometry. A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/. E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.</li> <li>shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.</li> </ul> <p> TYPE: <code>Union[str, BaseGeometry]</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Stop IDs</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stops_on_spatial_condition(self, region_input: Union[str, BaseGeometry]) -&gt; list:\n    \"\"\"Returns Stop IDs which intersect region_input.\n\n    Args:\n        region_input (Union[str, BaseGeometry]):\n            - path to a geojson file, can have multiple features.\n            - string with comma separated hex tokens of Google's S2 geometry.\n            A region can be covered with cells and the tokens string copied using http://s2.sidewalklabs.com/regioncoverer/.\n            E.g., '89c25985,89c25987,89c2598c,89c25994,89c25999ffc,89c2599b,89c259ec,89c259f4,89c25a1c,89c25a24'.\n            - shapely.geometry object, e.g. Polygon or a shapely.geometry.GeometryCollection of such objects.\n\n    Returns:\n        list: Stop IDs\n    \"\"\"\n    if isinstance(region_input, str):\n        if persistence.is_geojson(region_input):\n            return self._find_stops_on_geojson(region_input)\n        else:\n            # is assumed to be hex\n            return self._find_stops_on_s2_geometry(region_input)\n    else:\n        # assumed to be a shapely.geometry input\n        return self._find_stops_on_shapely_geometry(region_input)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.subschedule","title":"<code>subschedule(service_ids)</code>","text":"<p>Subset a Schedule object using a spatial bound. Args:     service_ids (list): Collection of service IDs in the Schedule for subsetting.</p> RETURNS DESCRIPTION <code>Schedule</code> <p>A new Schedule object that is a subset of the original.</p> <p> TYPE: <code>Schedule</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def subschedule(self, service_ids: list) -&gt; \"Schedule\":\n    \"\"\"Subset a Schedule object using a spatial bound.\n    Args:\n        service_ids (list): Collection of service IDs in the Schedule for subsetting.\n\n    Returns:\n        Schedule: A new Schedule object that is a subset of the original.\n    \"\"\"\n    subschedule = self.__copy__()\n    for s in subschedule.service_ids():\n        if s not in service_ids:\n            subschedule.remove_service(s)\n    subschedule.remove_unused_stops()\n    return subschedule\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.subschedule_on_spatial_condition","title":"<code>subschedule_on_spatial_condition(region_input, how='intersect')</code>","text":"<p>Subset a Schedule object using a spatial</p> <p>Schedule: A new Schedule object that is a subset of the original</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def subschedule_on_spatial_condition(\n    self,\n    region_input: Union[str, BaseGeometry],\n    how: Literal[\"interact\", \"within\"] = \"intersect\",\n) -&gt; \"Schedule\":\n    \"\"\"Subset a Schedule object using a spatial\n\n    Schedule: A new Schedule object that is a subset of the original\n    \"\"\"\n    services_to_keep = self.services_on_spatial_condition(region_input=region_input, how=how)\n    return self.subschedule(service_ids=services_to_keep)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.summary","title":"<code>summary()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def summary(self):\n    report = {}\n    schedule_stats = {\n        \"number_of_services\": self.__len__(),\n        \"number_of_routes\": self.number_of_routes(),\n        \"number_of_stops\": len(self.reference_nodes()),\n    }\n    report[\"schedule_info\"] = schedule_stats\n\n    report[\"modes\"] = {}\n    schedule_modes = self.modes()\n    report[\"modes\"][\"modes_in_schedule\"] = schedule_modes\n\n    services_by_modes = {}\n    for mode in schedule_modes:\n        services_by_modes[mode] = len(self.services_on_modal_condition(mode))\n    report[\"modes\"][\"services_by_mode\"] = services_by_modes\n\n    stops_by_modes = {}\n    for mode in schedule_modes:\n        stops_by_modes[mode] = len(self.stops_on_modal_condition(mode))\n    report[\"modes\"][\"pt_stops_by_mode\"] = stops_by_modes\n\n    df = pd.DataFrame(list(self.stop_attribute_data(\"attributes\")[\"attributes\"]))\n    report[\"stop_attributes\"] = set(df.columns)\n    report[\"accessibility_tags\"] = {}\n    for col in df.columns:\n        if \"Accessible\" in col:\n            mode = col.replace(\"Accessible\", \"\")\n            network_access_tag = f\"accessLinkId_{mode}\"\n            report[\"accessibility_tags\"][mode] = {\n                \"access_tag\": col,\n                \"number_of_stops_with_access_tag\": len(df[col].dropna()),\n                \"unique_values_under_access_tag\": set(df[col].dropna().unique()),\n                \"link_access_tag\": (\n                    network_access_tag\n                    if network_access_tag in df.columns\n                    else \"not_connected_to_network\"\n                ),\n                \"number_of_stops_with_link_access_tag\": (\n                    len(df[network_access_tag].dropna())\n                    if network_access_tag in df.columns\n                    else 0\n                ),\n            }\n    return report\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.to_gtfs","title":"<code>to_gtfs(gtfs_day, mode_to_route_type=None)</code>","text":"<p>Transforms Schedule in to GTFS-like format.</p> <p>It's not full GTFS as it only represents one day, misses a lot of optional data and does not include <code>agency.txt</code> required file. Produces 'stops', 'routes', 'trips', 'stop_times', 'calendar' tables.</p> PARAMETER DESCRIPTION <code>gtfs_day</code> <p>day used for GTFS when creating the network in YYYYMMDD format</p> <p> TYPE: <code>str</code> </p> <code>mode_to_route_type</code> <p>PT modes in Route objects to route type code by default uses https://developers.google.com/transit/gtfs/reference#routestxt Example: <pre><code>{\n    \"tram\": 0, \"subway\": 1, \"rail\": 2, \"bus\": 3, \"ferry\": 4, \"cablecar\": 5, \"gondola\": 6, \"funicular\": 7\n}\n</code></pre> Reference for extended mode types: https://developers.google.com/transit/gtfs/reference/extended-route-types.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>keys are the names of the tables e.g. <code>stops</code> for the <code>stops.txt</code> file, values are pandas.DataFrame tables.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def to_gtfs(self, gtfs_day: str, mode_to_route_type: Optional[dict] = None) -&gt; dict:\n    \"\"\"Transforms Schedule in to GTFS-like format.\n\n    It's not full GTFS as it only represents one day, misses a lot of optional data and does not include `agency.txt` required file.\n    Produces 'stops', 'routes', 'trips', 'stop_times', 'calendar' tables.\n\n    Args:\n        gtfs_day (str): day used for GTFS when creating the network in YYYYMMDD format\n        mode_to_route_type (Optional[dict], optional):\n            PT modes in Route objects to route type code by default uses https://developers.google.com/transit/gtfs/reference#routestxt\n            Example:\n            ```python\n            {\n                \"tram\": 0, \"subway\": 1, \"rail\": 2, \"bus\": 3, \"ferry\": 4, \"cablecar\": 5, \"gondola\": 6, \"funicular\": 7\n            }\n            ```\n            Reference for extended mode types:\n            https://developers.google.com/transit/gtfs/reference/extended-route-types.\n\n    Returns:\n        dict: keys are the names of the tables e.g. `stops` for the `stops.txt` file, values are pandas.DataFrame tables.\n    \"\"\"\n    stops = self.stop_attribute_data(\n        keys=[\n            \"id\",\n            \"name\",\n            \"lat\",\n            \"lon\",\n            \"stop_code\",\n            \"stop_desc\",\n            \"zone_id\",\n            \"stop_url\",\n            \"location_type\",\n            \"parent_station\",\n            \"stop_timezone\",\n            \"wheelchair_boarding\",\n            \"level_id\",\n            \"platform_code\",\n        ]\n    )\n    stops = stops.rename(\n        columns={\"id\": \"stop_id\", \"name\": \"stop_name\", \"lat\": \"stop_lat\", \"lon\": \"stop_lon\"}\n    )\n\n    routes = self.route_attribute_data(\n        keys=[\n            \"id\",\n            \"route_short_name\",\n            \"route_long_name\",\n            \"mode\",\n            \"agency_id\",\n            \"route_desc\",\n            \"route_url\",\n            \"route_type\",\n            \"route_color\",\n            \"route_text_color\",\n            \"route_sort_order\",\n            \"continuous_pickup\",\n            \"continuous_drop_off\",\n        ]\n    )\n    if mode_to_route_type is None:\n        mode_to_route_type = {\n            \"tram\": 0,\n            \"subway\": 1,\n            \"rail\": 2,\n            \"bus\": 3,\n            \"ferry\": 4,\n            \"cablecar\": 5,\n            \"gondola\": 6,\n            \"funicular\": 7,\n        }\n    routes.loc[routes[\"route_type\"].isna(), \"route_type\"] = routes.loc[\n        routes[\"route_type\"].isna(), \"mode\"\n    ].map(mode_to_route_type)\n    routes[\"route_id\"] = routes[\"id\"].map(self._graph.graph[\"route_to_service_map\"])\n    routes = routes.drop([\"mode\", \"id\"], axis=1)\n    routes = routes.groupby(\"route_id\").first().reset_index()\n\n    trips = self.route_attribute_data(\n        keys=[\"id\", \"ordered_stops\", \"arrival_offsets\", \"departure_offsets\"]\n    )\n    trips = trips.merge(self.trips_to_dataframe(), left_on=\"id\", right_on=\"route_id\")\n    trips[\"route_id\"] = trips[\"service_id\"]\n\n    # expand the frame for stops and offsets to get stop times\n    trips[\"stop_sequence\"] = trips[\"ordered_stops\"].apply(lambda x: list(range(len(x))))\n    trips[\"departure_offsets\"] = trips[\"departure_offsets\"].apply(\n        lambda x: list(map(use_schedule.get_offset, x))\n    )\n    trips[\"arrival_offsets\"] = trips[\"arrival_offsets\"].apply(\n        lambda x: list(map(use_schedule.get_offset, x))\n    )\n    stop_times = DataFrame(\n        {\n            col: np.repeat(trips[col].values, trips[\"ordered_stops\"].str.len())\n            for col in {\"trip_id\", \"trip_departure_time\"}\n        }\n    ).assign(\n        stop_id=np.concatenate(trips[\"ordered_stops\"].values),\n        stop_sequence=np.concatenate(trips[\"stop_sequence\"].values),\n        departure_time=np.concatenate(trips[\"departure_offsets\"].values),\n        arrival_time=np.concatenate(trips[\"arrival_offsets\"].values),\n    )\n    stop_times[\"arrival_time\"] = (\n        stop_times[\"trip_departure_time\"] + stop_times[\"arrival_time\"]\n    ).dt.strftime(\"%H:%M:%S\")\n    stop_times[\"departure_time\"] = (\n        stop_times[\"trip_departure_time\"] + stop_times[\"departure_time\"]\n    ).dt.strftime(\"%H:%M:%S\")\n    stop_times = stop_times.drop([\"trip_departure_time\"], axis=1)\n    for col in [\n        \"stop_headsign\",\n        \"pickup_type\",\n        \"drop_off_type\",\n        \"continuous_pickup\",\n        \"continuous_drop_off\",\n        \"shape_dist_traveled\",\n        \"timepoint\",\n    ]:\n        stop_times[col] = float(\"nan\")\n\n    # finish off trips frame\n    trips = trips[[\"route_id\", \"service_id\", \"trip_id\"]]\n    for col in [\n        \"trip_headsign\",\n        \"trip_short_name\",\n        \"direction_id\",\n        \"block_id\",\n        \"shape_id\",\n        \"wheelchair_accessible\",\n        \"bikes_allowed\",\n    ]:\n        trips[col] = float(\"nan\")\n\n    calendar = DataFrame(routes[\"route_id\"])\n    for col in [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"]:\n        calendar[col] = 1\n    calendar[\"start_date\"] = gtfs_day\n    calendar[\"end_date\"] = gtfs_day\n    return {\n        \"stops\": stops,\n        \"routes\": routes,\n        \"trips\": trips,\n        \"stop_times\": stop_times,\n        \"calendar\": calendar,\n    }\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.to_json","title":"<code>to_json()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def to_json(self):\n    stop_keys = {\n        d.name\n        for d in graph_operations.get_attribute_schema(self._graph.nodes(data=True)).children\n    }\n    stop_keys = stop_keys - {\"routes\", \"services\", \"additional_attributes\", \"epsg\"}\n    stops = self.stop_attribute_data(keys=stop_keys)\n    services = self._graph.graph[\"services\"]\n    for service_id, data in services.items():\n        data[\"routes\"] = {\n            route_id: self._graph.graph[\"routes\"][route_id]\n            for route_id in self._graph.graph[\"service_to_route_map\"][service_id]\n        }\n    d = {\"stops\": dict_support.dataframe_to_dict(stops.T), \"services\": services}\n    if self.minimal_transfer_times:\n        d[\"minimal_transfer_times\"] = self.minimal_transfer_times\n    return {\n        \"schedule\": d,\n        \"vehicles\": {\"vehicle_types\": self.vehicle_types, \"vehicles\": self.vehicles},\n    }\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.trips_to_dataframe","title":"<code>trips_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def trips_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    df = self.route_attribute_data(\n        keys=[{\"trips\": \"trip_id\"}, {\"trips\": \"trip_departure_time\"}, {\"trips\": \"vehicle_id\"}],\n        index_name=\"route_id\",\n    )\n    df = df.reset_index()\n    df[\"service_id\"] = df[\"route_id\"].apply(\n        lambda x: self._graph.graph[\"route_to_service_map\"][x]\n    )\n    df[\"mode\"] = df[\"route_id\"].apply(lambda x: self.graph().graph[\"routes\"][x][\"mode\"])\n    df = df.rename(\n        columns={\n            \"trips::trip_id\": \"trip_id\",\n            \"trips::trip_departure_time\": \"trip_departure_time\",\n            \"trips::vehicle_id\": \"vehicle_id\",\n        }\n    )\n    df = DataFrame(\n        {\n            col: np.repeat(df[col].values, df[\"trip_id\"].str.len())\n            for col in set(df.columns) - {\"trip_id\", \"trip_departure_time\", \"vehicle_id\"}\n        }\n    ).assign(\n        trip_id=np.concatenate(df[\"trip_id\"].values),\n        trip_departure_time=np.concatenate(df[\"trip_departure_time\"].values),\n        vehicle_id=np.concatenate(df[\"vehicle_id\"].values),\n    )\n    df[\"trip_departure_time\"] = df[\"trip_departure_time\"].apply(\n        lambda x: use_schedule.sanitise_time(x, gtfs_day)\n    )\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.trips_with_stops_to_dataframe","title":"<code>trips_with_stops_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def trips_with_stops_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    df = self.route_attribute_data(\n        keys=[\n            \"route_short_name\",\n            \"mode\",\n            \"trips\",\n            \"arrival_offsets\",\n            \"departure_offsets\",\n            \"ordered_stops\",\n            \"id\",\n        ]\n    )\n    df = df.rename(columns={\"id\": \"route_id\", \"route_short_name\": \"route_name\"})\n    df[\"route_name\"] = df[\"route_name\"].apply(lambda x: x.replace(\"\\\\\", \"_\").replace(\"/\", \"_\"))\n    df[\"service_id\"] = df[\"route_id\"].apply(\n        lambda x: self._graph.graph[\"route_to_service_map\"][x]\n    )\n    df[\"service_name\"] = df[\"service_id\"].apply(\n        lambda x: self._graph.graph[\"services\"][x][\"name\"].replace(\"\\\\\", \"_\").replace(\"/\", \"_\")\n    )\n    df[\"ordered_stops\"] = df[\"ordered_stops\"].apply(lambda x: list(zip(x[:-1], x[1:])))\n    df[\"departure_offsets\"] = df[\"departure_offsets\"].apply(\n        lambda x: list(map(use_schedule.get_offset, x[:-1]))\n    )\n    df[\"arrival_offsets\"] = df[\"arrival_offsets\"].apply(\n        lambda x: list(map(use_schedule.get_offset, x[1:]))\n    )\n\n    # expand the frame stop to stop and extract offsets for arrival and departure from these stops\n    stop_cols = np.concatenate(df[\"ordered_stops\"].values)\n    dep_offset_cols = np.concatenate(df[\"departure_offsets\"].values)\n    arr_offset_cols = np.concatenate(df[\"arrival_offsets\"].values)\n    df = DataFrame(\n        {\n            col: np.repeat(df[col].values, df[\"ordered_stops\"].str.len())\n            for col in set(df.columns)\n            - {\"ordered_stops\", \"arrival_offsets\", \"departure_offsets\"}\n        }\n    ).assign(\n        from_stop=stop_cols[:, 0],\n        to_stop=stop_cols[:, 1],\n        departure_time=dep_offset_cols,\n        arrival_time=arr_offset_cols,\n    )\n\n    df[\"from_stop_name\"] = df[\"from_stop\"].apply(\n        lambda x: self._graph.nodes[x][\"name\"].replace(\"\\\\\", \"_\").replace(\"/\", \"_\")\n    )\n    df[\"to_stop_name\"] = df[\"to_stop\"].apply(\n        lambda x: self._graph.nodes[x][\"name\"].replace(\"\\\\\", \"_\").replace(\"/\", \"_\")\n    )\n\n    # expand the frame on all the trips each route makes\n    trips = np.concatenate(\n        df[\"trips\"]\n        .apply(\n            lambda x: [\n                (trip_id, use_schedule.sanitise_time(trip_dep_time, gtfs_day), veh_id)\n                for trip_id, trip_dep_time, veh_id in zip(\n                    x[\"trip_id\"], x[\"trip_departure_time\"], x[\"vehicle_id\"]\n                )\n            ]\n        )\n        .values\n    )\n    df = (\n        DataFrame(\n            {\n                col: np.repeat(df[col].values, df[\"trips\"].str[\"trip_id\"].str.len())\n                for col in set(df.columns) - {\"trips\"}\n            }\n        )\n        .assign(trip_id=trips[:, 0], trip_dep_time=trips[:, 1], vehicle_id=trips[:, 2])\n        .sort_values(by=[\"route_id\", \"trip_id\", \"departure_time\"])\n        .reset_index(drop=True)\n    )\n\n    df[\"departure_time\"] = df[\"trip_dep_time\"] + df[\"departure_time\"]\n    df[\"arrival_time\"] = df[\"trip_dep_time\"] + df[\"arrival_time\"]\n    df = df.drop(\"trip_dep_time\", axis=1)\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.unused_vehicles","title":"<code>unused_vehicles()</code>","text":"<p>A scenario change to the network may result in changes to vehicle assignments, with some vehicles not being used anymore. This method checks if any of the vehicles are missing (i.e. exist in Schedule.vehicles, but are not used by services) and returns a list of these vehicles' IDs, if there are any. It also logs a warning which says whether any unused vehicles have been found.</p> <p>self.vehicles = dictionary of vehicle IDs from Route objects, in form {veh_id : {'type': 'bus'}} e.g.  {'fun_bus_1': {'type': 'bus'}, 'fun_bus_2': {'type': 'bus'}, 'some_bus_2': {'type': 'bus'}}</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def unused_vehicles(self):\n    \"\"\"\n    A scenario change to the network may result in changes to vehicle assignments, with some vehicles not\n    being used anymore. This method checks if any of the vehicles are missing (i.e. exist in Schedule.vehicles,\n    but are not used by services) and returns a list of these vehicles' IDs, if there are any.\n    It also logs a warning which says whether any unused vehicles have been found.\n\n    self.vehicles = dictionary of vehicle IDs from Route objects, in form {veh_id : {'type': 'bus'}}\n    e.g.  {'fun_bus_1': {'type': 'bus'}, 'fun_bus_2': {'type': 'bus'}, 'some_bus_2': {'type': 'bus'}}\n    \"\"\"\n\n    existing_vehicles = set(self.vehicles.keys())\n    used_vehicles = self.trips_to_dataframe()\n    used_vehicles = set(used_vehicles[\"vehicle_id\"].to_list())\n\n    unused_vehicles = existing_vehicles - used_vehicles\n\n    if len(unused_vehicles) == 0:\n        logging.info(\"All vehicles are being used.\")\n    else:\n        logging.warning(str(len(unused_vehicles)) + \" unused vehicles have been found.\")\n\n    return unused_vehicles\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.update_vehicles","title":"<code>update_vehicles(vehicles, vehicle_types, overwrite=True)</code>","text":"<p>Updates vehicles and vehicle types.</p> PARAMETER DESCRIPTION <code>vehicles</code> <p>vehicles to add.</p> <p> TYPE: <code>dict</code> </p> <code>vehicle_types</code> <p>vehicle types to add.</p> <p> TYPE: <code>dict</code> </p> <code>overwrite</code> <p>If True: overwrites overlapping vehicle types data currently in the Schedule, adds vehicles as they are,     overwriting in case of clash If False: adds vehicles and vehicle types that do not clash with those already stored in the Schedule. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>tuple[set, set]</code> <p>tuple[set, set]: Any clashing 1. vehicles and 2. vehicle types.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def update_vehicles(\n    self, vehicles: dict, vehicle_types: dict, overwrite: bool = True\n) -&gt; tuple[set, set]:\n    \"\"\"Updates vehicles and vehicle types.\n\n    Args:\n        vehicles (dict): vehicles to add.\n        vehicle_types (dict): vehicle types to add.\n        overwrite (bool, optional):\n            If True: overwrites overlapping vehicle types data currently in the Schedule, adds vehicles as they are,\n                overwriting in case of clash\n            If False: adds vehicles and vehicle types that do not clash with those already stored in the Schedule.\n            Defaults to True.\n\n    Returns:\n        tuple[set, set]: Any clashing 1. vehicles and 2. vehicle types.\n    \"\"\"\n    # check for vehicle ID overlap\n    clashing_vehicles = self.overlapping_vehicle_ids(vehicles=vehicles)\n    if clashing_vehicles:\n        logging.warning(f\"The following vehicles clash: {clashing_vehicles}\")\n        if overwrite:\n            logging.warning(\"Overwrite is on. Vehicles listed above will be overwritten.\")\n        else:\n            logging.warning(\n                \"Overwrite is off. Clashing vehicles will remain as they are. \"\n                \"All others will be added.\"\n            )\n    # check for vehicle type overlap\n    clashing_vehicle_types = self.overlapping_vehicle_types(vehicle_types=vehicle_types)\n    if clashing_vehicle_types:\n        logging.warning(f\"The following vehicle types clash: {clashing_vehicle_types}\")\n        if overwrite:\n            logging.warning(\"Overwrite is on. Vehicle types listed above will be overwritten.\")\n        else:\n            logging.warning(\n                \"Overwrite is off. Clashing vehicle types will remain as they are. \"\n                \"All others will be added.\"\n            )\n\n    if overwrite:\n        self.vehicles = {**self.vehicles, **vehicles}\n        self.vehicle_types = {**self.vehicle_types, **vehicle_types}\n    else:\n        self.vehicles = {**vehicles, **self.vehicles}\n        self.vehicle_types = {**vehicle_types, **self.vehicle_types}\n\n    self.validate_vehicle_definitions()\n    return clashing_vehicles, clashing_vehicle_types\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.validate_vehicle_definitions","title":"<code>validate_vehicle_definitions()</code>","text":"<p>Checks if modes mapped to vehicle IDs in vehicles attribute of Schedule are defined in the vehicle_types.</p> RETURNS DESCRIPTION <code>bool</code> <p>Returns True if the vehicle types in the <code>vehicles</code> attribute exist in the <code>vehicle_types</code> attribute. But useful even just for the logging messages.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def validate_vehicle_definitions(self) -&gt; bool:\n    \"\"\"Checks if modes mapped to vehicle IDs in vehicles attribute of Schedule are defined in the vehicle_types.\n\n    Returns:\n        bool:\n            Returns True if the vehicle types in the `vehicles` attribute exist in the `vehicle_types` attribute.\n            But useful even just for the logging messages.\n    \"\"\"\n\n    missing_vehicle_information = self.get_missing_vehicle_information()\n    missing_vehicles = len(missing_vehicle_information[\"missing_vehicle_types\"])\n\n    if missing_vehicles == 0:\n        return True\n    else:\n        logging.warning(\n            \"The following vehicle types are missing from the `vehicle_types` \" + \" attribute: \"\n            f'{missing_vehicle_information[\"missing_vehicle_types\"]}'\n        )\n        logging.warning(\n            \"Vehicles affected by missing vehicle\"\n            \" types: \"\n            f\"{missing_vehicle_information['vehicles_affected']}\"\n        )\n        return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.validity_of_services","title":"<code>validity_of_services()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def validity_of_services(self):\n    return [service.is_valid_service() for service in self.services()]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.write_extras","title":"<code>write_extras(output_dir)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def write_extras(self, output_dir):\n    self.change_log().export(os.path.join(output_dir, \"schedule_change_log.csv\"))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.write_spatial","title":"<code>write_spatial(output_dir, epsg=None, filetype='parquet')</code>","text":"<p>Transforms Schedule (if applicable) to geopandas.GeoDataFrame of nodes and links and saves to the requested file format.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Path to folder where to save the file.</p> <p> TYPE: <code>str</code> </p> <code>epsg</code> <p>Projection if the geometry is to be reprojected. Defaults to None (no reprojection).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>filetype</code> <p>The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported. Defaults to parquet format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parquet'</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def write_spatial(self, output_dir, epsg: Optional[str] = None, filetype: str = \"parquet\"):\n    \"\"\"Transforms Schedule (if applicable) to geopandas.GeoDataFrame of nodes and links and saves to\n    the requested file format.\n\n    Args:\n        output_dir (str):\n            Path to folder where to save the file.\n        epsg (Optional[str], optional):\n            Projection if the geometry is to be reprojected. Defaults to None (no reprojection).\n        filetype (str, optional):\n            The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported.\n            Defaults to parquet format.\n    \"\"\"\n    if filetype.lower() not in genet.utils.io.SUPPORTED_FILE_FORMATS:\n        raise RuntimeError(\n            \"You've requested to save Schedule as a GeoDataFrame but did not select any of the \"\n            f\"file formats available: {', '.join(genet.utils.io.SUPPORTED_FILE_FORMATS)}\"\n        )\n\n    persistence.ensure_dir(output_dir)\n    _gdfs = self.to_geodataframe()\n    if epsg is not None:\n        _gdfs[\"nodes\"] = _gdfs[\"nodes\"].to_crs(epsg)\n        _gdfs[\"links\"] = _gdfs[\"links\"].to_crs(epsg)\n    logging.info(f\"Saving Schedule in {output_dir}\")\n    for gdf, filename in (\n        (_gdfs[\"nodes\"], \"schedule_nodes\"),\n        (_gdfs[\"links\"], \"schedule_links\"),\n        (_gdfs[\"nodes\"][\"geometry\"], \"schedule_nodes_geometry_only\"),\n        (_gdfs[\"links\"][\"geometry\"], \"schedule_links_geometry_only\"),\n    ):\n        genet.utils.io.save_geodataframe(gdf, filename, output_dir, filetype=filetype)\n    self.write_extras(output_dir)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.write_to_csv","title":"<code>write_to_csv(output_dir, gtfs_day='19700101', file_extention='csv')</code>","text":"<p>Writes 'stops', 'routes', 'trips', 'stop_times', 'calendar' tables to CSV files.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>folder to output csv or txt files.</p> <p> TYPE: <code>str</code> </p> <code>gtfs_day</code> <p>day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> <code>file_extention</code> <p>File extension to save to. Defaults to \"csv\".</p> <p> TYPE: <code>Literal[csv, txt]</code> DEFAULT: <code>'csv'</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def write_to_csv(\n    self,\n    output_dir: str,\n    gtfs_day: str = \"19700101\",\n    file_extention: Literal[\"csv\", \"txt\"] = \"csv\",\n):\n    \"\"\"Writes 'stops', 'routes', 'trips', 'stop_times', 'calendar' tables to CSV files.\n\n    Args:\n        output_dir (str): folder to output csv or txt files.\n        gtfs_day (str, optional): day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".\n        file_extention (Literal[csv, txt], optional): File extension to save to. Defaults to \"csv\".\n    \"\"\"\n    persistence.ensure_dir(output_dir)\n    logging.info(f\"Saving Schedule to GTFS {file_extention} in {output_dir}\")\n    for table, df in self.to_gtfs(gtfs_day).items():\n        file_path = os.path.join(output_dir, f\"{table}.{file_extention}\")\n        logging.info(f\"Saving {file_path}\")\n        df.to_csv(file_path)\n    self.write_extras(output_dir)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.write_to_gtfs","title":"<code>write_to_gtfs(output_dir, gtfs_day='19700101')</code>","text":"<p>Writes 'stops', 'routes', 'trips', 'stop_times', 'calendar' tables to CSV files.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>folder to output csv or txt files.</p> <p> TYPE: <code>str</code> </p> <code>gtfs_day</code> <p>day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def write_to_gtfs(self, output_dir: str, gtfs_day: str = \"19700101\"):\n    \"\"\"Writes 'stops', 'routes', 'trips', 'stop_times', 'calendar' tables to CSV files.\n\n    Args:\n        output_dir (str): folder to output csv or txt files.\n        gtfs_day (str, optional): day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".\n    \"\"\"\n    self.write_to_csv(output_dir, gtfs_day=gtfs_day, file_extention=\"txt\")\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.write_to_json","title":"<code>write_to_json(output_dir)</code>","text":"<p>Writes Schedule to a single JSON file with stops, services, vehicles and minimum transfer times (if applicable)</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>output directory.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def write_to_json(self, output_dir: str):\n    \"\"\"Writes Schedule to a single JSON file with stops, services, vehicles and minimum transfer times (if applicable)\n\n    Args:\n        output_dir (str): output directory.\n    \"\"\"\n    persistence.ensure_dir(output_dir)\n    logging.info(f\"Saving Schedule to JSON in {output_dir}\")\n    with open(os.path.join(output_dir, \"schedule.json\"), \"w\") as outfile:\n        json.dump(self.to_json(), outfile)\n    self.write_extras(output_dir)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Schedule.write_to_matsim","title":"<code>write_to_matsim(output_dir, reproj_processes=1)</code>","text":"<p>Save to MATSim XML format.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>path to output directory.</p> <p> TYPE: <code>str</code> </p> <code>reproj_processes</code> <p>You can set this in case you have a lot of stops and your stops need to be reprojected. It splits the process across given number of processes. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def write_to_matsim(self, output_dir: str, reproj_processes: int = 1):\n    \"\"\"Save to MATSim XML format.\n\n    Args:\n        output_dir (str): path to output directory.\n        reproj_processes (int, optional):\n            You can set this in case you have a lot of stops and your stops need to be reprojected.\n            It splits the process across given number of processes.\n            Defaults to 1.\n    \"\"\"\n    persistence.ensure_dir(output_dir)\n    matsim_xml_writer.write_matsim_schedule(output_dir, self, reproj_processes=reproj_processes)\n    matsim_xml_writer.write_vehicles(output_dir, self.vehicles, self.vehicle_types)\n    self.write_extras(output_dir)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement","title":"<code>ScheduleElement()</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for Route, Service and Schedule</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def __init__(self):\n    self._graph: nx.DiGraph\n    # check if in graph first\n    if \"crs\" in self._graph.graph:\n        self.epsg = self._graph.graph[\"crs\"]\n    else:\n        self.epsg = self.find_epsg()\n        self._graph.graph[\"crs\"] = self.epsg\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.epsg","title":"<code>epsg = self._graph.graph['crs']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.add_additional_attributes","title":"<code>add_additional_attributes(attribs)</code>","text":"<p>Adds attributes defined by keys of the attribs dictionary with values of the corresponding values.</p> PARAMETER DESCRIPTION <code>attribs</code> <p>The additional attributes <code>{attribute_name: attribute_value}</code></p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def add_additional_attributes(self, attribs: dict):\n    \"\"\"Adds attributes defined by keys of the attribs dictionary with values of the corresponding values.\n\n    Args:\n        attribs (dict): The additional attributes `{attribute_name: attribute_value}`\n    \"\"\"\n    for k, v in attribs.items():\n        if k not in self.__dict__:\n            setattr(self, k, v)\n            if \"_graph\" in self.__dict__:\n                self._add_additional_attribute_to_graph(k, v)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.average_route_speeds","title":"<code>average_route_speeds(network_factor=1.3)</code>","text":"<p>Average speed for each route in object.</p> PARAMETER DESCRIPTION <code>network_factor</code> <p>Does not consider network routes, network factor is applied to Euclidean distance. Defaults to 1.3.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.3</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary <code>{route_ID: average_speed_in_m_per_s}</code></p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def average_route_speeds(self, network_factor: float = 1.3) -&gt; dict:\n    \"\"\"Average speed for each route in object.\n\n    Args:\n        network_factor (float, optional): Does not consider network routes, network factor is applied to Euclidean distance. Defaults to 1.3.\n\n    Returns:\n        dict: Dictionary `{route_ID: average_speed_in_m_per_s}`\n    \"\"\"\n    df = self.speed_geodataframe(network_factor=network_factor)\n    # computing with all trips is redundant as the speeds for each trip for the same route are the same we can\n    # select the first or random trip from each route, but depending on how it's done, it might not improve\n    # performance very much\n    return df.groupby(\"route_id\")[\"speed\"].mean().to_dict()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.change_log","title":"<code>change_log()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def change_log(self):\n    return change_log.ChangeLog(df=self._graph.graph[\"change_log\"])\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.find_epsg","title":"<code>find_epsg()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def find_epsg(self):\n    if \"crs\" in self._graph.graph:\n        return self._graph.graph[\"crs\"]\n    else:\n        epsg = list(\n            {d for k, d in dict(self._graph.nodes(data=\"epsg\", default=\"\")).items()} - {\"\"}\n        )\n        if epsg:\n            if len(epsg) == 1:\n                return epsg[0]\n            else:\n                return epsg\n    return None\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.graph","title":"<code>graph()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def graph(self):\n    return nx.DiGraph(nx.edge_subgraph(self._graph, self.reference_edges()))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.has_attrib","title":"<code>has_attrib(attrib_name)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_attrib(self, attrib_name):\n    return attrib_name in self.__dict__\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.has_uniformly_projected_stops","title":"<code>has_uniformly_projected_stops()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_uniformly_projected_stops(self):\n    return bool(len(self.unique_stop_projections()) == 1)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.headway_stats","title":"<code>headway_stats(from_time=None, to_time=None, gtfs_day='19700101')</code>","text":"<p>Generates a DataFrame calculating mean headway in minutes for all routes, with their service ID. This can also be done for a specific time frame by specifying from_time and to_time (or just one of them).</p> PARAMETER DESCRIPTION <code>from_time</code> <p>\"HH:MM:SS\" format, used as lower time bound for subsetting. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_time</code> <p>\"HH:MM:SS\" format, used as upper time bound for subsetting. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>gtfs_day</code> <p>day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Headway stats.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def headway_stats(\n    self,\n    from_time: Optional[str] = None,\n    to_time: Optional[str] = None,\n    gtfs_day: str = \"19700101\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generates a DataFrame calculating mean headway in minutes for all routes, with their service ID.\n    This can also be done for a specific time frame by specifying from_time and to_time (or just one of them).\n\n    Args:\n        from_time (Optional[str], optional): \"HH:MM:SS\" format, used as lower time bound for subsetting. Defaults to None.\n        to_time (Optional[str], optional): \"HH:MM:SS\" format, used as upper time bound for subsetting. Defaults to None.\n        gtfs_day (str, optional): day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".\n\n    Returns:\n        pd.DataFrame: Headway stats.\n    \"\"\"\n    df = self.trips_headways(from_time=from_time, to_time=to_time, gtfs_day=gtfs_day)\n\n    groupby_cols = []\n    if \"service_id\" in df.columns:\n        groupby_cols.append(\"service_id\")\n    groupby_cols += [\"route_id\", \"mode\"]\n\n    # first trips don't have a headway, they are kept as NaT and NaN\n    if not df.empty:\n        route_groups = df.groupby(by=groupby_cols)\n        df = route_groups.describe()\n        df = df[\"headway_mins\"][[\"mean\", \"std\", \"max\", \"min\"]]\n        df[\"trip_count\"] = route_groups.apply(len)\n        df.reset_index(inplace=True)\n        df = df.rename(\n            columns={\n                \"mean\": \"mean_headway_mins\",\n                \"std\": \"std_headway_mins\",\n                \"max\": \"max_headway_mins\",\n                \"min\": \"min_headway_mins\",\n            }\n        )\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.kepler_map","title":"<code>kepler_map(output_dir='', file_name='kepler_map', data=False)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def kepler_map(self, output_dir=\"\", file_name=\"kepler_map\", data=False):\n    gdf = self.to_geodataframe()\n    if data is not True:\n        gdf[\"links\"] = sanitiser._subset_plot_gdf(\n            data, gdf[\"links\"], base_keys={\"u\", \"v\", \"geometry\"}\n        )\n        gdf[\"nodes\"] = sanitiser._subset_plot_gdf(\n            data, gdf[\"nodes\"], base_keys={\"id\", \"lat\", \"lon\"}\n        )\n\n    m = plot.plot_geodataframes_on_kepler_map(\n        {\n            \"schedule_links\": sanitiser.sanitise_geodataframe(gdf[\"links\"]),\n            \"schedule_stops\": sanitiser.sanitise_geodataframe(gdf[\"nodes\"]),\n        },\n        kepler_config=\"schedule\",\n    )\n    if output_dir:\n        persistence.ensure_dir(output_dir)\n        m.save_to_html(file_name=os.path.join(output_dir, f\"{file_name}.html\"))\n    return m\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.mode_graph_map","title":"<code>mode_graph_map()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def mode_graph_map(self):\n    mode_map = {mode: set() for mode in self.modes()}\n    for route in self.routes():\n        mode_map[route.mode] = mode_map[route.mode] | {\n            (u, v) for u, v in route.reference_edges()\n        }\n    return mode_map\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.modes","title":"<code>modes()</code>  <code>abstractmethod</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef modes(self):\n    pass\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.plot","title":"<code>plot(output_dir='', data=False)</code>  <code>abstractmethod</code>","text":"<p>Plots the schedule element on a kepler map.</p> <p>Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Output directory for the image, if passed, will save plot to html. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>data</code> <p>If False, only the geometry and ID will be visible. If True, will visualise all data on the map (not suitable for large networks) If a set of keys e.g. {'name'}, will visualise those keys. Defaults to False.</p> <p> TYPE: <code>Union[bool, set]</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>KeplerGl</code> <p>Kepler plot object</p> <p> TYPE: <code>KeplerGl</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef plot(self, output_dir: str = \"\", data: Union[bool, set] = False) -&gt; KeplerGl:\n    \"\"\"Plots the schedule element on a kepler map.\n\n    Ensure all prerequisites are installed https://docs.kepler.gl/docs/keplergl-jupyter#install.\n\n    Args:\n        output_dir (str, optional): Output directory for the image, if passed, will save plot to html. Defaults to \"\".\n        data (Union[bool, set], optional):\n            If False, only the geometry and ID will be visible.\n            If True, will visualise all data on the map (not suitable for large networks)\n            If a set of keys e.g. {'name'}, will visualise those keys.\n            Defaults to False.\n\n    Returns:\n        KeplerGl: Kepler plot object\n    \"\"\"\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.reference_edges","title":"<code>reference_edges()</code>  <code>abstractmethod</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef reference_edges(self):\n    pass\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.reference_nodes","title":"<code>reference_nodes()</code>  <code>abstractmethod</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef reference_nodes(self):\n    pass\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.reproject","title":"<code>reproject(new_epsg, processes=1)</code>","text":"<p>Changes projection of the element to <code>new_epsg</code>.</p> PARAMETER DESCRIPTION <code>new_epsg</code> <p>New projection, e.g., \"epsg:1234\".</p> <p> TYPE: <code>str</code> </p> <code>processes</code> <p>Number of parallel processes to use when reprojecting. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reproject(self, new_epsg: str, processes: int = 1):\n    \"\"\"Changes projection of the element to `new_epsg`.\n\n    Args:\n        new_epsg (str):\n            New projection, e.g., \"epsg:1234\".\n        processes (int, optional):\n            Number of parallel processes to use when reprojecting. Defaults to 1.\n    \"\"\"\n    if not self.stops_have_this_projection(new_epsg):\n        g = self.graph()\n        reprojected_node_attribs = parallel.multiprocess_wrap(\n            data=dict(g.nodes(data=True)),\n            split=parallel.split_dict,\n            apply=mod_schedule.reproj_stops,\n            combine=parallel.combine_dict,\n            processes=processes,\n            new_epsg=new_epsg,\n        )\n        nx.set_node_attributes(self._graph, reprojected_node_attribs)\n        self.epsg = new_epsg\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.route","title":"<code>route(route_id)</code>  <code>abstractmethod</code>","text":"<p>Attempting to extract route from route given an id should yield itself unless index doesn't match.</p> PARAMETER DESCRIPTION <code>route_id</code> <p>ID to extract.</p> <p> TYPE: <code>Union[str, int]</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>ID must match self ID.</p> RETURNS DESCRIPTION <code>Route</code> <p>This route.</p> <p> TYPE: <code>Route</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef route(self, route_id: Union[str, int]) -&gt; \"Route\":\n    \"\"\"Attempting to extract route from route given an id should yield itself unless index doesn't match.\n\n    Args:\n        route_id (Union[str, int]): ID to extract.\n\n    Raises:\n        IndexError: ID must match self ID.\n\n    Returns:\n        Route: This route.\n    \"\"\"\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.route_attribute_data","title":"<code>route_attribute_data(keys, index_name=None)</code>  <code>abstractmethod</code>","text":"<p>Generates a pandas.DataFrame object indexed by Route IDs, with attribute data stored for Routes under <code>key</code>.</p> PARAMETER DESCRIPTION <code>keys</code> <p>List of either a string e.g. 'name', or if accessing nested information, a dictionary. E.g. <code>{'attributes': {'osm:way:name': 'text'}}</code>.</p> <p> TYPE: <code>Union[list, str]</code> </p> <code>index_name</code> <p>gives the index_name to dataframes index. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <p>Returns:     pd.DataFrame: Route attribute data</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef route_attribute_data(self, keys: Union[list, str], index_name: Optional[str] = None):\n    \"\"\"Generates a pandas.DataFrame object indexed by Route IDs, with attribute data stored for Routes under `key`.\n\n    Args:\n        keys (Union[list, str]):\n            List of either a string e.g. 'name', or if accessing nested information, a dictionary.\n            E.g. `{'attributes': {'osm:way:name': 'text'}}`.\n        index_name (Optional[str], optional): gives the index_name to dataframes index. Defaults to None.\n    Returns:\n        pd.DataFrame: Route attribute data\n    \"\"\"\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.route_reference_edges","title":"<code>route_reference_edges(route_id)</code>","text":"<p>Method to extract edges for a route straight from the graph.</p> <p>Equivalent to route_object.reference_edges() but faster if used from a higher order object like Service or Schedule.</p> PARAMETER DESCRIPTION <code>route_id</code> <p>Route in graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> RETURNS DESCRIPTION <code>set</code> <p>graph edges for the route with ID: route_id</p> <p> TYPE: <code>set</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_reference_edges(self, route_id: Union[str, int]) -&gt; set:\n    \"\"\"Method to extract edges for a route straight from the graph.\n\n    Equivalent to route_object.reference_edges() but faster if used from a higher order object like Service or Schedule.\n\n    Args:\n        route_id (Union[str, int]): Route in graph.\n\n    Returns:\n        set: graph edges for the route with ID: route_id\n    \"\"\"\n    return {\n        (u, v)\n        for u, v, edge_routes in self._graph.edges(data=\"routes\")\n        if route_id in edge_routes\n    }\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.route_reference_nodes","title":"<code>route_reference_nodes(route_id)</code>","text":"<p>Method to extract nodes for a route straight from the graph.</p> <p>Equivalent to route_object.reference_nodes() but faster if used from a higher order object like Service or Schedule.</p> PARAMETER DESCRIPTION <code>route_id</code> <p>Route in graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> RETURNS DESCRIPTION <code>set</code> <p>graph nodes for the route with ID: route_id - not ordered</p> <p> TYPE: <code>set</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_reference_nodes(self, route_id: Union[str, int]) -&gt; set:\n    \"\"\"Method to extract nodes for a route straight from the graph.\n\n    Equivalent to route_object.reference_nodes() but faster if used from a higher order object like Service or Schedule.\n\n    Args:\n        route_id (Union[str, int]): Route in graph.\n\n    Returns:\n        set: graph nodes for the route with ID: route_id - not ordered\n    \"\"\"\n    return {\n        node\n        for node, node_routes in self._graph.nodes(data=\"routes\")\n        if route_id in node_routes\n    }\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.route_trips_to_dataframe","title":"<code>route_trips_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_trips_to_dataframe(self, gtfs_day=\"19700101\"):\n    logging.warning(\n        \"`route_trips_to_dataframe` method is deprecated and will be replaced by `trips_to_dataframe`\"\n        \"in later versions.\"\n    )\n    return self.trips_to_dataframe(gtfs_day)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.route_trips_with_stops_to_dataframe","title":"<code>route_trips_with_stops_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_trips_with_stops_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    logging.warning(\n        \"`route_trips_with_stops_to_dataframe` method is deprecated and will be replaced by \"\n        \"`trips_to_dataframe` in later versions.\"\n    )\n    return self.trips_with_stops_to_dataframe(gtfs_day)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.routes","title":"<code>routes()</code>  <code>abstractmethod</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef routes(self):\n    pass\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.service_attribute_data","title":"<code>service_attribute_data(keys, index_name=None)</code>  <code>abstractmethod</code>","text":"<p>Generates a pandas.DataFrame object indexed by Service IDs, with attribute data stored for Services under <code>key</code>.</p> PARAMETER DESCRIPTION <code>keys</code> <p>List of either a string e.g. 'name', or if accessing nested information, a dictionary. E.g. <code>{'attributes': {'osm:way:name': 'text'}}</code>.</p> <p> TYPE: <code>Union[list, str]</code> </p> <code>index_name</code> <p>gives the index_name to dataframes index. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <p>Returns:     pd.DataFrame: Service attribute data</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef service_attribute_data(\n    self, keys: Union[list, str], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"Generates a pandas.DataFrame object indexed by Service IDs, with attribute data stored for Services under `key`.\n\n    Args:\n        keys (Union[list, str]):\n            List of either a string e.g. 'name', or if accessing nested information, a dictionary.\n            E.g. `{'attributes': {'osm:way:name': 'text'}}`.\n        index_name (Optional[str], optional): gives the index_name to dataframes index. Defaults to None.\n    Returns:\n        pd.DataFrame: Service attribute data\n    \"\"\"\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.service_reference_edges","title":"<code>service_reference_edges(service_id)</code>","text":"<p>Method to extract nodes for a service straight from the graph</p> <p>Equivalent to service_object.reference_edges() but faster if used from a higher order object: Schedule.</p> PARAMETER DESCRIPTION <code>service_id</code> <p>Service in graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> RETURNS DESCRIPTION <code>set</code> <p>graph edges for the service with ID: service_id</p> <p> TYPE: <code>set</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_reference_edges(self, service_id: Union[str, int]) -&gt; set:\n    \"\"\"Method to extract nodes for a service straight from the graph\n\n    Equivalent to service_object.reference_edges() but faster if used from a higher order object: Schedule.\n\n    Args:\n        service_id (Union[str, int]): Service in graph.\n\n    Returns:\n        set: graph edges for the service with ID: service_id\n\n    \"\"\"\n    return {\n        (u, v)\n        for u, v, edge_services in self._graph.edges(data=\"services\")\n        if service_id in edge_services\n    }\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.service_reference_nodes","title":"<code>service_reference_nodes(service_id)</code>","text":"<p>Method to extract nodes for a service straight from the graph.</p> <p>Equivalent to service_object.reference_nodes() but faster if used from a higher order object: Schedule.</p> PARAMETER DESCRIPTION <code>service_id</code> <p>Service in graph.</p> <p> TYPE: <code>Union[str, int]</code> </p> RETURNS DESCRIPTION <code>set</code> <p>graph nodes for the service with ID: service_id - not ordered.</p> <p> TYPE: <code>set</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_reference_nodes(self, service_id: Union[str, int]) -&gt; set:\n    \"\"\"Method to extract nodes for a service straight from the graph.\n\n    Equivalent to service_object.reference_nodes() but faster if used from a higher order object: Schedule.\n\n    Args:\n        service_id (Union[str, int]): Service in graph.\n\n    Returns:\n        set: graph nodes for the service with ID: service_id - not ordered.\n    \"\"\"\n    return {\n        node\n        for node, node_services in self._graph.nodes(data=\"services\")\n        if service_id in node_services\n    }\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.speed_geodataframe","title":"<code>speed_geodataframe(network_factor=1.3, gdf_network_links=None)</code>","text":"<p>DataFrame of speed for PT routes, in metres/second for each stop pair.</p> <p>Note</p> <ul> <li>The unit of metres is not guaranteed - this assumes the object is in local metre-based projection.</li> <li>If you pass a GeoDataFrame of genet.Network links you will get routed speeds as well as teleported with a factor</li> <li>Assumes genet.Network links geometry if passed. If not, gives the stop-to-stop line geometry</li> </ul> PARAMETER DESCRIPTION <code>network_factor</code> <p>Network factor to be applied to the Euclidean distance between stops. Defaults to 1.3.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.3</code> </p> <code>gdf_network_links</code> <p>GeoDataFrame of genet.Network links, can be obtained using: <code>genet.Network.to_geodataframe()['links']</code>. Defaults to None.</p> <p> TYPE: <code>Optional[GeoDataFrame]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: Speeds for public transport routes.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def speed_geodataframe(\n    self, network_factor: float = 1.3, gdf_network_links: Optional[gpd.GeoDataFrame] = None\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"DataFrame of speed for PT routes, in metres/second for each stop pair.\n\n    !!! note\n        - The unit of metres is not guaranteed - this assumes the object is in local metre-based projection.\n        - If you pass a GeoDataFrame of genet.Network links you will get routed speeds as well as teleported with a factor\n        - Assumes genet.Network links geometry if passed. If not, gives the stop-to-stop line geometry\n\n    Args:\n        network_factor (float, optional): Network factor to be applied to the Euclidean distance between stops. Defaults to 1.3.\n        gdf_network_links (Optional[gpd.GeoDataFrame], optional):\n            GeoDataFrame of genet.Network links, can be obtained using: `genet.Network.to_geodataframe()['links']`.\n            Defaults to None.\n\n    Returns:\n        gpd.GeoDataFrame: Speeds for public transport routes.\n    \"\"\"\n    df = self.trips_with_stops_to_dataframe()\n    df[\"time\"] = (df[\"arrival_time\"] - df[\"departure_time\"]).dt.total_seconds()\n    df = df[\n        [\n            \"service_id\",\n            \"service_name\",\n            \"route_id\",\n            \"route_name\",\n            \"mode\",\n            \"from_stop\",\n            \"to_stop\",\n            \"from_stop_name\",\n            \"to_stop_name\",\n            \"time\",\n        ]\n    ].drop_duplicates()\n    df[\"distance\"] = (\n        df.apply(\n            lambda row: spatial.distance_between_s2cellids(\n                self._graph.nodes[row[\"from_stop\"]][\"s2_id\"],\n                self._graph.nodes[row[\"to_stop\"]][\"s2_id\"],\n            ),\n            axis=1,\n        )\n        * network_factor\n    )\n    df[\"speed\"] = df[\"distance\"] / df[\"time\"]\n    if gdf_network_links is not None:\n        network_distance_df = use_schedule.network_routed_distance_gdf(self, gdf_network_links)\n        df = gpd.GeoDataFrame(\n            df.merge(\n                network_distance_df,\n                left_on=[\"route_id\", \"from_stop\", \"to_stop\"],\n                right_on=[\"id\", \"from_stop\", \"to_stop\"],\n            )\n        )\n        df[\"routed_speed\"] = df[\"network_distance\"] / df[\"time\"]\n    else:\n        df[\"network_distance\"] = float(\"nan\")\n        df[\"routed_speed\"] = float(\"nan\")\n        schedule_links = self.to_geodataframe()[\"links\"]\n        df = gpd.GeoDataFrame(\n            pd.merge(\n                df,\n                schedule_links[[\"u\", \"v\", \"geometry\"]],\n                left_on=[\"from_stop\", \"to_stop\"],\n                right_on=[\"u\", \"v\"],\n            ),\n            crs=schedule_links.crs,\n        )\n        df.drop([\"u\", \"v\"], axis=1, inplace=True)\n    return df.drop([\"time\", \"distance\", \"network_distance\"], axis=1)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.stop","title":"<code>stop(stop_id)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stop(self, stop_id):\n    stop_data = {\n        k: v\n        for k, v in dict(self._graph.nodes[stop_id]).items()\n        if k not in {\"routes\", \"services\"}\n    }\n    return Stop(**stop_data)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.stop_attribute_data","title":"<code>stop_attribute_data(keys, index_name=None)</code>  <code>abstractmethod</code>","text":"<p>Generates a pandas.DataFrame object indexed by Stop IDs, with attribute data stored for Stops under <code>key</code>.</p> PARAMETER DESCRIPTION <code>keys</code> <p>List of either a string e.g. 'name', or if accessing nested information, a dictionary. E.g. <code>{'attributes': {'osm:way:name': 'text'}}</code>.</p> <p> TYPE: <code>Union[list, str]</code> </p> <code>index_name</code> <p>gives the index_name to dataframes index. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <p>Returns:     pd.DataFrame: Stop attribute data</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef stop_attribute_data(self, keys: Union[list, str], index_name: Optional[str] = None):\n    \"\"\"Generates a pandas.DataFrame object indexed by Stop IDs, with attribute data stored for Stops under `key`.\n\n    Args:\n        keys (Union[list, str]):\n            List of either a string e.g. 'name', or if accessing nested information, a dictionary.\n            E.g. `{'attributes': {'osm:way:name': 'text'}}`.\n        index_name (Optional[str], optional): gives the index_name to dataframes index. Defaults to None.\n    Returns:\n        pd.DataFrame: Stop attribute data\n    \"\"\"\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.stop_to_route_ids_map","title":"<code>stop_to_route_ids_map()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stop_to_route_ids_map(self):\n    return dict(self.graph().nodes(data=\"routes\"))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.stop_to_service_ids_map","title":"<code>stop_to_service_ids_map()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stop_to_service_ids_map(self):\n    return dict(self.graph().nodes(data=\"services\"))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.stops","title":"<code>stops()</code>","text":"YIELDS DESCRIPTION <code>Stop</code> <p>Iterable returns stops in the Schedule Element</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stops(self) -&gt; Iterator[\"Stop\"]:\n    \"\"\"\n    Yields:\n        Iterable returns stops in the Schedule Element\n    \"\"\"\n    for s in self.reference_nodes():\n        yield self.stop(s)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.stops_have_this_projection","title":"<code>stops_have_this_projection(epsg)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stops_have_this_projection(self, epsg):\n    return self.unique_stop_projections() == {epsg}\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.subgraph","title":"<code>subgraph(edges)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def subgraph(self, edges):\n    return nx.DiGraph(nx.edge_subgraph(self.graph(), edges))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.to_geodataframe","title":"<code>to_geodataframe()</code>","text":"<p>Generates GeoDataFrames of the Schedule graph in Schedule's crs.</p> RETURNS DESCRIPTION <code>dict[str, GeoDataFrame]</code> <p>dict[str, gpd.GeoDataFrame]: dict with keys 'nodes' and 'links', values are the GeoDataFrames corresponding to nodes and edges</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def to_geodataframe(self) -&gt; dict[str, gpd.GeoDataFrame]:\n    \"\"\"Generates GeoDataFrames of the Schedule graph in Schedule's crs.\n\n    Returns:\n        dict[str, gpd.GeoDataFrame]: dict with keys 'nodes' and 'links', values are the GeoDataFrames corresponding to nodes and edges\n    \"\"\"\n    return spatial_output.generate_geodataframes(self.graph())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.trips_headways","title":"<code>trips_headways(from_time=None, to_time=None, gtfs_day='19700101')</code>","text":"<p>Generates a DataFrame holding all the trips IDs, their departure times and vehicle IDs, next to the route ID and service ID.</p> <p>Departure times given in datetime format with given GTFS day, if specified in <code>gtfs_day</code>.</p> <p>Adds two columns: <code>headway</code> and <code>headway_mins</code> by calculating the time difference in ordered trip departures for each unique route.</p> <p>This can also be done for a specific time frame by specifying from_time and to_time (or just one of them).</p> PARAMETER DESCRIPTION <code>from_time</code> <p>\"HH:MM:SS\" format, used as lower time bound for subsetting. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>to_time</code> <p>\"HH:MM:SS\" format, used as upper time bound for subsetting. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>gtfs_day</code> <p>day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Departure and headway times.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def trips_headways(\n    self,\n    from_time: Optional[str] = None,\n    to_time: Optional[str] = None,\n    gtfs_day: str = \"19700101\",\n) -&gt; pd.DataFrame:\n    \"\"\"Generates a DataFrame holding all the trips IDs, their departure times and vehicle IDs, next to the route ID and service ID.\n\n    Departure times given in datetime format with given GTFS day, if specified in `gtfs_day`.\n\n    Adds two columns: `headway` and `headway_mins` by calculating the time difference in ordered trip departures for each unique route.\n\n    This can also be done for a specific time frame by specifying from_time and to_time (or just one of them).\n\n    Args:\n        from_time (Optional[str], optional): \"HH:MM:SS\" format, used as lower time bound for subsetting. Defaults to None.\n        to_time (Optional[str], optional): \"HH:MM:SS\" format, used as upper time bound for subsetting. Defaults to None.\n        gtfs_day (str, optional): day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".\n\n    Returns:\n        pd.DataFrame: Departure and headway times.\n    \"\"\"\n    df = (\n        self.trips_to_dataframe(gtfs_day=gtfs_day)\n        .sort_values([\"route_id\", \"trip_departure_time\"])\n        .reset_index(drop=True)\n    )\n\n    year = int(gtfs_day[:4])\n    month = int(gtfs_day[4:6])\n    day = int(gtfs_day[6:8])\n\n    df = df.groupby(\"route_id\", group_keys=False).apply(get_headway)\n    df[\"headway_mins\"] = pd.to_timedelta(df[\"headway\"]).dt.total_seconds() / 60\n\n    if from_time is not None:\n        hour, minute, second = list(map(int, from_time.split(\":\")))\n        df = df[df[\"trip_departure_time\"] &gt;= datetime(year, month, day, hour, minute, second)]\n    if to_time is not None:\n        hour, minute, second = list(map(int, to_time.split(\":\")))\n        df = df[df[\"trip_departure_time\"] &lt;= datetime(year, month, day, hour, minute, second)]\n\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.trips_to_dataframe","title":"<code>trips_to_dataframe(gtfs_day='19700101')</code>  <code>abstractmethod</code>","text":"<p>Generates a DataFrame holding all the trips IDs, their departure times (in datetime with given GTFS day, if specified in <code>gtfs_day</code>) and vehicle IDs, next to the route ID and service ID.</p> <p>Check out also <code>trips_with_stops_to_dataframe</code> for a more complex version. All trips are expanded over all of their stops, giving scheduled timestamps of each trips expected to arrive and leave the stop.</p> PARAMETER DESCRIPTION <code>gtfs_day</code> <p>day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Trips.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef trips_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    \"\"\"Generates a DataFrame holding all the trips IDs,\n    their departure times (in datetime with given GTFS day, if specified in `gtfs_day`) and vehicle IDs, next to the route ID and service ID.\n\n    Check out also `trips_with_stops_to_dataframe` for a more complex version.\n    All trips are expanded over all of their stops, giving scheduled timestamps of each trips expected to arrive and leave the stop.\n\n    Args:\n        gtfs_day (str, optional): day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".\n\n    Returns:\n        pd.DataFrame: Trips.\n    \"\"\"\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.trips_with_stops_to_dataframe","title":"<code>trips_with_stops_to_dataframe(gtfs_day='19700101')</code>  <code>abstractmethod</code>","text":"<p>Generates a DataFrame holding all the trips, their movements from stop to stop (in datetime with given GTFS day, if specified in <code>gtfs_day</code>) and vehicle IDs, next to the route ID and service ID.</p> PARAMETER DESCRIPTION <code>gtfs_day</code> <p>day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'19700101'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Trips.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>@abstractmethod\ndef trips_with_stops_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    \"\"\"Generates a DataFrame holding all the trips,\n    their movements from stop to stop (in datetime with given GTFS day, if specified in `gtfs_day`) and vehicle IDs,\n    next to the route ID and service ID.\n\n    Args:\n        gtfs_day (str, optional): day used for GTFS when creating the network in YYYYMMDD format. Defaults to \"19700101\".\n\n    Returns:\n        pd.DataFrame: Trips.\n    \"\"\"\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.ScheduleElement.unique_stop_projections","title":"<code>unique_stop_projections()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def unique_stop_projections(self):\n    return {x[1] for x in self.graph().nodes(data=\"epsg\")}\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service","title":"<code>Service(id, routes=None, name='', **kwargs)</code>","text":"<p>               Bases: <code>ScheduleElement</code></p> <p>A Service is an object containing unique routes pertaining to the same public transit service.</p> <p>Note</p> <p>Not providing some of the optional parameters may result in the object failing validation.</p> PARAMETER DESCRIPTION <code>id</code> <p>Unique identifier for the service</p> <p> TYPE: <code>str</code> </p> <code>routes</code> <p>List of Route objects, if the Routes are not uniquely indexed, they will be re-indexed. Defaults to None.</p> <p> TYPE: <code>Optional[list[Route]]</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Name for the service, if not provided, will inherit the first non-trivial name from routes. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <p>Keyword Args: Additional attributes which will be attached to the class.</p> RAISES DESCRIPTION <code>ServiceInitialisationError</code> <p><code>routes</code> must be a valid graph or a list of Route objects.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def __init__(self, id: str, routes: Optional[list[Route]] = None, name: str = \"\", **kwargs):\n    \"\"\"A Service is an object containing unique routes pertaining to the same public transit service.\n\n    !!! note\n        Not providing some of the optional parameters may result in the object failing validation.\n\n    Args:\n        id (str): Unique identifier for the service\n        routes (Optional[list[Route]], optional): List of Route objects, if the Routes are not uniquely indexed, they will be re-indexed. Defaults to None.\n        name (str, optional): Name for the service, if not provided, will inherit the first non-trivial name from routes. Defaults to \"\".\n\n    Keyword Args: Additional attributes which will be attached to the class.\n\n    Raises:\n        ServiceInitialisationError: `routes` must be a valid graph or a list of Route objects.\n    \"\"\"\n    self.id = id\n    # a service inherits a name from the first route in the list (all route names are still accessible via each\n    # route object\n    self.name = str(name)\n    _graph = None\n    if not self.name and routes:\n        for route in routes:\n            if route.route_short_name:\n                self.name = str(route.route_short_name)\n                break\n    if kwargs:\n        if \"_graph\" in kwargs:\n            _graph = kwargs.pop(\"_graph\")\n        self.add_additional_attributes(kwargs)\n\n    if _graph is not None:\n        # check graph type and schema\n        verify_graph_schema(_graph)\n        self._graph = _graph\n    elif routes is not None:\n        # re-index if not unique ids\n        self._graph = self._build_graph(self._ensure_unique_routes(routes))\n    else:\n        raise ServiceInitialisationError(\n            \"You need to pass either a valid `_graph` or a list of Route objects to `routes`\"\n        )\n    super().__init__()\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.id","title":"<code>id = id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.name","title":"<code>name = str(name)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.has_id","title":"<code>has_id()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_id(self):\n    return self.id\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.has_self_loops","title":"<code>has_self_loops()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_self_loops(self):\n    return list(nx.nodes_with_selfloops(self.graph()))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.has_valid_routes","title":"<code>has_valid_routes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_valid_routes(self):\n    return all(self.validity_of_routes())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.info","title":"<code>info()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def info(self):\n    return \"{} ID: {}\\nName: {}\\nNumber of routes: {}\\nNumber of stops: {}\".format(\n        self.__class__.__name__, self.id, self.name, len(self), len(self.reference_nodes())\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.invalid_routes","title":"<code>invalid_routes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def invalid_routes(self):\n    return [route for route in self.routes() if not route.is_valid_route()]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.is_exact","title":"<code>is_exact(other)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_exact(self, other):\n    return (self.id == other.id) and (set(self.route_ids()) == set(other.route_ids()))\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.is_strongly_connected","title":"<code>is_strongly_connected()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_strongly_connected(self):\n    if nx.number_strongly_connected_components(self.graph()) == 1:\n        return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.is_valid_service","title":"<code>is_valid_service(return_reason=False)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_valid_service(self, return_reason=False):\n    invalid_stages = []\n    valid = True\n\n    if not self.has_valid_routes():\n        valid = False\n        invalid_stages.append(\"not_has_valid_routes\")\n\n    if return_reason:\n        return valid, invalid_stages\n    return valid\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.isin_exact","title":"<code>isin_exact(services)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def isin_exact(self, services: list):\n    for other in services:\n        if self.is_exact(other):\n            return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.modes","title":"<code>modes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def modes(self):\n    return {r.mode for r in self.routes()}\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.plot","title":"<code>plot(output_dir='', data=False)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def plot(self, output_dir: str = \"\", data: Union[bool, set] = False) -&gt; KeplerGl:\n    return self.kepler_map(output_dir, f\"service_{self.id}_map\", data=data)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.print","title":"<code>print()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def print(self):\n    print(self.info())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.reference_edges","title":"<code>reference_edges()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reference_edges(self):\n    return self.service_reference_edges(self.id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.reference_nodes","title":"<code>reference_nodes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reference_nodes(self):\n    return self.service_reference_nodes(self.id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.reindex","title":"<code>reindex(new_id)</code>","text":"<p>Changes the current index of the object to <code>new_id</code>.</p> PARAMETER DESCRIPTION <code>new_id</code> <p>Desired value of the new index</p> <p> TYPE: <code>Union[str, int]</code> </p> RAISES DESCRIPTION <code>ServiceIndexError</code> <p>Cannot reindex to an existing ID.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reindex(self, new_id: Union[str, int]):\n    \"\"\"Changes the current index of the object to `new_id`.\n\n    Args:\n        new_id (Union[str, int]): Desired value of the new index\n\n    Raises:\n        ServiceIndexError: Cannot reindex to an existing ID.\n    \"\"\"\n    if not self._index_unique(new_id):\n        raise ServiceIndexError(f\"Service of index {new_id} already exists\")\n    if self.id != new_id:\n        # change data on graph\n        nodes = self.reference_nodes()\n        self._remove_services_from_nodes(nodes=nodes, service_ids={self.id})\n        self._add_services_to_nodes(nodes=nodes, service_ids={new_id})\n        edges = self.reference_edges()\n        self._remove_services_from_edges(edges=edges, service_ids={self.id})\n        self._add_services_to_edges(edges=edges, service_ids={new_id})\n        self._graph.graph[\"services\"][new_id] = self._graph.graph[\"services\"][self.id]\n        self._graph.graph[\"services\"][new_id][\"id\"] = new_id\n        del self._graph.graph[\"services\"][self.id]\n\n        # if service has routes tied to it, update the indexing\n        for r_id in self.route_ids():\n            self._graph.graph[\"route_to_service_map\"][r_id] = new_id\n        self._graph.graph[\"service_to_route_map\"][new_id] = self._graph.graph[\n            \"service_to_route_map\"\n        ][self.id]\n        del self._graph.graph[\"service_to_route_map\"][self.id]\n\n        self._graph.graph[\"change_log\"].modify(\n            object_type=\"service\",\n            old_id=self.id,\n            new_id=new_id,\n            old_attributes={\"id\": self.id},\n            new_attributes={\"id\": new_id},\n        )\n        logging.info(f\"Reindexed Service from {self.id} to {new_id}\")\n        self.id = new_id\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.route","title":"<code>route(route_id)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route(self, route_id: Union[str, int]) -&gt; \"Route\":\n    return self._get_route_from_graph(route_id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.route_attribute_data","title":"<code>route_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_attribute_data(self, keys: Union[list, str], index_name: Optional[str] = None):\n    return graph_operations.build_attribute_dataframe(\n        iterator=[(rid, self._graph.graph[\"routes\"][rid]) for rid in self.route_ids()],\n        keys=keys,\n        index_name=index_name,\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.route_ids","title":"<code>route_ids()</code>","text":"<p>Iterator for the Route IDs in the Service</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def route_ids(self):\n    \"\"\"\n    Iterator for the Route IDs in the Service\n    \"\"\"\n    for route_id in self._graph.graph[\"service_to_route_map\"][self.id]:\n        yield route_id\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.routes","title":"<code>routes()</code>","text":"<p>Iterator for the Route objects in the Service</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def routes(self):\n    \"\"\"\n    Iterator for the Route objects in the Service\n    \"\"\"\n    for route_id in self.route_ids():\n        yield self._get_route_from_graph(route_id)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.service_attribute_data","title":"<code>service_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def service_attribute_data(\n    self, keys: Union[list, str], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    return graph_operations.build_attribute_dataframe(\n        iterator=[(self.id, self.__dict__)], keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.split_by_direction","title":"<code>split_by_direction()</code>","text":"<p>Divide the routes of the Service by direction e.g. North- and South-bound.</p> <p>Depending on the mode, typically a Service will have either 1 or 2 directions. Some Services will have more, especially ones that are loops.</p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary with directions as keys and lists of routes which head in that direction as values. E.g.: <pre><code>{\n    \"North-East Bound\": ['route_1', 'route_2'],\n    \"South-West Bound\": ['route_3', 'route_4']\n}\n</code></pre></p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def split_by_direction(self) -&gt; dict:\n    \"\"\"Divide the routes of the Service by direction e.g. North- and South-bound.\n\n    Depending on the mode, typically a Service will have either 1 or 2 directions.\n    Some Services will have more, especially ones that are loops.\n\n    Returns:\n        dict:\n            Dictionary with directions as keys and lists of routes which head in that direction as values. E.g.:\n            ```python\n            {\n                \"North-East Bound\": ['route_1', 'route_2'],\n                \"South-West Bound\": ['route_3', 'route_4']\n            }\n            ```\n    \"\"\"\n    geodesic = Geod(ellps=\"WGS84\")\n    route_direction_map = {}\n    for route_id in self.route_ids():\n        ordered_stops = self._graph.graph[\"routes\"][route_id][\"ordered_stops\"]\n        start_stop = self.stop(ordered_stops[0])\n        end_stop = self.stop(ordered_stops[-1])\n        if start_stop == end_stop:\n            # just check which way it's heading\n            end_stop = self.stop(ordered_stops[1])\n        azimuth = geodesic.inv(\n            lats1=start_stop.lat, lons1=start_stop.lon, lats2=end_stop.lat, lons2=end_stop.lon\n        )[0]\n        route_direction_map[route_id] = spatial.map_azimuth_to_name(azimuth)\n    res = defaultdict(list)\n    for key, val in sorted(route_direction_map.items()):\n        res[val].append(key)\n    return dict(res)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.split_graph","title":"<code>split_graph()</code>","text":"<p>Divide the routes and the graph of the Service by share of Service's graph.</p> <p>Most services with have one or two outputs, but some will have more. The results of this method may vary from <code>split_by_direction</code>. The output graph edges in the list will be independent of each other (the edges will be independent, but they may share nodes), sometimes producing more than two sets.</p> <p>The method is not symmetric, if the Routes in a Service are listed in a different order this may lead to some graph groups merging (in a desired way).</p> RETURNS DESCRIPTION <code>tuple[list, list]</code> <p>tuple[list, list]: (routes, graph_groups) where: - routes is a list of sets with grouped route IDs - graph_groups is a list of the same length as routes. Each item is a set of graph edges and corresponds to the item in routes list in that same index.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def split_graph(self) -&gt; tuple[list, list]:\n    \"\"\"Divide the routes and the graph of the Service by share of Service's graph.\n\n    Most services with have one or two outputs, but some will have more.\n    The results of this method may vary from `split_by_direction`.\n    The output graph edges in the list will be independent of each other (the edges will be independent, but they may share nodes), sometimes producing more than two sets.\n\n    The method is not symmetric, if the Routes in a Service are listed in a different order this may lead to some graph groups merging (in a desired way).\n\n    Returns:\n        tuple[list, list]:\n            (routes, graph_groups) where:\n            - routes is a list of sets with grouped route IDs\n            - graph_groups is a list of the same length as routes.\n            Each item is a set of graph edges and corresponds to the item in routes list in that same index.\n    \"\"\"\n\n    def route_overlap_condition(graph_edge_group):\n        edges_in_common = bool(graph_edge_group &amp; route_edges)\n        if edges_in_common:\n            return edges_in_common\n        else:\n            from_nodes = {i[0] for i in route_edges}\n            to_nodes = {i[1] for i in route_edges}\n            shares_from_node = (from_nodes - to_nodes) &amp; {i[0] for i in graph_edge_group}\n            shares_to_node = (to_nodes - from_nodes) &amp; {i[1] for i in graph_edge_group}\n            return bool(shares_from_node) &amp; bool(shares_to_node)\n\n    def route_overlap_mask():\n        return [route_overlap_condition(graph_edge_group) for graph_edge_group in graph_edges]\n\n    def merge_multiple_overlaps():\n        merged_route_group = {route_id}\n        merged_graph_edges = route_edges\n        overlap_routes = list(itertools.compress(routes, overlap_mask))\n        overlap_graph_edges = list(itertools.compress(graph_edges, overlap_mask))\n        for r, e in zip(overlap_routes, overlap_graph_edges):\n            merged_route_group |= r\n            merged_graph_edges |= e\n            routes.remove(r)\n            graph_edges.remove(e)\n        routes.append(merged_route_group)\n        graph_edges.append(merged_graph_edges)\n\n    routes = []\n    graph_edges = []\n    for route_id in self.route_ids():\n        route_edges = set(self.route_reference_edges(route_id))\n        overlap_mask = route_overlap_mask()\n        route_overlap = sum(overlap_mask)\n        if route_overlap == 0:\n            routes.append({route_id})\n            graph_edges.append(route_edges)\n        elif route_overlap == 1:\n            for routes_group, graph_edge_group in zip(\n                list(itertools.compress(routes, overlap_mask)),\n                list(itertools.compress(graph_edges, overlap_mask)),\n            ):\n                routes_group.add(route_id)\n                graph_edge_group |= route_edges\n        else:\n            logging.warning(\n                f\"Graph of route: `{route_id}` overlaps with multiple current graph groups. This will \"\n                f\"result in merging of those groups. This is usually desirable but check results to \"\n                f\"ensure expected behaviour.\"\n            )\n            merge_multiple_overlaps()\n    return routes, graph_edges\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.stop_attribute_data","title":"<code>stop_attribute_data(keys, index_name=None)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def stop_attribute_data(self, keys: Union[list, str], index_name: Optional[str] = None):\n    return graph_operations.build_attribute_dataframe(\n        iterator=[(s.id, s.__dict__) for s in self.stops()], keys=keys, index_name=index_name\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.trips_to_dataframe","title":"<code>trips_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def trips_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    df = None\n    for route in self.routes():\n        _df = route.trips_to_dataframe(gtfs_day=gtfs_day)\n        if df is None:\n            df = _df\n        else:\n            df = pd.concat([df, _df])\n    df[\"service_id\"] = self.id\n    df = df.reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.trips_with_stops_to_dataframe","title":"<code>trips_with_stops_to_dataframe(gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def trips_with_stops_to_dataframe(self, gtfs_day: str = \"19700101\") -&gt; pd.DataFrame:\n    df = None\n    for route in self.routes():\n        _df = route.trips_with_stops_to_dataframe(gtfs_day=gtfs_day)\n        if df is None:\n            df = _df\n        else:\n            df = pd.concat([df, _df])\n    df[\"service_id\"] = self.id\n    df[\"service_name\"] = self.name.replace(\"\\\\\", \"_\").replace(\"/\", \"_\")\n    df = df.reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.validity_of_routes","title":"<code>validity_of_routes()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def validity_of_routes(self):\n    return [route.is_valid_route() for route in self.routes()]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Service.vehicles","title":"<code>vehicles()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def vehicles(self):\n    return set().union(\n        *[r_dat[\"trips\"][\"vehicle_id\"] for r_id, r_dat in self.graph().graph[\"routes\"].items()]\n    )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop","title":"<code>Stop(id, x, y, epsg, transformer=None, name='', **kwargs)</code>","text":"<p>A transit stop that features in a Route object.</p> PARAMETER DESCRIPTION <code>id</code> <p>Unique identifier.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>x</code> <p>x coordinate or lat if using 'epsg:4326'.</p> <p> TYPE: <code>Union[str, int, float]</code> </p> <code>y</code> <p>y coordinate or lon if using 'epsg:4326'.</p> <p> TYPE: <code>Union[str, int, float]</code> </p> <code>epsg</code> <p>Projection, e.g. \"epsg:4326\".</p> <p> TYPE: <code>str</code> </p> <code>transformer</code> <p>E.g., result of pyproj.Transformer.from_crs(epsg, 'epsg:4326', always_xy=True). Optional but makes things MUCH faster if you're reading through a lot of stops in the same projection,  all stops are mapped back to 'epsg:4326' and indexed with s2sphere.  Defaults to None.</p> <p> TYPE: <code>Optional[Transformer]</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>human readable name for the stop. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <p>Keyword Args: Additional attributes which will be attached to the class.</p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def __init__(\n    self,\n    id: Union[str, int],\n    x: Union[str, int, float],\n    y: Union[str, int, float],\n    epsg: str,\n    transformer: Optional[Transformer] = None,\n    name: str = \"\",\n    **kwargs,\n):\n    \"\"\"A transit stop that features in a Route object.\n\n    Args:\n        id (Union[str, int]): Unique identifier.\n        x (Union[str, int, float]): x coordinate or lat if using 'epsg:4326'.\n        y (Union[str, int, float]): y coordinate or lon if using 'epsg:4326'.\n        epsg (str): Projection, e.g. \"epsg:4326\".\n        transformer (Optional[Transformer], optional):\n            E.g., result of pyproj.Transformer.from_crs(epsg, 'epsg:4326', always_xy=True).\n            Optional but makes things MUCH faster if you're reading through a lot of stops in the same projection,\n             all stops are mapped back to 'epsg:4326' and indexed with s2sphere.\n             Defaults to None.\n        name (str, optional): human readable name for the stop. Defaults to \"\".\n\n    Keyword Args: Additional attributes which will be attached to the class.\n    \"\"\"\n    self.id = id\n    self.x = float(x)\n    self.y = float(y)\n    self.epsg = epsg\n    self.name = name\n\n    if (\"lat\" in kwargs) and (\"lon\" in kwargs):\n        self.lat, self.lon = kwargs[\"lat\"], kwargs[\"lon\"]\n    else:\n        if self.epsg == \"epsg:4326\":\n            self.lon, self.lat = float(x), float(y)\n        else:\n            if transformer is None:\n                transformer = Transformer.from_crs(self.epsg, \"epsg:4326\", always_xy=True)\n            self.lon, self.lat = spatial.change_proj(x, y, transformer)\n    if \"s2_id\" in kwargs:\n        self.s2_id = kwargs[\"s2_id\"]\n    else:\n        self.s2_id = spatial.generate_index_s2(lat=self.lat, lng=self.lon)\n\n    if kwargs:\n        self.add_additional_attributes(kwargs)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.epsg","title":"<code>epsg = epsg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.id","title":"<code>id = id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.s2_id","title":"<code>s2_id = kwargs['s2_id']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.x","title":"<code>x = float(x)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.y","title":"<code>y = float(y)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.add_additional_attributes","title":"<code>add_additional_attributes(attribs)</code>","text":"<p>Adds attributes defined by keys of the attribs dictionary with values of the corresponding values.</p> <p>Ignores keys: 'id', 'x', 'y'.</p> PARAMETER DESCRIPTION <code>attribs</code> <p>The additional attributes {attrribute_name: attribute_value}</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def add_additional_attributes(self, attribs: dict):\n    \"\"\"Adds attributes defined by keys of the attribs dictionary with values of the corresponding values.\n\n    Ignores keys: 'id', 'x', 'y'.\n\n    Args:\n        attribs (dict): The additional attributes {attrribute_name: attribute_value}\n    \"\"\"\n    for k, v in attribs.items():\n        if k not in self.__dict__ or (not self.__dict__[k]):\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.additional_attribute","title":"<code>additional_attribute(attrib_name)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def additional_attribute(self, attrib_name):\n    return self.__dict__[attrib_name]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.has_attrib","title":"<code>has_attrib(attrib_name)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_attrib(self, attrib_name):\n    return attrib_name in self.__dict__\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.has_id","title":"<code>has_id()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_id(self):\n    return self.id\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.has_linkRefId","title":"<code>has_linkRefId()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def has_linkRefId(self):\n    return \"linkRefId\" in self.__dict__\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.info","title":"<code>info()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def info(self):\n    if self.has_linkRefId():\n        return \"{} ID: {}\\nProjection: {}\\nLat, Lon: {}, {}\\nlinkRefId: {}\".format(\n            self.__class__.__name__,\n            self.id,\n            self.epsg,\n            self._round_lat(),\n            self._round_lon(),\n            self.linkRefId,\n        )\n    else:\n        return \"{} ID: {}\\nProjection: {}\\nLat, Lon: {}, {}\".format(\n            self.__class__.__name__, self.id, self.epsg, self._round_lat(), self._round_lon()\n        )\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.is_exact","title":"<code>is_exact(other)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def is_exact(self, other):\n    same_id = self.id == other.id\n    same_lat = round(self.lat, SPATIAL_TOLERANCE) == round(other.lat, SPATIAL_TOLERANCE)\n    same_lon = round(self.lon, SPATIAL_TOLERANCE) == round(other.lon, SPATIAL_TOLERANCE)\n    return same_id and same_lat and same_lon\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.isin_exact","title":"<code>isin_exact(stops)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def isin_exact(self, stops: list):\n    for other in stops:\n        if self.is_exact(other):\n            return True\n    return False\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.print","title":"<code>print()</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def print(self):\n    print(self.info())\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.Stop.reproject","title":"<code>reproject(new_epsg, transformer=None)</code>","text":"<p>Changes projection of a stop.</p> <p>If doing many stops, it's much quicker to pass the transformer as well as epsg.</p> PARAMETER DESCRIPTION <code>new_epsg</code> <p>New projection, e.g., \"epsg:1234\".</p> <p> TYPE: <code>str</code> </p> <code>transformer</code> <p>E.g., result of pyproj.Transformer.from_crs(epsg, 'epsg:4326', always_xy=True). Optional but makes things MUCH faster if you're reading through a lot of stops in the same projection,  all stops are mapped back to 'epsg:4326' and indexed with s2sphere.  Defaults to None.</p> <p> TYPE: <code>Optional[Transformer]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def reproject(self, new_epsg: str, transformer: Optional[Transformer] = None):\n    \"\"\"Changes projection of a stop.\n\n    If doing many stops, it's much quicker to pass the transformer as well as epsg.\n\n    Args:\n        new_epsg (str):\n            New projection, e.g., \"epsg:1234\".\n        transformer (Optional[Transformer], optional):\n            E.g., result of pyproj.Transformer.from_crs(epsg, 'epsg:4326', always_xy=True).\n            Optional but makes things MUCH faster if you're reading through a lot of stops in the same projection,\n             all stops are mapped back to 'epsg:4326' and indexed with s2sphere.\n             Defaults to None.\n    \"\"\"\n    if transformer is None:\n        transformer = Transformer.from_crs(self.epsg, new_epsg, always_xy=True)\n    self.x, self.y = spatial.change_proj(self.x, self.y, transformer)\n    self.epsg = new_epsg\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.generate_trip_departures_from_headway","title":"<code>generate_trip_departures_from_headway(headway_spec)</code>","text":"<p>Generates new trip departure times.</p> PARAMETER DESCRIPTION <code>headway_spec</code> <p>Dictionary with tuple keys: (from time, to time) and headway values in minutes: <code>{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}</code>.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def generate_trip_departures_from_headway(headway_spec: dict):\n    \"\"\"Generates new trip departure times.\n\n    Args:\n        headway_spec (dict):\n            Dictionary with tuple keys: (from time, to time) and headway values in minutes:\n            `{('HH:MM:SS', 'HH:MM:SS'): headway_minutes}`.\n    \"\"\"\n    trip_departures = set()\n    for (from_time, to_time), headway_mins in headway_spec.items():\n        trip_departures |= set(\n            pd.date_range(\n                f\"1970-01-01 {from_time}\", f\"1970-01-01 {to_time}\", freq=f\"{headway_mins}min\"\n            )\n        )\n    return trip_departures\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.get_headway","title":"<code>get_headway(group)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def get_headway(group):\n    group[\"headway\"] = group[\"trip_departure_time\"].diff()\n    return group\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.read_vehicle_types","title":"<code>read_vehicle_types(yml)</code>","text":"PARAMETER DESCRIPTION <code>yml</code> <p>path to .yml file based on example vehicles config in <code>genet/configs/vehicles/vehicle_definitions.yml</code>.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Vehicle type dictionary.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def read_vehicle_types(yml: str) -&gt; dict:\n    \"\"\"\n    Args:\n        yml (str): path to .yml file based on example vehicles config in `genet/configs/vehicles/vehicle_definitions.yml`.\n\n    Returns:\n        dict: Vehicle type dictionary.\n    \"\"\"\n    if persistence.is_yml(yml):\n        yml = io.open(yml, mode=\"r\")\n    return yaml.load(yml, Loader=yaml.FullLoader)[\"VEHICLE_TYPES\"]\n</code></pre>"},{"location":"reference/genet/schedule_elements/#genet.schedule_elements.verify_graph_schema","title":"<code>verify_graph_schema(graph)</code>","text":"Source code in <code>src/genet/schedule_elements.py</code> <pre><code>def verify_graph_schema(graph):\n    if not isinstance(graph, nx.DiGraph):\n        raise ScheduleElementGraphSchemaError(\n            f\"Object of type {type(graph)} passed. The graph for a schedule element needs \"\n            f\"to be a networkx.DiGraph\"\n        )\n\n    required_stop_attributes = {\"x\", \"y\", \"id\", \"epsg\"}\n    for node, node_attribs in graph.nodes(data=True):\n        if not required_stop_attributes.issubset(set(node_attribs.keys())):\n            missing_attribs = required_stop_attributes - set(node_attribs.keys())\n            raise ScheduleElementGraphSchemaError(\n                f\"Node/Stop {node} is missing the following attributes: \" f\"{missing_attribs}\"\n            )\n\n    required_route_attributes = {\n        \"arrival_offsets\",\n        \"ordered_stops\",\n        \"route_short_name\",\n        \"mode\",\n        \"departure_offsets\",\n        \"trips\",\n    }\n    if \"routes\" not in graph.graph:\n        raise ScheduleElementGraphSchemaError(\"Graph is missing `routes` attribute\")\n    else:\n        for route_id, route_dict in graph.graph[\"routes\"].items():\n            if not required_route_attributes.issubset(set(route_dict.keys())):\n                missing_attribs = required_route_attributes - set(route_dict.keys())\n                raise ScheduleElementGraphSchemaError(\n                    f\"Route {route_id} is missing the following attributes: \" f\"{missing_attribs}\"\n                )\n\n    required_service_attributes = {\"id\"}\n    if \"services\" not in graph.graph:\n        raise ScheduleElementGraphSchemaError(\"Graph is missing `services` attribute\")\n    else:\n        for service_id, service_dict in graph.graph[\"services\"].items():\n            if not required_service_attributes.issubset(set(service_dict.keys())):\n                missing_attribs = required_service_attributes - set(service_dict.keys())\n                raise ScheduleElementGraphSchemaError(\n                    f\"Service {service_id} is missing the following attributes: \"\n                    f\"{missing_attribs}\"\n                )\n</code></pre>"},{"location":"reference/genet/use/road_pricing/","title":"genet.use.road_pricing","text":""},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.Toll","title":"<code>Toll(df_tolls=None)</code>","text":"Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def __init__(self, df_tolls: pd.DataFrame = None):\n    if df_tolls is None:\n        self.df_tolls = pd.DataFrame(\n            columns=[\n                \"toll_id\",  # optional, unique ID of the toll, based off OSM ref if applicable\n                \"network_link_id\",  # network link ID to be charged\n                \"vehicle_type\",  # optional, type of vehicle, does not persist to MATSim road pricing xml file\n                \"toll_amount\",  # cost to travel on that link\n                \"start_time\",  # start time for the toll\n                \"end_time\",  # end time for the toll\n                \"osm_name\",  # optional, if derived from OSM, human readable name of the road\n                \"notes\",  # optional, user notes\n            ]\n        )\n    else:\n        self.df_tolls = df_tolls\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.Toll.df_tolls","title":"<code>df_tolls = pd.DataFrame(columns=['toll_id', 'network_link_id', 'vehicle_type', 'toll_amount', 'start_time', 'end_time', 'osm_name', 'notes'])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.Toll.write_to_csv","title":"<code>write_to_csv(output_dir, filename='road_pricing.csv')</code>","text":"<p>Exports all tolls to csv file.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Path to folder in which to save <code>filename</code>.</p> <p> TYPE: <code>str</code> </p> <code>filename</code> <p>CSV filename. Defaults to \"road_pricing.csv\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'road_pricing.csv'</code> </p> Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def write_to_csv(self, output_dir: str, filename: str = \"road_pricing.csv\"):\n    \"\"\"Exports all tolls to csv file.\n\n    Args:\n        output_dir (str): Path to folder in which to save `filename`.\n        filename (str, optional): CSV filename. Defaults to \"road_pricing.csv\".\n    \"\"\"\n    self.df_tolls.to_csv(os.path.join(output_dir, filename), index=False)\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.Toll.write_to_xml","title":"<code>write_to_xml(output_dir, filename='roadpricing-file.xml', toll_type='link', toll_scheme_name='simple-toll', toll_description='A simple toll scheme')</code>","text":"<p>Write toll to MATSim xml file.</p> PARAMETER DESCRIPTION <code>output_dir</code> <p>Path to folder in which to save <code>filename</code>.</p> <p> TYPE: <code>str</code> </p> <code>filename</code> <p>Matsim XML filename. Defaults to \"roadpricing-file.xml\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'roadpricing-file.xml'</code> </p> <code>toll_type</code> <p>Supported MATSim toll types: 'distance', 'cordon', 'area', 'link'. More info: https://www.matsim.org/apidocs/core/0.3.0/org/matsim/roadpricing/package-summary.html. Defaults to \"link\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'link'</code> </p> <code>toll_scheme_name</code> <p>Name to pass to xml file, useful for identifying multiple toll schemes. Defaults to \"simple-toll\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple-toll'</code> </p> <code>toll_description</code> <p>Additional description of the toll to pass to the xml file. Defaults to \"A simple toll scheme\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'A simple toll scheme'</code> </p> Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def write_to_xml(\n    self,\n    output_dir: str,\n    filename: str = \"roadpricing-file.xml\",\n    toll_type: str = \"link\",\n    toll_scheme_name: str = \"simple-toll\",\n    toll_description: str = \"A simple toll scheme\",\n):\n    \"\"\"Write toll to MATSim xml file.\n\n    Args:\n        output_dir (str): Path to folder in which to save `filename`.\n        filename (str, optional): Matsim XML filename. Defaults to \"roadpricing-file.xml\".\n        toll_type (str, optional):\n            Supported MATSim toll types: 'distance', 'cordon', 'area', 'link'.\n            More info: https://www.matsim.org/apidocs/core/0.3.0/org/matsim/roadpricing/package-summary.html.\n            Defaults to \"link\".\n        toll_scheme_name (str, optional):\n            Name to pass to xml file, useful for identifying multiple toll schemes.\n            Defaults to \"simple-toll\".\n        toll_description (str, optional):\n            Additional description of the toll to pass to the xml file.\n            Defaults to \"A simple toll scheme\".\n    \"\"\"\n    xml_tree = build_tree(\n        self.df_tolls,\n        toll_type=toll_type,\n        toll_scheme_name=toll_scheme_name,\n        toll_description=toll_description,\n    )\n    write_xml(xml_tree, output_dir, filename=filename)\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.build_tree","title":"<code>build_tree(df_tolls, toll_type='link', toll_scheme_name='simple-toll', toll_description='A simple toll scheme')</code>","text":"<p>Build XML config for MATSim Road Pricing from tolls DataFrame input</p> PARAMETER DESCRIPTION <code>df_tolls</code> <p>Of the form: <pre><code>pd.DataFrame(\n    columns=[\n        'toll_id',  # optional, unique ID of the toll, based off OSM ref if applicable\n        'network_link_id',  # network link ID to be charged\n        'vehicle_type',  # optional, type of vehicle, does not persist to MATSim road pricing xml file\n        'toll_amount',  # cost to travel on that link\n        'start_time',  # start time for the toll\n        'end_time',  # end time for the toll\n        'osm_name',  # optional, if derived from OSM, human readable name of the road\n        'notes'  # optional, user notes\n    ]\n)\n</code></pre></p> <p> TYPE: <code>DataFrame</code> </p> <code>toll_type</code> <p>Supported MATSim toll types: 'distance', 'cordon', 'area', 'link'. More info: https://www.matsim.org/apidocs/core/0.3.0/org/matsim/roadpricing/package-summary.html. Defaults to \"link\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'link'</code> </p> <code>toll_scheme_name</code> <p>Name to pass to xml file, useful for identifying multiple toll schemes. Defaults to \"simple-toll\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple-toll'</code> </p> <code>toll_description</code> <p>Additional description of the toll to pass to the xml file. Defaults to \"A simple toll scheme\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'A simple toll scheme'</code> </p> RETURNS DESCRIPTION <code>_Element</code> <p>XML root element.</p> <p> TYPE: <code>_Element</code> </p> Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def build_tree(\n    df_tolls: pd.DataFrame,\n    toll_type: str = \"link\",\n    toll_scheme_name: str = \"simple-toll\",\n    toll_description: str = \"A simple toll scheme\",\n) -&gt; _Element:\n    \"\"\"Build XML config for MATSim Road Pricing from tolls DataFrame input\n\n    Args:\n        df_tolls (pd.DataFrame): Of the form:\n            ```python\n            pd.DataFrame(\n                columns=[\n                    'toll_id',  # optional, unique ID of the toll, based off OSM ref if applicable\n                    'network_link_id',  # network link ID to be charged\n                    'vehicle_type',  # optional, type of vehicle, does not persist to MATSim road pricing xml file\n                    'toll_amount',  # cost to travel on that link\n                    'start_time',  # start time for the toll\n                    'end_time',  # end time for the toll\n                    'osm_name',  # optional, if derived from OSM, human readable name of the road\n                    'notes'  # optional, user notes\n                ]\n            )\n            ```\n        toll_type (str, optional):\n            Supported MATSim toll types: 'distance', 'cordon', 'area', 'link'.\n            More info: https://www.matsim.org/apidocs/core/0.3.0/org/matsim/roadpricing/package-summary.html.\n            Defaults to \"link\".\n        toll_scheme_name (str, optional):\n            Name to pass to xml file, useful for identifying multiple toll schemes.\n            Defaults to \"simple-toll\".\n        toll_description (str, optional):\n            Additional description of the toll to pass to the xml file.\n            Defaults to \"A simple toll scheme\".\n\n    Returns:\n        _Element: XML root element.\n    \"\"\"\n\n    roadpricing = Element(\"roadpricing\", type=toll_type, name=toll_scheme_name)\n    description = SubElement(roadpricing, \"description\")\n    description.text = toll_description\n\n    links = SubElement(roadpricing, \"links\")\n\n    # make sure all links from same toll are grouped together:\n    if \"toll_id\" not in df_tolls.columns:\n        # if not present just take it link by link\n        df_tolls[\"toll_id\"] = df_tolls[\"network_link_id\"]\n    df_tolls = df_tolls.sort_values(by=\"toll_id\")\n\n    # Time-of-day pricing:\n    # links with multiple tolling amounts throughout the day appear as multiple rows in the .csv config\n    # links with uniform pricing throughout the day appear only once in .csv config\n    try:\n        links_repeat = pd.concat(g for _, g in df_tolls.groupby(\"network_link_id\") if len(g) &gt; 1)\n    except ValueError:\n        links_repeat = pd.DataFrame()\n    links_no_repeat = df_tolls[~df_tolls.index.isin(links_repeat.index)]\n\n    # list to keep track of which Toll names we added as comments\n    commented_tolls = []\n\n    # links without time-of-day pricing:\n    for index, row in links_no_repeat.iterrows():\n        if str(row[\"toll_id\"]) not in commented_tolls:\n            links.append(Comment(\" === \" + str(row[\"toll_id\"]) + \" === \"))\n            commented_tolls.append(str(row[\"toll_id\"]))\n\n        link = SubElement(links, \"link\", id=str(row[\"network_link_id\"]))\n        SubElement(\n            link,\n            \"cost\",\n            start_time=str(row[\"start_time\"]),\n            end_time=str(row[\"end_time\"]),\n            amount=str(row[\"toll_amount\"]),\n        )\n\n    # links with time-of-day pricing:\n    # get unique ids of these links and iterate through them\n    if not links_repeat.empty:\n        unique_repeated_ids = links_repeat[\"network_link_id\"].unique()\n        for link_id in unique_repeated_ids:\n            link_time_of_day_df = links_repeat[links_repeat[\"network_link_id\"] == link_id]\n\n            link_ref = link_time_of_day_df[\"toll_id\"].unique()[0]\n            if link_ref not in commented_tolls:\n                links.append(Comment(\" === \" + str(link_ref) + \" === \"))\n                commented_tolls.append(str(link_ref))\n\n            link = SubElement(links, \"link\", id=str(link_id))\n            for index, row in link_time_of_day_df.iterrows():\n                SubElement(\n                    link,\n                    \"cost\",\n                    start_time=str(row[\"start_time\"]),\n                    end_time=str(row[\"end_time\"]),\n                    amount=str(row[\"toll_amount\"]),\n                )\n\n    return roadpricing\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.build_tree_from_csv_json","title":"<code>build_tree_from_csv_json(csv_input, json_input, toll_type='link', toll_scheme_name='simple-toll', toll_description='A simple toll scheme')</code>","text":"<p>Build XML config for MATSim Road Pricing from .csv and .json input.</p> PARAMETER DESCRIPTION <code>csv_input</code> <p>csv output from <code>extract_network_id_from_osm_csv</code> with additional columns: <code>vehicle_type</code>, <code>toll_amount</code>, <code>start_time</code> and <code>end_time</code> for each of the tolls required.</p> <p> TYPE: <code>str</code> </p> <code>json_input</code> <p>json output from <code>extract_network_id_from_osm_csv</code>.</p> <p> TYPE: <code>str</code> </p> <code>toll_type</code> <p>Supported MATSim toll types: 'distance', 'cordon', 'area', 'link'. More info: https://www.matsim.org/apidocs/core/0.3.0/org/matsim/roadpricing/package-summary.html. Defaults to \"link\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'link'</code> </p> <code>toll_scheme_name</code> <p>Name to pass to xml file, useful for identifying multiple toll schemes. Defaults to \"simple-toll\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple-toll'</code> </p> <code>toll_description</code> <p>Additional description of the toll to pass to the xml file. Defaults to \"A simple toll scheme\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'A simple toll scheme'</code> </p> RETURNS DESCRIPTION <code>_Element</code> <p>XML root element.</p> <p> TYPE: <code>_Element</code> </p> Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def build_tree_from_csv_json(\n    csv_input: str,\n    json_input: str,\n    toll_type: str = \"link\",\n    toll_scheme_name: str = \"simple-toll\",\n    toll_description: str = \"A simple toll scheme\",\n) -&gt; _Element:\n    \"\"\"Build XML config for MATSim Road Pricing from .csv and .json input.\n\n    Args:\n        csv_input (str):\n            csv output from `extract_network_id_from_osm_csv` with additional columns: `vehicle_type`, `toll_amount`, `start_time` and `end_time` for each of the tolls required.\n        json_input (str): json output from `extract_network_id_from_osm_csv`.\n        toll_type (str, optional):\n            Supported MATSim toll types: 'distance', 'cordon', 'area', 'link'.\n            More info: https://www.matsim.org/apidocs/core/0.3.0/org/matsim/roadpricing/package-summary.html.\n            Defaults to \"link\".\n        toll_scheme_name (str, optional):\n            Name to pass to xml file, useful for identifying multiple toll schemes.\n            Defaults to \"simple-toll\".\n        toll_description (str, optional):\n            Additional description of the toll to pass to the xml file.\n            Defaults to \"A simple toll scheme\".\n\n    Returns:\n        _Element: XML root element.\n    \"\"\"\n\n    # CSV input\n    osm_df = pd.read_csv(csv_input, dtype={\"osm_id\": str})\n    # JSON input\n    with open(json_input, \"r\") as f:\n        osm_to_network_dict = json.load(f)\n    return build_tree(\n        merge_osm_tolls_and_network_snapping(osm_df, osm_to_network_dict),\n        toll_type=toll_type,\n        toll_scheme_name=toll_scheme_name,\n        toll_description=toll_description,\n    )\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.extract_network_id_from_osm_csv","title":"<code>extract_network_id_from_osm_csv(network, attribute_name, osm_csv_path, outpath, osm_dtype=str)</code>","text":"<p>Parse a genet.Network object and find edges whose <code>['attributes'][attribute_name]</code> is present in a list of OSM way ids.</p> PARAMETER DESCRIPTION <code>network</code> <p>a genet.Network object with <code>attribute_name</code> tags,</p> <p> TYPE: <code>Network</code> </p> <code>attribute_name</code> <p>a string corresponding to the name of the link attribute of interest</p> <p> TYPE: <code>str</code> </p> <code>osm_csv_path</code> <p>path to a .csv config file where OSM way ids are stored in column <code>osm_ids</code></p> <p> TYPE: <code>str</code> </p> <code>outpath</code> <p>path to a folder</p> <p> TYPE: <code>str</code> </p> <code>osm_dtype</code> <p>Data type to pass to pandas.read_csv method. Should match the python dtype for OSM data tags stored in the network as they are being matched. Defaults to str.</p> <p> TYPE: <code>type</code> DEFAULT: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple[DataFrame, dict]</code> <p>tuple[pd.DataFrame, dict]: <code>osm_df</code> which is also written to .csv and a mapping between OSM IDs and network link IDs; <code>osm_to_network_dict</code> which is also saved to .json in the <code>outpath</code> location.</p> Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def extract_network_id_from_osm_csv(\n    network: Network, attribute_name: str, osm_csv_path: str, outpath: str, osm_dtype: type = str\n) -&gt; tuple[pd.DataFrame, dict]:\n    \"\"\"Parse a genet.Network object and find edges whose `['attributes'][attribute_name]` is present in a list of OSM way ids.\n\n    Args:\n        network (Network): a genet.Network object with `attribute_name` tags,\n        attribute_name (str): a string corresponding to the name of the link attribute of interest\n        osm_csv_path (str): path to a .csv config file where OSM way ids are stored in column `osm_ids`\n        outpath (str): path to a folder\n        osm_dtype (type, optional):\n            Data type to pass to pandas.read_csv method.\n            Should match the python dtype for OSM data tags stored in the network as they are being matched.\n            Defaults to str.\n\n    Returns:\n        tuple[pd.DataFrame, dict]:\n            `osm_df` which is also written to .csv and a mapping between OSM IDs and network link IDs;\n            `osm_to_network_dict` which is also saved to .json in the `outpath` location.\n    \"\"\"\n\n    osm_df = pd.read_csv(osm_csv_path, dtype={\"osm_id\": osm_dtype})\n    osm_df[\"network_id\"] = pd.Series(dtype=str)\n\n    target_osm_ids = set(osm_df[\"osm_id\"])\n\n    osm_to_network_dict = {}\n\n    with tqdm(total=len(target_osm_ids)) as pbar:\n        for target_id in target_osm_ids:\n            links = network.extract_links_on_edge_attributes(\n                conditions={\"attributes\": {attribute_name: target_id}}\n            )\n\n            # links is now a list of strings\n            if len(links) &gt; 0:\n                # store list of links in dictionary\n                osm_to_network_dict[target_id] = links\n                # mark the OSM id as \"matched\" in the dataframe\n                osm_df.loc[osm_df[\"osm_id\"] == target_id, \"network_id\"] = True\n            else:\n                # mark the OSM id as \"ummatched\" in the dataframe\n                osm_df.loc[osm_df[\"osm_id\"] == target_id, \"network_id\"] = False\n\n            pbar.update(1)\n\n    # check whether some of our OSM ids were not found\n    osm_df[\"network_id\"] = osm_df[\"network_id\"].fillna(False)\n    unmatched_osm_df = osm_df[~osm_df[\"network_id\"]]\n    if unmatched_osm_df.shape[0] &gt; 0:\n        # print unmatched ids\n        logging.info(\n            f'These OSM way IDs did not find a match in the network.xml: {unmatched_osm_df[\"osm_id\"].values}'\n        )\n\n    # write dataframe as .csv and dictionary as .json\n    osm_df.to_csv(os.path.join(outpath, \"osm_tolls_with_network_ids.csv\"), index=False)\n    with open(os.path.join(outpath, \"osm_to_network_ids.json\"), \"w\") as write_file:\n        json.dump(osm_to_network_dict, write_file)\n\n    return osm_df, osm_to_network_dict\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.merge_osm_tolls_and_network_snapping","title":"<code>merge_osm_tolls_and_network_snapping(osm_df, osm_to_network_dict)</code>","text":"Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def merge_osm_tolls_and_network_snapping(osm_df, osm_to_network_dict):\n    # map OSM IDs to network link IDs\n    osm_df[\"network_link_id\"] = osm_df[\"osm_id\"].map(osm_to_network_dict)\n    # not all would have matched, we drop unmatched at this point (they get reported elsewhere)\n    osm_df = osm_df[osm_df[\"network_link_id\"].notna()]\n    osm_df = osm_df.drop([\"osm_id\", \"network_id\"], axis=1)\n    df = pd.DataFrame(\n        {\n            col: np.repeat(osm_df[col].values, osm_df[\"network_link_id\"].str.len())\n            for col in set(osm_df.columns) - {\"network_link_id\"}\n        }\n    ).assign(network_link_id=np.concatenate(osm_df[\"network_link_id\"].values))\n    df = df.rename(columns={\"osm_ref\": \"toll_id\"})\n    return df\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.road_pricing_from_osm","title":"<code>road_pricing_from_osm(network, attribute_name, osm_csv_path, outpath)</code>","text":"<p>Instantiates a Toll object from OSM csv config and network inputs.</p> <p>Parse a genet.Network object and find edges whose <code>['attributes'][attribute_name]['text']</code> is present in a list of OSM way ids.</p> PARAMETER DESCRIPTION <code>network</code> <p>a genet.Network object with attribute_name tags.</p> <p> TYPE: <code>Network</code> </p> <code>attribute_name</code> <p>a string corresponding to the name of the link attribute of interest</p> <p> TYPE: <code>str</code> </p> <code>osm_csv_path</code> <p>path to a .csv config file where OSM way ids are stored in column <code>osm_ids</code></p> <p> TYPE: <code>str</code> </p> <code>outpath</code> <p>path to an outputs folder</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Toll</code> <p>Contains OSM dataframe (which is also written to CSV file), and a mapping between OSM IDs and network link IDs osm_to_network_dict (which is also saved to JSON file in the <code>outpath</code> location).</p> <p> TYPE: <code>Toll</code> </p> Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def road_pricing_from_osm(\n    network: Network, attribute_name: str, osm_csv_path: str, outpath: str\n) -&gt; Toll:\n    \"\"\"Instantiates a Toll object from OSM csv config and network inputs.\n\n    Parse a genet.Network object and find edges whose `['attributes'][attribute_name]['text']` is present in a list of OSM way ids.\n\n    Args:\n        network (Network): a genet.Network object with attribute_name tags.\n        attribute_name (str): a string corresponding to the name of the link attribute of interest\n        osm_csv_path (str): path to a .csv config file where OSM way ids are stored in column `osm_ids`\n        outpath (str): path to an outputs folder\n\n    Returns:\n        Toll: Contains OSM dataframe (which is also written to CSV file), and a mapping between OSM IDs and network link IDs osm_to_network_dict (which is also saved to JSON file in the `outpath` location).\n    \"\"\"\n    osm_df, osm_to_network_dict = extract_network_id_from_osm_csv(\n        network, attribute_name, osm_csv_path, outpath\n    )\n    tolls_df = merge_osm_tolls_and_network_snapping(osm_df, osm_to_network_dict)\n    return Toll(tolls_df)\n</code></pre>"},{"location":"reference/genet/use/road_pricing/#genet.use.road_pricing.write_xml","title":"<code>write_xml(root, path, filename='roadpricing-file.xml')</code>","text":"<p>Write XML config for MATSim Road Pricing a given folder location.</p> PARAMETER DESCRIPTION <code>root</code> <p>root of an XML tree.</p> <p> TYPE: <code>_Element</code> </p> <code>path</code> <p>location of destination folder for Road Pricing config.</p> <p> TYPE: <code>str</code> </p> <code>filename</code> <p>Road pricing XML filename. Defaults to \"roadpricing-file.xml\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'roadpricing-file.xml'</code> </p> Source code in <code>src/genet/use/road_pricing.py</code> <pre><code>def write_xml(root: _Element, path: str, filename: str = \"roadpricing-file.xml\"):\n    \"\"\"Write XML config for MATSim Road Pricing a given folder location.\n\n    Args:\n        root (_Element): root of an XML tree.\n        path (str): location of destination folder for Road Pricing config.\n        filename (str, optional): Road pricing XML filename. Defaults to \"roadpricing-file.xml\".\n    \"\"\"\n    tree = et.tostring(root, pretty_print=True, xml_declaration=False, encoding=\"UTF-8\")\n    with open(os.path.join(path, filename), \"wb\") as file:\n        file.write(b'&lt;?xml version=\"1.0\" ?&gt;\\n')\n        file.write(\n            b'&lt;!DOCTYPE roadpricing SYSTEM \"http://www.matsim.org/files/dtd/roadpricing_v1.dtd\"&gt;\\n'\n        )\n        file.write(tree)\n</code></pre>"},{"location":"reference/genet/use/schedule/","title":"genet.use.schedule","text":""},{"location":"reference/genet/use/schedule/#genet.use.schedule.aggregate_by_stop_names","title":"<code>aggregate_by_stop_names(df_aggregate_trips_per_day_per_route_by_end_stop_pairs)</code>","text":"Source code in <code>src/genet/use/schedule.py</code> <pre><code>def aggregate_by_stop_names(df_aggregate_trips_per_day_per_route_by_end_stop_pairs):\n    df = df_aggregate_trips_per_day_per_route_by_end_stop_pairs\n    df = df[(df[\"station_A_name\"] != \"\") &amp; (df[\"station_B_name\"] != \"\")]\n    if not df.empty:\n        df[[\"station_A_name\", \"station_B_name\"]] = np.sort(\n            df[[\"station_A_name\", \"station_B_name\"]], axis=1\n        )\n        df = (\n            df.groupby([\"station_A_name\", \"station_B_name\", \"mode\"])[\"number_of_trips\"]\n            .sum()\n            .reset_index()\n        )\n    return df\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.aggregate_trips_per_day_per_route_by_end_stop_pairs","title":"<code>aggregate_trips_per_day_per_route_by_end_stop_pairs(schedule, trips_per_day_per_route)</code>","text":"Source code in <code>src/genet/use/schedule.py</code> <pre><code>def aggregate_trips_per_day_per_route_by_end_stop_pairs(schedule, trips_per_day_per_route):\n    def route_id_intersect(row):\n        intersect = set(schedule.graph().nodes[row[\"station_A\"]][\"routes\"]) &amp; set(\n            schedule.graph().nodes[row[\"station_B\"]][\"routes\"]\n        )\n        if intersect:\n            return intersect\n        else:\n            return float(\"nan\")\n\n    df = None\n    for mode in schedule.modes():\n        end_points = set()\n        for route in schedule.routes():\n            if route.mode == mode:\n                end_points |= {route.ordered_stops[0], route.ordered_stops[-1]}\n        df_stops = pd.DataFrame.from_records(\n            list(itertools.combinations({schedule.stop(pt).id for pt in end_points}, 2)),\n            columns=[\"station_A\", \"station_B\"],\n        )\n        df_stops[\"station_A_name\"] = df_stops[\"station_A\"].apply(lambda x: schedule.stop(x).name)\n        df_stops[\"station_B_name\"] = df_stops[\"station_B\"].apply(lambda x: schedule.stop(x).name)\n        df_stops[\"mode\"] = mode\n        if df is None:\n            df = df_stops\n        else:\n            df = pd.concat([df, df_stops])\n    df[\"routes_in_common\"] = df.apply(lambda x: route_id_intersect(x), axis=1)\n    df = df.dropna()\n    trips_per_day_per_route = trips_per_day_per_route.set_index(\"route_id\")\n    df[\"number_of_trips\"] = df[\"routes_in_common\"].apply(\n        lambda x: sum([trips_per_day_per_route.loc[r_id, \"number_of_trips\"] for r_id in x])\n    )\n    return df\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.divide_network_route","title":"<code>divide_network_route(route, stops_linkrefids)</code>","text":"<p>Divides the network route traversed by a PT service into list of lists.</p> <p>Examples:</p> <pre><code>route = ['a-a', 'a-b', 'b-b', 'b-c', 'c-c', 'c-d']\nstops_linkrefids = ['a-a', 'b-b', 'c-c']\n</code></pre> <p>For a service with stops A, B, C, where the stops are snapped to network links 'a-a', 'b-b', 'c-c' respectively. This method will give you the answer: <pre><code>[['a-a', 'a-b', 'b-b'], ['b-b', 'b-c', 'c-c']]\n</code></pre> i.e. the route between stops A and B, and B and C, in order.</p> PARAMETER DESCRIPTION <code>route</code> <p>list of network link IDs.</p> <p> TYPE: <code>list[str]</code> </p> <code>stops_linkrefids</code> <p>List of network link IDs (str) that the stops on route are snapped to.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>list[list[str]]</code> <p>list[list[str]]: Divided route.</p> Source code in <code>src/genet/use/schedule.py</code> <pre><code>def divide_network_route(route: list[str], stops_linkrefids: list[str]) -&gt; list[list[str]]:\n    \"\"\"Divides the network route traversed by a PT service into list of lists.\n\n    Examples:\n        ```python\n        route = ['a-a', 'a-b', 'b-b', 'b-c', 'c-c', 'c-d']\n        stops_linkrefids = ['a-a', 'b-b', 'c-c']\n        ```\n\n        For a service with stops A, B, C, where the stops are snapped to network links 'a-a', 'b-b', 'c-c' respectively.\n        This method will give you the answer:\n        ```python\n        [['a-a', 'a-b', 'b-b'], ['b-b', 'b-c', 'c-c']]\n        ```\n        i.e. the route between stops A and B, and B and C, in order.\n\n    Args:\n        route (list[str]): list of network link IDs.\n        stops_linkrefids (list[str]): List of network link IDs (str) that the stops on route are snapped to.\n\n    Returns:\n        list[list[str]]: Divided route.\n    \"\"\"\n    divided_route: list[list[str]] = [[]]\n    for link_id in route:\n        divided_route[-1].append(link_id)\n        while stops_linkrefids and (link_id == stops_linkrefids[0]):\n            divided_route.append([stops_linkrefids[0]])\n            stops_linkrefids = stops_linkrefids[1:]\n    return divided_route[1:-1]\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.generate_edge_vph_geodataframe","title":"<code>generate_edge_vph_geodataframe(df, gdf_links)</code>","text":"<p>Generates vehicles per hour for a trips dataframe.</p> PARAMETER DESCRIPTION <code>df</code> <p>trips dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> <code>gdf_links</code> <p>geodataframe containing links of the schedule (element) graph.</p> <p> TYPE: <code>GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: Geodataframe which merges the two input arguments and keeps the <code>vph</code> column.</p> Source code in <code>src/genet/use/schedule.py</code> <pre><code>def generate_edge_vph_geodataframe(\n    df: pd.DataFrame, gdf_links: gpd.GeoDataFrame\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Generates vehicles per hour for a trips dataframe.\n\n    Args:\n        df (pd.DataFrame): trips dataframe.\n        gdf_links (gpd.GeoDataFrame): geodataframe containing links of the schedule (element) graph.\n\n    Returns:\n        gpd.GeoDataFrame: Geodataframe which merges the two input arguments and keeps the `vph` column.\n    \"\"\"\n    df.loc[:, \"hour\"] = df[\"departure_time\"].dt.round(\"H\")\n    groupby_cols = [\"hour\", \"trip_id\", \"from_stop\", \"from_stop_name\", \"to_stop\", \"to_stop_name\"]\n    df = df.groupby(groupby_cols).count().reset_index()\n    df.loc[:, \"vph\"] = 1\n    groupby_cols.remove(\"trip_id\")\n    df = df.groupby(groupby_cols).sum().reset_index()\n\n    cols_to_delete = df.columns.difference(groupby_cols + [\"vph\"])\n    gdf = gdf_links.merge(df, left_on=[\"u\", \"v\"], right_on=[\"from_stop\", \"to_stop\"])\n    gdf = gdf.drop(cols_to_delete.union([\"u\", \"v\", \"routes\", \"services\"]), axis=1)\n    return gdf\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.get_offset","title":"<code>get_offset(time)</code>","text":"Source code in <code>src/genet/use/schedule.py</code> <pre><code>def get_offset(time):\n    time_list = time.split(\":\")\n    return timedelta(\n        seconds=int(time_list[0]) * 60 * 60 + int(time_list[1]) * 60 + int(time_list[2])\n    )\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.network_routed_distance_gdf","title":"<code>network_routed_distance_gdf(schedule, gdf_network_links)</code>","text":"Source code in <code>src/genet/use/schedule.py</code> <pre><code>def network_routed_distance_gdf(schedule, gdf_network_links):\n    def combine_route(group):\n        group = group.sort_values(by=\"sequence\")\n        geom = spatial.merge_linestrings(list(group[\"geometry\"]))\n        length = group[\"length\"].sum()\n        group = group.iloc[0, :][[\"id\", \"from_stop\", \"to_stop\"]]\n        group[\"geometry\"] = geom\n        group[\"network_distance\"] = length\n        return group\n\n    # TODO speeds account for snapping to long links\n    logging.warning(\n        \"Right now routed speeds do not account for services snapping to long network links. \"\n        \"Be sure to account for that in your investigations and check the non-routed `pt_speeds`\"\n        \"output as well.\"\n    )\n\n    routes_df = schedule.route_attribute_data(keys=[\"id\", \"network_links\", \"ordered_stops\"])\n    routes_df[\"linkrefids\"] = routes_df.apply(\n        lambda x: [\n            schedule._graph.nodes[i][\"linkRefId\"]\n            for i in schedule._graph.graph[\"routes\"][x[\"id\"]][\"ordered_stops\"]\n        ],\n        axis=1,\n    )\n    routes_df[\"network_links\"] = routes_df.apply(\n        lambda x: divide_network_route(x[\"network_links\"], x[\"linkrefids\"]), axis=1\n    )\n    routes_df.drop(\"linkrefids\", axis=1, inplace=True)\n    routes_df[\"ordered_stops\"] = routes_df[\"ordered_stops\"].apply(\n        lambda x: list(zip(x[:-1], x[1:]))\n    )\n    stop_cols = np.concatenate(routes_df[\"ordered_stops\"].values)\n    route_cols = sum(routes_df[\"network_links\"].values, [])\n    # expand across stop pairs\n    routes_df = pd.DataFrame(\n        {\n            col: np.repeat(routes_df[col].values, routes_df[\"ordered_stops\"].str.len())\n            for col in set(routes_df.columns) - {\"ordered_stops\", \"network_links\"}\n        }\n    ).assign(from_stop=stop_cols[:, 0], to_stop=stop_cols[:, 1], network_links=route_cols)\n    # expand across route\n    routes_df[\"sequence\"] = routes_df[\"network_links\"].apply(lambda x: list(range(len(x))))\n    routes_df = pd.DataFrame(\n        {\n            col: np.repeat(routes_df[col].values, routes_df[\"network_links\"].str.len())\n            for col in set(routes_df.columns) - {\"network_links\", \"sequence\"}\n        }\n    ).assign(\n        network_links=np.concatenate(routes_df[\"network_links\"].values),\n        sequence=np.concatenate(routes_df[\"sequence\"].values),\n    )\n    routes_gdf = gdf_network_links[[\"length\", \"geometry\"]].merge(\n        routes_df, right_on=\"network_links\", left_index=True\n    )\n\n    new_route = routes_gdf.groupby([\"id\", \"from_stop\", \"to_stop\"], as_index=False).apply(\n        combine_route\n    )\n\n    return gpd.GeoDataFrame(new_route).set_crs(routes_gdf.crs)\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.sanitise_time","title":"<code>sanitise_time(time, gtfs_day='19700101')</code>","text":"Source code in <code>src/genet/use/schedule.py</code> <pre><code>def sanitise_time(time, gtfs_day=\"19700101\"):\n    time_list = time.split(\":\")\n    if int(time_list[0]) &gt;= 24:\n        days = int(time_list[0]) // 24\n        time_list[0] = int(time_list[0]) % 24\n        if time_list[0] &lt; 10:\n            time_list[0] = \"0{}\".format(time_list[0])\n        else:\n            time_list[0] = str(time_list[0])\n        return datetime.strptime(\n            gtfs_day + \" \" + \":\".join(time_list), \"%Y%m%d %H:%M:%S\"\n        ) + timedelta(days=days)\n    else:\n        return datetime.strptime(gtfs_day + \" \" + time, \"%Y%m%d %H:%M:%S\")\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.trips_per_day_per_route","title":"<code>trips_per_day_per_route(df, output_dir=None)</code>","text":"<p>Generates trips per day per route for a trips dataframe.</p> PARAMETER DESCRIPTION <code>df</code> <p>trips dataframe</p> <p> TYPE: <code>DataFrame</code> </p> <code>output_dir</code> <p>If given, directory to save <code>trips_per_day_per_service.csv</code>. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: trips per day per route.</p> Source code in <code>src/genet/use/schedule.py</code> <pre><code>def trips_per_day_per_route(df: pd.DataFrame, output_dir: Optional[str] = None) -&gt; pd.DataFrame:\n    \"\"\"Generates trips per day per route for a trips dataframe.\n\n    Args:\n        df (pd.DataFrame): trips dataframe\n        output_dir (Optional[str], optional):\n            If given, directory to save `trips_per_day_per_service.csv`.\n            Defaults to None.\n\n    Returns:\n        pd.DataFrame: trips per day per route.\n    \"\"\"\n    trips_per_day = (\n        df.groupby([\"route_id\", \"route_name\", \"mode\"]).nunique()[\"trip_id\"].reset_index()\n    )\n    trips_per_day = trips_per_day.rename(columns={\"trip_id\": \"number_of_trips\"})\n    if output_dir:\n        trips_per_day.to_csv(os.path.join(output_dir, \"trips_per_day_per_route.csv\"))\n    return trips_per_day\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.trips_per_day_per_service","title":"<code>trips_per_day_per_service(df, output_dir=None)</code>","text":"<p>Generates trips per day per service for a trips dataframe.</p> PARAMETER DESCRIPTION <code>df</code> <p>trips dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> <code>output_dir</code> <p>If given, directory to save <code>trips_per_day_per_service.csv</code>. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Trips per day.</p> Source code in <code>src/genet/use/schedule.py</code> <pre><code>def trips_per_day_per_service(df: pd.DataFrame, output_dir: Optional[str] = None) -&gt; pd.DataFrame:\n    \"\"\"Generates trips per day per service for a trips dataframe.\n\n    Args:\n        df (pd.DataFrame): trips dataframe.\n        output_dir (Optional[str], optional):\n            If given, directory to save `trips_per_day_per_service.csv`.\n            Defaults to None.\n\n    Returns:\n        pd.DataFrame: Trips per day.\n    \"\"\"\n    trips_per_day = (\n        df.groupby([\"service_id\", \"service_name\", \"route_id\", \"mode\"])\n        .nunique()[\"trip_id\"]\n        .reset_index()\n    )\n    trips_per_day = (\n        trips_per_day.groupby([\"service_id\", \"service_name\", \"mode\"]).sum()[\"trip_id\"].reset_index()\n    )\n    trips_per_day = trips_per_day.rename(columns={\"trip_id\": \"number_of_trips\"})\n    if output_dir:\n        trips_per_day.to_csv(os.path.join(output_dir, \"trips_per_day_per_service.csv\"))\n    return trips_per_day\n</code></pre>"},{"location":"reference/genet/use/schedule/#genet.use.schedule.vehicles_per_hour","title":"<code>vehicles_per_hour(df, aggregate_by, output_path=None)</code>","text":"<p>Generates vehicles per hour for a trips dataframe</p> PARAMETER DESCRIPTION <code>df</code> <p>trips dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> <code>aggregate_by</code> <p>trip metadata to aggregate trips by.</p> <p> TYPE: <code>list</code> </p> <code>output_path</code> <p>If given, path for the frame with .csv extension. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Vehicles per hour.</p> Source code in <code>src/genet/use/schedule.py</code> <pre><code>def vehicles_per_hour(\n    df: pd.DataFrame, aggregate_by: list, output_path: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"Generates vehicles per hour for a trips dataframe\n\n    Args:\n        df (pd.DataFrame): trips dataframe.\n        aggregate_by (list): trip metadata to aggregate trips by.\n        output_path (Optional[str], optional):\n            If given, path for the frame with .csv extension.\n            Defaults to None.\n\n    Returns:\n        pd.DataFrame: Vehicles per hour.\n    \"\"\"\n    df.loc[:, \"hour\"] = df[\"departure_time\"].dt.round(\"H\")\n    df.loc[:, \"hour\"] = df[\"hour\"].dt.hour\n    df = df.groupby([\"hour\", \"trip_id\"] + aggregate_by).count().reset_index()\n    df.loc[:, \"vph\"] = 1\n    df = pd.pivot_table(\n        df, values=\"vph\", index=aggregate_by, columns=[\"hour\"], aggfunc=np.sum\n    ).reset_index()\n    df = df.fillna(0)\n    if output_path:\n        df.to_csv(output_path)\n    return df\n</code></pre>"},{"location":"reference/genet/utils/dict_support/","title":"genet.utils.dict_support","text":""},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.combine_edge_data_lists","title":"<code>combine_edge_data_lists(l1, l2)</code>","text":"<p>Merges two lists where each elem is of the form (from_node, to_node, list).</p> PARAMETER DESCRIPTION <code>l1</code> <p>First list in merge.</p> <p> TYPE: <code>list</code> </p> <code>l2</code> <p>Second list in merge.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of merged dictionaries.</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def combine_edge_data_lists(l1: list, l2: list) -&gt; list:\n    \"\"\"Merges two lists where each elem is of the form (from_node, to_node, list).\n\n    Args:\n        l1 (list): First list in merge.\n        l2 (list): Second list in merge.\n\n    Returns:\n        list: List of merged dictionaries.\n    \"\"\"\n    edges = merge_complex_dictionaries(\n        {(u, v): dat for u, v, dat in l1}, {(u, v): dat for u, v, dat in l2}\n    )\n    return [(u, v, dat) for (u, v), dat in edges.items()]\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.dataframe_to_dict","title":"<code>dataframe_to_dict(df)</code>","text":"Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def dataframe_to_dict(df):\n    return {_id: {k: v for k, v in m.items() if notna(v)} for _id, m in df.to_dict().items()}\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.dict_to_string","title":"<code>dict_to_string(d)</code>","text":"Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def dict_to_string(d):\n    return str(d).replace(\"{\", \"\").replace(\"}\", \"\").replace(\"'\", \"\").replace(\" \", \":\")\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.find_nested_paths_to_value","title":"<code>find_nested_paths_to_value(d, value)</code>","text":"Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def find_nested_paths_to_value(d: dict, value: Union[str, int, float, set, list]):\n    def parse_node_path(node_path):\n        n_path_names_reversed = list(reversed([n.name for n in node_path if n.name != \"attribute\"]))\n        if len(n_path_names_reversed) == 1:\n            return n_path_names_reversed[0]\n        else:\n            d = {n_path_names_reversed[1]: n_path_names_reversed[0]}\n            for key in n_path_names_reversed[2:]:\n                d = {key: d}\n            return d\n\n    if not isinstance(value, (list, set)):\n        value = {value}\n    elif not isinstance(value, set):\n        value = set(value)\n    paths = []\n    schema = graph_operations.get_attribute_schema([(\"\", d)], data=True)\n    for node in schema.descendants:\n        try:\n            if node.values &amp; value:\n                paths.append(parse_node_path(node.path))\n        except AttributeError:\n            # that node does not have values\n            pass\n    return paths\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.get_nested_value","title":"<code>get_nested_value(d, path)</code>","text":"<p>Retrieves value from nested dictionary.</p> PARAMETER DESCRIPTION <code>d</code> <p><code>{key: {key_2: {key_2_1: hey}, key_1: 1234}</code>.</p> <p> TYPE: <code>dict</code> </p> <code>path</code> <p><code>{key: {key_2: key_2_1}} path to take through the dictionary d</code>.</p> <p> TYPE: <code>Union[dict, str]</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>All nested keys in the path must exist.</p> RETURNS DESCRIPTION <code>dict</code> <p><code>d[key][key_2][key_2_1]</code></p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def get_nested_value(d: dict, path: Union[dict, str]) -&gt; dict:\n    \"\"\"Retrieves value from nested dictionary.\n\n    Args:\n        d (dict): `{key: {key_2: {key_2_1: hey}, key_1: 1234}`.\n        path (Union[dict, str]): `{key: {key_2: key_2_1}} path to take through the dictionary d`.\n\n    Raises:\n        KeyError: All nested keys in the path must exist.\n\n    Returns:\n        dict: `d[key][key_2][key_2_1]`\n    \"\"\"\n\n    if isinstance(path, dict):\n        for k, v in path.items():\n            if k in d:\n                val = get_nested_value(d[k], v)\n            else:\n                raise KeyError(f\"Dictionary {d} does not have key {k}\")\n    else:\n        val = d[path]\n    return val\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.merge_complex_dictionaries","title":"<code>merge_complex_dictionaries(d1, d2)</code>","text":"<p>Merges two dictionaries where the values can be lists, sets or other dictionaries with the same behaviour.</p> <p>If values are not list, set or dict then d2 values prevail.</p> <p>If the values are lists, the two merge, retaining all elements of both lists and preserving their order. The result is: <code>d1_list</code> + <code>d2_list</code>.</p> <p>If the values are sets, the two combine with the OR operator.</p> <p>If the values are dicts, the two merge using this method.</p> PARAMETER DESCRIPTION <code>d1</code> <p>First dictionary in the merge</p> <p> TYPE: <code>dict</code> </p> <code>d2</code> <p>Second dictionary in the merge</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Merged dictionary.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def merge_complex_dictionaries(d1: dict, d2: dict) -&gt; dict:\n    \"\"\"\n    Merges two dictionaries where the values can be lists, sets or other dictionaries with the same behaviour.\n\n    If values are not list, set or dict then d2 values prevail.\n\n    If the values are lists, the two merge, retaining all elements of both lists and preserving their order.\n    The result is: `d1_list` + `d2_list`.\n\n    If the values are sets, the two combine with the OR operator.\n\n    If the values are dicts, the two merge using this method.\n\n    Args:\n        d1 (dict): First dictionary in the merge\n        d2 (dict): Second dictionary in the merge\n\n    Returns:\n        dict: Merged dictionary.\n    \"\"\"\n    d = deepcopy(d1)\n    clashing_keys = set(d1) &amp; set(d2)\n    for key in clashing_keys:\n        if isinstance(d1[key], dict) and isinstance(d2[key], dict):\n            d[key] = merge_complex_dictionaries(d1[key], d2[key])\n        elif isinstance(d1[key], list) and isinstance(d2[key], list):\n            d[key] = d1[key] + d2[key]\n        elif isinstance(d1[key], set) and isinstance(d2[key], set):\n            d[key] = d1[key] | d2[key]\n        else:\n            d[key] = d2[key]\n    for key in set(d2) - clashing_keys:\n        d[key] = d2[key]\n    return d\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.nest_at_leaf","title":"<code>nest_at_leaf(d, value)</code>","text":"Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def nest_at_leaf(d: dict, value):\n    for k, v in d.items():\n        if isinstance(v, dict):\n            nest_at_leaf(v, value)\n        else:\n            d[k] = {v: value}\n    return d\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.notna","title":"<code>notna(value)</code>","text":"Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def notna(value):\n    nn = pd.notna(value)\n    if isinstance(nn, ndarray):\n        return any(nn)\n    return nn\n</code></pre>"},{"location":"reference/genet/utils/dict_support/#genet.utils.dict_support.set_nested_value","title":"<code>set_nested_value(d, value)</code>","text":"<p>Changes or, if not present injects, <code>different_value</code> into nested dictionary d at key <code>key: key_2</code>.</p> PARAMETER DESCRIPTION <code>d</code> <p><code>{key: {key_2: value, key_1: 1234}</code></p> <p> TYPE: <code>dict</code> </p> <code>value</code> <p><code>{key: {key_2: different_value}}</code></p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p><code>d</code> with nested dictionary value updated.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/dict_support.py</code> <pre><code>def set_nested_value(d: dict, value: dict) -&gt; dict:\n    \"\"\"Changes or, if not present injects, `different_value` into nested dictionary d at key `key: key_2`.\n\n    Args:\n        d (dict): `{key: {key_2: value, key_1: 1234}`\n        value (dict): `{key: {key_2: different_value}}`\n\n    Returns:\n        dict: `d` with nested dictionary value updated.\n    \"\"\"\n    if isinstance(value, dict):\n        for k, v in value.items():\n            if k in d:\n                if isinstance(d[k], dict):\n                    d[k] = set_nested_value(d[k], v)\n                else:\n                    d[k] = v\n            else:\n                d[k] = v\n    else:\n        d = value\n    return d\n</code></pre>"},{"location":"reference/genet/utils/elevation/","title":"genet.utils.elevation","text":""},{"location":"reference/genet/utils/elevation/#genet.utils.elevation.get_elevation_data","title":"<code>get_elevation_data(img, lat, lon)</code>","text":"Source code in <code>src/genet/utils/elevation.py</code> <pre><code>def get_elevation_data(img, lat, lon):\n    output = img.sel(x=lon, y=lat, method=\"nearest\")\n    mt = output.values\n    elevation_meters = mt.item()\n\n    return elevation_meters\n</code></pre>"},{"location":"reference/genet/utils/elevation/#genet.utils.elevation.get_elevation_image","title":"<code>get_elevation_image(elevation_tif)</code>","text":"Source code in <code>src/genet/utils/elevation.py</code> <pre><code>def get_elevation_image(elevation_tif):\n    xarr_file = rioxarray.open_rasterio(elevation_tif)\n    if str(xarr_file.rio.crs) != \"EPSG:4326\":\n        xarr_file = xarr_file.rio.write_crs(4326, inplace=True)\n\n    return xarr_file[0, :, :]\n</code></pre>"},{"location":"reference/genet/utils/elevation/#genet.utils.elevation.validation_report_for_node_elevation","title":"<code>validation_report_for_node_elevation(elev_dict, low_limit=-50, mont_blanc_height=4809)</code>","text":"<p>Generates a validation report for the node elevation dictionary.</p> PARAMETER DESCRIPTION <code>elev_dict</code> <p>contains node_id as key and elevation in meters as value.</p> <p> TYPE: <code>dict</code> </p> <code>low_limit</code> <p>values below this get flagged as possibly wrong. Defaults to -50 (below sea level).</p> <p> TYPE: <code>int</code> DEFAULT: <code>-50</code> </p> <code>mont_blanc_height</code> <p>values above this get flagged as possibly wrong. Defaults to 4809 (the height of Mont Blanc).</p> <p> TYPE: <code>int</code> DEFAULT: <code>4809</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Contains summary statistics, and extreme values lists.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/elevation.py</code> <pre><code>def validation_report_for_node_elevation(\n    elev_dict: dict, low_limit: int = -50, mont_blanc_height: int = 4809\n) -&gt; dict:\n    \"\"\"Generates a validation report for the node elevation dictionary.\n\n    Args:\n        elev_dict (dict): contains node_id as key and elevation in meters as value.\n        low_limit (int, optional): values below this get flagged as possibly wrong. Defaults to -50 (below sea level).\n        mont_blanc_height (int, optional): values above this get flagged as possibly wrong. Defaults to 4809 (the height of Mont Blanc).\n\n    Returns:\n        dict: Contains summary statistics, and extreme values lists.\n    \"\"\"\n\n    elevation_list = []\n    for node_id in elev_dict.keys():\n        elevation_list.append(elev_dict[node_id][\"z\"])\n\n    min_value = np.min(elevation_list)\n    max_value = np.max(elevation_list)\n    mean = np.mean(elevation_list)\n    median = np.median(elevation_list)\n\n    too_high = {}\n    too_low = {}\n\n    for node_id in elev_dict.keys():\n        node_elev = elev_dict[node_id][\"z\"]\n        if node_elev &lt; low_limit:\n            too_low[node_id] = node_elev\n        elif node_elev &gt; mont_blanc_height:\n            too_high[node_id] = node_elev\n\n    report = {\n        \"summary\": {\n            \"total_nodes\": len(elevation_list),\n            \"min_value\": int(min_value),\n            \"max_value\": int(max_value),\n            \"mean\": int(mean),\n            \"median\": int(median),\n            \"extremely_high_values_count\": len(too_high),\n            \"extremely_low_values_count\": len(too_low),\n        },\n        \"values\": {\"extremely_high_values_dict\": too_high, \"extremely_low_values_dict\": too_low},\n    }\n\n    return report\n</code></pre>"},{"location":"reference/genet/utils/elevation/#genet.utils.elevation.write_slope_xml","title":"<code>write_slope_xml(link_slope_dictionary, output_dir)</code>","text":"<p>Generates a link_slopes XML file.</p> PARAMETER DESCRIPTION <code>link_slope_dictionary</code> <p>dictionary of link slopes in format <code>{link_id: {'slope': slope_value}}</code></p> <p> TYPE: <code>dict</code> </p> <code>output_dir</code> <p>directory where the XML file will be written to.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/utils/elevation.py</code> <pre><code>def write_slope_xml(link_slope_dictionary: dict, output_dir: str):\n    \"\"\"Generates a link_slopes XML file.\n\n    Args:\n        link_slope_dictionary (dict): dictionary of link slopes in format `{link_id: {'slope': slope_value}}`\n        output_dir (str): directory where the XML file will be written to.\n    \"\"\"\n    fname = os.path.join(output_dir, \"link_slopes.xml\")\n    logging.info(f\"Writing {fname}\")\n\n    with open(fname, \"wb\") as f, etree.xmlfile(f, encoding=\"UTF-8\") as xf:\n        xf.write_declaration(\n            doctype='&lt;!DOCTYPE objectAttributes SYSTEM \"http://matsim.org/files/dtd/objectattributes_v1.dtd\"&gt;'\n        )\n        with xf.element(\"objectAttributes\"):\n            for link_id, slope_dict in link_slope_dictionary.items():\n                with xf.element(\"object\", {\"id\": link_id}):\n                    attrib = {\"name\": \"slope\", \"class\": \"java.lang.Double\"}\n                    rec = etree.Element(\"attribute\", attrib)\n                    rec.text = str(slope_dict[\"slope\"])\n                    xf.write(rec)\n</code></pre>"},{"location":"reference/genet/utils/google_directions/","title":"genet.utils.google_directions","text":""},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.session","title":"<code>session = FuturesSession(max_workers=2)</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.dump_all_api_requests_to_json","title":"<code>dump_all_api_requests_to_json(api_requests, output_dir, output_file_name=None)</code>","text":"Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def dump_all_api_requests_to_json(api_requests, output_dir, output_file_name=None):\n    # sanitise tuple keys\n    new_d = {}\n    for k, v in api_requests.items():\n        new_d[\"{}\".format(k)] = \"{}\".format(v)\n\n    if output_file_name is None:\n        output_file_name = \"api_requests.json\"\n\n    persistence.ensure_dir(output_dir)\n    logging.info(f\"Saving Google Directions API requests to {output_dir}\")\n    with open(os.path.join(output_dir, output_file_name), \"w\") as fp:\n        json.dump(new_d, fp)\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.generate_requests","title":"<code>generate_requests(n, osm_tags=all)</code>","text":"<p>Generates a dictionary describing pairs of nodes for which we need to request directions from Google directions API.</p> PARAMETER DESCRIPTION <code>n</code> <p>GeNet network.</p> <p> TYPE: <code>Network</code> </p> <code>osm_tags</code> <p>OSM tags to subset the network on. Defaults to all (no subsetting).</p> <p> TYPE: <code>Union[Callable, list[str]]</code> DEFAULT: <code>all</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Can only subset on tags for non-simplified networks.</p> RETURNS DESCRIPTION <code>dict</code> <p>Generated requests.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def generate_requests(n: Network, osm_tags: Union[Callable, list[str]] = all) -&gt; dict:\n    \"\"\"Generates a dictionary describing pairs of nodes for which we need to request directions from Google directions API.\n\n    Args:\n        n (Network): GeNet network.\n        osm_tags (Union[Callable, list[str]], optional): OSM tags to subset the network on. Defaults to all (no subsetting).\n\n    Raises:\n        RuntimeError: Can only subset on tags for non-simplified networks.\n\n    Returns:\n        dict: Generated requests.\n    \"\"\"\n    if n.is_simplified():\n        logging.info(\"Generating Google Directions API requests for a simplified network.\")\n        return _generate_requests_for_simplified_network(n)\n    elif (n.is_simplified()) and (osm_tags != all):\n        raise RuntimeError(\n            \"OSM tags can only be specified if the network used to generate the requests is not \"\n            \"simplified. Please use a non-simplified network as input or set osm_tags=all.\"\n        )\n    else:\n        logging.info(\"Generating Google Directions API requests for a non-simplified network.\")\n        return _generate_requests_for_non_simplified_network(n, osm_tags)\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.make_request","title":"<code>make_request(origin_attributes, destination_attributes, key, departure_time, traffic_model)</code>","text":"Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def make_request(origin_attributes, destination_attributes, key, departure_time, traffic_model):\n    base_url = \"https://maps.googleapis.com/maps/api/directions/json\"\n    params = {\n        \"origin\": \"{},{}\".format(origin_attributes[\"lat\"], origin_attributes[\"lon\"]),\n        \"destination\": \"{},{}\".format(destination_attributes[\"lat\"], destination_attributes[\"lon\"]),\n        \"key\": key,\n        \"traffic_model\": traffic_model,\n    }\n    current_unix_time = time.time()\n    end_of_unix_time = 2147483646\n    if departure_time == \"now\":\n        params[\"departure_time\"] = \"now\"\n    elif (\n        isinstance(departure_time, int)\n        &amp; (departure_time &gt; current_unix_time)\n        &amp; (departure_time &lt; end_of_unix_time)\n    ):\n        params[\"departure_time\"] = departure_time\n    else:\n        raise RuntimeError(\n            \"The departure_time parameter value not recognised. The departure_time can be set \"\n            \"to None (meaning API will return results for average time-independent traffic conditions)\"\n            ', \"now\", or some time in the future. If setting the departure_time to '\n            \"some time in the future, then it needs to be specified as an integer in seconds since \"\n            \"midnight, January 1, 1970 UTC (i.e. unix time). It cannot be in the past.\"\n        )\n    return session.get(base_url, params=params)\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.map_results_to_edges","title":"<code>map_results_to_edges(api_requests)</code>","text":"Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def map_results_to_edges(api_requests):\n    google_dir_api_edge_data = {}\n    for node_request_pair, api_requests_attribs in api_requests.items():\n        path_nodes = api_requests_attribs[\"path_nodes\"]\n        parsed_request_data = api_requests_attribs[\"parsed_response\"]\n\n        edges = set(zip(path_nodes[:-1], path_nodes[1:]))\n\n        current_edges = set(google_dir_api_edge_data.keys())\n        overlapping_edges = edges &amp; current_edges\n        left_overs = edges - overlapping_edges\n        google_dir_api_edge_data = {\n            **google_dir_api_edge_data,\n            **dict(zip(left_overs, [parsed_request_data] * len(left_overs))),\n        }\n    return google_dir_api_edge_data\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.parse_results","title":"<code>parse_results(api_requests)</code>","text":"<p>Goes through all api requests and parses results.</p> PARAMETER DESCRIPTION <code>api_requests</code> <p>generated and 'sent' api requests.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Requests with parsed results.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def parse_results(api_requests: dict) -&gt; dict:\n    \"\"\"Goes through all api requests and parses results.\n\n    Args:\n        api_requests (dict): generated and 'sent' api requests.\n\n    Returns:\n        dict: Requests with parsed results.\n    \"\"\"\n    api_requests_with_response = {}\n    for node_request_pair, api_requests_attribs in api_requests.items():\n        path_polyline = api_requests_attribs[\"path_polyline\"]\n        request = api_requests_attribs[\"request\"]\n        del api_requests_attribs[\"request\"]\n        api_requests_attribs[\"request_payload\"] = request.result().json()\n        api_requests_attribs[\"parsed_response\"] = parse_routes(request.result(), path_polyline)\n        api_requests_with_response[node_request_pair] = api_requests_attribs\n    return api_requests_with_response\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.parse_route","title":"<code>parse_route(route)</code>","text":"Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def parse_route(route: dict):\n    def compute_speed():\n        total_distance = sum([leg[\"distance\"][\"value\"] for leg in legs])\n        total_duration = 0\n        for leg in legs:\n            if \"duration_in_traffic\" in leg:\n                total_duration += leg[\"duration_in_traffic\"][\"value\"]\n            else:\n                logging.warning(\n                    f'duration_in_traffic was not found for leg: from: {leg[\"start_location\"]} '\n                    f'to: {leg[\"end_location\"]}'\n                )\n                total_duration += leg[\"duration\"][\"value\"]\n        if total_duration == 0:\n            logging.warning(\n                \"Duration of 0 detected. Route polyline: {}\".format(\n                    route[\"overview_polyline\"][\"points\"]\n                )\n            )\n            return 0\n        return total_distance / total_duration\n\n    legs = route[\"legs\"]\n    if len(legs) &gt; 1:\n        logging.warning(\n            \"Response has more than one leg. This is not consistent with driving requests.\"\n        )\n    data = {\n        \"google_speed\": compute_speed(),\n        \"google_polyline\": route[\"overview_polyline\"][\"points\"],\n    }\n    return data\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.parse_routes","title":"<code>parse_routes(response, path_polyline)</code>","text":"<p>Parses response contents to infer speed.</p> <p>If response returned more than one route, it picks the one closest on average to the original request.</p> PARAMETER DESCRIPTION <code>response</code> <p>request content</p> <p> TYPE: <code>Response</code> </p> <code>path_polyline</code> <p>original request path encoded list of lat lon tuples</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Parsed routes.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def parse_routes(response: requests.Response, path_polyline: str) -&gt; dict:\n    \"\"\"Parses response contents to infer speed.\n\n    If response returned more than one route, it picks the one closest on average to the original request.\n\n    Args:\n        response (requests.Response): request content\n        path_polyline (str): original request path encoded list of lat lon tuples\n\n    Returns:\n        dict: Parsed routes.\n    \"\"\"\n    data: dict = {}\n\n    if response.status_code == 200:\n        content = response.json()\n        if content[\"routes\"]:\n            if len(content[\"routes\"]) &gt; 1:\n                for route in content[\"routes\"]:\n                    route_data = parse_route(route)\n                    route_data[\"polyline_proximity\"] = (\n                        spatial.compute_average_proximity_to_polyline(\n                            route_data[\"google_polyline\"], path_polyline\n                        )\n                    )\n                    if data:\n                        # pick closest one\n                        if data[\"polyline_proximity\"] &gt; route_data[\"polyline_proximity\"]:\n                            data = route_data\n                    else:\n                        data = route_data\n            else:\n                data = parse_route(content[\"routes\"][0])\n        else:\n            logging.info(f\"Request did not yield any routes. Status: {content['status']}\")\n            if \"error_message\" in content:\n                logging.info(f\"Error message: {content['error_message']}\")\n    else:\n        logging.warning(\n            f\"Request was not successful. Status code {response.status_code}. \"\n            f\"Content of the unsuccessful response: {response.json()}\"\n        )\n    return data\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.read_api_requests","title":"<code>read_api_requests(file_path)</code>","text":"<p>Read the Google Directions API request results stored in the <code>file_path</code> JSON file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>path to the JSON file where the google directions api requests were saved.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Loaded API request results</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def read_api_requests(file_path: str) -&gt; dict:\n    \"\"\"Read the Google Directions API request results stored in the `file_path` JSON file.\n\n    Args:\n        file_path (str): path to the JSON file where the google directions api requests were saved.\n\n    Returns:\n        dict: Loaded API request results\n    \"\"\"\n    api_requests = {}\n    with open(file_path, \"rb\") as handle:\n        json_dump = json.load(handle)\n    for key in json_dump:\n        try:\n            json_dump[key] = ast.literal_eval(json_dump[key])\n        except (ValueError, TypeError) as e:\n            logging.warning(f\"{str(key)} not processed due to {e}\")\n            continue\n        api_requests[(json_dump[key][\"path_nodes\"][0], json_dump[key][\"path_nodes\"][-1])] = (\n            json_dump[key]\n        )\n    return api_requests\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.send_requests","title":"<code>send_requests(api_requests, departure_time, traffic_model=None, key=None, secret_name=None, region_name=None)</code>","text":"Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def send_requests(\n    api_requests: dict,\n    departure_time: int,\n    traffic_model: Optional[str] = None,\n    key: Optional[str] = None,\n    secret_name: Optional[str] = None,\n    region_name: Optional[str] = None,\n):\n    if key is None:\n        key = secrets_vault.get_google_directions_api_key(secret_name, region_name)\n        if key is None:\n            raise RuntimeError(\n                \"API key was not found. Make sure you are authenticated and pointing in the correct \"\n                \"location if using AWS secrets manager, or that you have passed the correct key. \"\n                \"If using `GOOGLE_DIR_API_KEY` environmental variable, make sure you have spelled it \"\n                \"correctly. You can check this using `echo $GOOGLE_DIR_API_KEY` in the terminal you're \"\n                \"using or  `!echo $GOOGLE_DIR_API_KEY` if using jupyter notebook cells. To export the \"\n                \"key use: `export GOOGLE_DIR_API_KEY=key` (again, use ! at the beginning of the line in \"\n                \"jupyter).\"\n            )\n    for request_nodes, api_request_attribs in api_requests.items():\n        api_request_attribs[\"timestamp\"] = time.time()\n        api_request_attribs[\"request\"] = make_request(\n            api_request_attribs[\"origin\"],\n            api_request_attribs[\"destination\"],\n            key,\n            departure_time,\n            traffic_model,\n        )\n    return api_requests\n</code></pre>"},{"location":"reference/genet/utils/google_directions/#genet.utils.google_directions.send_requests_for_network","title":"<code>send_requests_for_network(n, request_number_threshold, output_dir, departure_time, traffic_model=None, key=None, secret_name=None, region_name=None)</code>","text":"<p>Generates, sends and parses results from Google Directions API for the car modal subgraph for network n.</p> <p>You can pass your API key to this function under <code>key</code> variable.</p> <p>Alternatively, you can use AWS Secrets manager for storing your API and pass secret_name and region_name (make sure you are authenticated to your AWS account).</p> <p>You can also export an environmental variable in your terminal <code>$ export GOOGLE_DIR_API_KEY='your key'</code>.</p> PARAMETER DESCRIPTION <code>n</code> <p>GeNet Network.</p> <p> TYPE: <code>Network</code> </p> <code>request_number_threshold</code> <p>max number of requests.</p> <p> TYPE: <code>int</code> </p> <code>output_dir</code> <p>output directory where to save the google directions api parsed data.</p> <p> TYPE: <code>str</code> </p> <code>departure_time</code> <p>specifies the desired time of departure, in seconds since midnight, January 1, 1970 UTC. i.e. unix time; if set to None, API will return results for average time-independent traffic conditions.</p> <p> TYPE: <code>int</code> </p> <code>traffic_model</code> <p>If given, specifies the assumptions to use when calculating time in traffic. For choices see https://developers.google.com/maps/documentation/directions/get-directions#traffic_model. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>key</code> <p>API key. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>secret_name</code> <p>If using AWS secrets manager, the name where your directions api key is stored. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p>The AWS region you operate in. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Can only make as many requests as <code>request_number</code>.</p> RETURNS DESCRIPTION <code>dict</code> <p>API request results.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/google_directions.py</code> <pre><code>def send_requests_for_network(\n    n: Network,\n    request_number_threshold: int,\n    output_dir: str,\n    departure_time: int,\n    traffic_model: Optional[str] = None,\n    key: Optional[str] = None,\n    secret_name: Optional[str] = None,\n    region_name: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Generates, sends and parses results from Google Directions API for the car modal subgraph for network n.\n\n    You can pass your API key to this function under `key` variable.\n\n    Alternatively, you can use AWS Secrets manager for storing your API and pass secret_name and region_name (make sure you are authenticated to your AWS account).\n\n    You can also export an environmental variable in your terminal `$ export GOOGLE_DIR_API_KEY='your key'`.\n\n    Args:\n        n (Network): GeNet Network.\n        request_number_threshold (int): max number of requests.\n        output_dir (str): output directory where to save the google directions api parsed data.\n        departure_time (int):\n            specifies the desired time of departure, in seconds since midnight, January 1, 1970 UTC.\n            i.e. unix time; if set to None, API will return results for average time-independent traffic conditions.\n        traffic_model (Optional[str], optional):\n            If given, specifies the assumptions to use when calculating time in traffic.\n            For choices see https://developers.google.com/maps/documentation/directions/get-directions#traffic_model.\n            Defaults to None.\n        key (Optional[str], optional): API key. Defaults to None.\n        secret_name (Optional[str], optional): If using AWS secrets manager, the name where your directions api key is stored. Defaults to None.\n        region_name (Optional[str], optional): The AWS region you operate in. Defaults to None.\n\n    Raises:\n        RuntimeError: Can only make as many requests as `request_number`.\n\n    Returns:\n        dict: API request results.\n    \"\"\"\n    logging.info(\"Generating Google Directions API requests\")\n    api_requests = generate_requests(n)\n\n    dump_all_api_requests_to_json(api_requests, output_dir)\n\n    if len(api_requests) &gt; request_number_threshold:\n        raise RuntimeError(\n            f\"Number of requests exceeded the threshold. Number of requests: {len(api_requests)}\"\n        )\n\n    logging.info(\"Sending API requests\")\n    api_requests = send_requests(\n        api_requests, departure_time, traffic_model, key, secret_name, region_name\n    )\n    logging.info(\"Parsing API requests\")\n    api_requests = parse_results(api_requests)\n\n    dump_all_api_requests_to_json(api_requests, output_dir)\n    return api_requests\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/","title":"genet.utils.graph_operations","text":""},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.Filter","title":"<code>Filter(conditions=None, how=any, mixed_dtypes=True)</code>","text":"<p>Helps filtering on specified attributes.</p> PARAMETER DESCRIPTION <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> DEFAULT: <code>None</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def __init__(\n    self,\n    conditions: Optional[\n        Union[\n            list,\n            dict[str, Union[dict, str, int, float, list, Callable[[str, int, float], bool]]],\n        ]\n    ] = None,\n    how: Callable = any,\n    mixed_dtypes: bool = True,\n):\n    \"\"\"Helps filtering on specified attributes.\n\n    Args:\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n    \"\"\"\n\n    self.conditions = conditions\n    self.how = how\n    self.mixed_dtypes = mixed_dtypes\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.Filter.conditions","title":"<code>conditions = conditions</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.Filter.how","title":"<code>how = how</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.Filter.mixed_dtypes","title":"<code>mixed_dtypes = mixed_dtypes</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.Filter.evaluate_condition","title":"<code>evaluate_condition(condition, data_dict)</code>","text":"Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def evaluate_condition(self, condition, data_dict):\n    satisfies = False\n    for key, val in condition.items():\n        if key in data_dict:\n            if isinstance(val, dict):\n                # keep going\n                satisfies = self.evaluate_condition(val, data_dict[key])\n            elif isinstance(val, (int, float, str)):\n                if isinstance(data_dict[key], (list, set)) and self.mixed_dtypes:\n                    satisfies = val in data_dict[key]\n                else:\n                    # value is that value\n                    satisfies = data_dict[key] == val\n            elif isinstance(val, (list, set)):\n                if isinstance(data_dict[key], (list, set)) and self.mixed_dtypes:\n                    if set(data_dict[key]) &amp; set(val):\n                        satisfies = True\n                else:\n                    # value is one of the items in the list\n                    satisfies = data_dict[key] in val\n            elif isinstance(val, tuple):\n                if len(val) != 2:\n                    raise AttributeError(\n                        \"Tuple defining the bound has to be a two-tuple: (lower_bound, upper_bound)\"\n                    )\n                if isinstance(data_dict[key], (list, set)) and self.mixed_dtypes:\n                    return any([val[0] &lt;= value &lt;= val[1] for value in data_dict[key]])\n                else:\n                    try:\n                        # value is within the bound\n                        satisfies = val[0] &lt;= data_dict[key] &lt;= val[1]\n                    except TypeError:\n                        # ignore types not suitable for this condition\n                        pass\n            elif callable(val):\n                if isinstance(data_dict[key], (list, set)) and self.mixed_dtypes:\n                    return any([val(value) for value in data_dict[key]])\n                else:\n                    # value is a function of data_dict[key] that returns a bool\n                    satisfies = val(data_dict[key])\n    return satisfies\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.Filter.satisfies_conditions","title":"<code>satisfies_conditions(data_dict)</code>","text":"Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def satisfies_conditions(self, data_dict):\n    if isinstance(self.conditions, list):\n        conditions_satisfied = []\n        for condition in self.conditions:\n            conditions_satisfied.append(self.evaluate_condition(condition, data_dict))\n        return self.how(conditions_satisfied)\n    elif isinstance(self.conditions, dict):\n        return self.evaluate_condition(self.conditions, data_dict)\n    elif self.conditions is None:\n        return True\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.apply_function_to_attributes","title":"<code>apply_function_to_attributes(iterator, function, location)</code>","text":"Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def apply_function_to_attributes(iterator, function, location):\n    new_attributes = {}\n    for item_id, item_attribs in iterator:\n        try:\n            new_attributes[item_id] = {location: function(item_attribs)}\n        except KeyError:\n            # Not all items are required to work with the function. Fail silently and only apply\n            # to relevant items\n            pass\n    return new_attributes\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.apply_mapping_to_attributes","title":"<code>apply_mapping_to_attributes(iterator, mapping, location)</code>","text":"Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def apply_mapping_to_attributes(iterator, mapping, location):\n    new_attributes = {}\n    # assumes mapping at the same location\n    for item_id, item_attribs in iterator:\n        try:\n            new_attributes[item_id] = {location: mapping[item_attribs[location]]}\n        except KeyError:\n            # Not all items are required to work with the mapping. Fail silently and only apply\n            # to relevant items\n            pass\n    if (not new_attributes) and mapping:\n        logging.warning(\n            f\"Mapping attributes resulted in 0 changes. Ensure your location variable: {location} exists \"\n            f\"as keys in the input dictionaries. Only dictionaries with location={location} keys will be \"\n            \"mapped.\"\n        )\n    return new_attributes\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.apply_to_attributes","title":"<code>apply_to_attributes(iterator, to_apply, location)</code>","text":"Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def apply_to_attributes(iterator, to_apply, location):\n    if isinstance(to_apply, dict):\n        return apply_mapping_to_attributes(iterator, to_apply, location)\n    else:\n        return apply_function_to_attributes(iterator, to_apply, location)\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.build_attribute_dataframe","title":"<code>build_attribute_dataframe(iterator, keys, index_name=None)</code>","text":"<p>Builds a pandas.DataFrame from data in iterator.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>iterator or list of tuples (id, dictionary data with keys of interest).</p> <p> TYPE: <code>Iterable</code> </p> <code>keys</code> <p>keys to extract data from. Can be a string, list or dictionary/list of dictionaries if accessing nested dictionaries, for example on using dictionaries see <code>get_attribute_data_under_key</code> docstring.</p> <p> TYPE: <code>Union[list, dict, str]</code> </p> <code>index_name</code> <p>Name of returned dataframe index. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Attribute dataframe.</p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def build_attribute_dataframe(\n    iterator: Iterable, keys: Union[list, dict, str], index_name: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"Builds a pandas.DataFrame from data in iterator.\n\n    Args:\n        iterator (Iterable): iterator or list of tuples (id, dictionary data with keys of interest).\n        keys (Union[list, dict, str]):\n            keys to extract data from.\n            Can be a string, list or dictionary/list of dictionaries if accessing nested dictionaries, for example on using dictionaries see `get_attribute_data_under_key` docstring.\n        index_name (Optional[str], optional): Name of returned dataframe index. Defaults to None.\n\n    Returns:\n        pd.DataFrame: Attribute dataframe.\n    \"\"\"\n    df = pd.DataFrame()\n    if isinstance(keys, str):\n        keys = [keys]\n    if len(keys) &gt; 1:\n        iterator = list(iterator)\n    for key in keys:\n        if isinstance(key, dict):\n            # consolidate nestedness to get a name for the column\n            name = dict_support.dict_to_string(key)\n        else:\n            name = key\n\n        attribute_data = get_attribute_data_under_key(iterator, key)\n        col_series = pd.Series(attribute_data, dtype=pd_helpers.get_pandas_dtype(attribute_data))\n        col_series.name = name\n\n        df = df.merge(pd.DataFrame(col_series), left_index=True, right_index=True, how=\"outer\")\n    if index_name is not None:\n        df.index = df.index.set_names([index_name])\n    return df\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.consolidate_link_indices","title":"<code>consolidate_link_indices(left, right)</code>","text":"<p>Changes the link indexing in right to match left on modes stored on the links and resolves clashing link ids if they don't match.</p> <p>This method assumes that the node ids of left vs right have already been consolidated (see <code>consolidate_node_indices</code>, which consolidates node ids).</p> PARAMETER DESCRIPTION <code>left</code> <p>GeNet network.</p> <p> TYPE: <code>Network</code> </p> <code>right</code> <p>GeNet network that needs to be updated to match left network.</p> <p> TYPE: <code>Network</code> </p> RETURNS DESCRIPTION <code>Network</code> <p>Updated <code>right</code> network.</p> <p> TYPE: <code>Network</code> </p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def consolidate_link_indices(left: Network, right: Network) -&gt; Network:\n    \"\"\"Changes the link indexing in right to match left on modes stored on the links and resolves clashing link ids if they don't match.\n\n    This method assumes that the node ids of left vs right have already been consolidated (see `consolidate_node_indices`, which consolidates node ids).\n\n    Args:\n        left (Network): GeNet network.\n        right (Network): GeNet network that needs to be updated to match left network.\n\n    Returns:\n        Network: Updated `right` network.\n    \"\"\"\n\n    def sort_and_hash(modes_list):\n        modes_list.sort()\n        return \"_\".join(modes_list)\n\n    def extract_multindex(link_id, graph):\n        return graph.link_id_mapping[link_id][\"multi_edge_idx\"]\n\n    def get_edges_with_clashing_ids(group):\n        if (\n            (group.dropna()[\"link_id_right\"] != group.dropna()[\"link_id_left\"])\n            | (group.dropna()[\"multi_idx_right\"] != group.dropna()[\"multi_idx_left\"])\n        ).any():\n            return group\n        elif group.dropna().empty:\n            clashing_multi_idx = set(group[\"multi_idx_right\"].dropna()) &amp; set(\n                group[\"multi_idx_left\"].dropna()\n            )\n            if clashing_multi_idx:\n                return group\n\n    def append_data_to_overlapping_links_data(row):\n        if not row.empty:\n            overlapping_links_data[row[\"link_id_left\"]] = right.link(row[\"link_id_right\"])\n\n    def append_data_to_unique_clashing_links_data(row):\n        if not row.empty:\n            unique_clashing_links_data[row[\"link_id_right\"]] = right.link(row[\"link_id_right\"])\n\n    # Now consolidate link ids, we do a similar dataframe join as for nodes but on edge data and nodes the edges\n    # connect instead of spatial\n    left_df = left.link_attribute_data_under_keys([\"modes\", \"from\", \"to\", \"id\"], index_name=\"left\")\n    # extract multi index and hash modes\n    left_df[\"multi_idx\"] = left_df[\"id\"].apply(lambda x: extract_multindex(x, left))\n    left_df[\"modes\"] = left_df[\"modes\"].apply(lambda x: sort_and_hash(x))\n    left_df = left_df.rename(columns={\"id\": \"link_id\"})\n    right_df = right.link_attribute_data_under_keys(\n        [\"modes\", \"from\", \"to\", \"id\"], index_name=\"right\"\n    )\n    # extract multi index and hash modes\n    right_df[\"multi_idx\"] = right_df[\"id\"].apply(lambda x: extract_multindex(x, right))\n    right_df[\"modes\"] = right_df[\"modes\"].apply(lambda x: sort_and_hash(x))\n    right_df = right_df.rename(columns={\"id\": \"link_id\"})\n\n    df = left_df.reset_index().merge(\n        right_df.reset_index(),\n        on=[\"modes\", \"from\", \"to\"],\n        how=\"outer\",\n        suffixes=(\"_left\", \"_right\"),\n    )\n\n    # In the dataframe above we have combined to compare edges which have the same from and to nodes and the same modes\n    # on the edge. Remember these graphs have multi edges, there could be more than one edge between two nodes.\n    # There are a few different scenarios here, if edges have found a match on mode, and nodes\n    # - link ids match and multi indices match\n    # - link ids match but the multi indices dont match\n    # - link ids dont match but multi indices do match\n    # - neither link ids or multi indices match, but the edge is the same in terms of mode and from/to nodes\n    # Similarly, there are a few scenarios if the edges didn't find a match\n    # - remaining (unmatched) link ids for edges in right are unique, don't clash with left,\n    # they will remain as they are\n    # - link ids clash with left\n\n    # remove all edges that match and clash, we will re-add them later\n    # this includes multiedges of edges that may have matched only one multiedge or no multi edges at all, i.e. the\n    # graphs that multi edges that are completely separate but clash in the multi index\n    # ---this is to consolidate the multindices across left and right\n    clashing_overlapping_edges = (\n        df.groupby([\"from\", \"to\"]).apply(get_edges_with_clashing_ids).reset_index(drop=True)\n    )\n    # store the edge data from right\n    overlapping_links_data: dict = {}\n    unique_clashing_links_data: dict = {}\n    if not clashing_overlapping_edges.empty:\n        clashing_overlapping_edges[\n            clashing_overlapping_edges[\"link_id_right\"].notna()\n            &amp; clashing_overlapping_edges[\"link_id_left\"].notna()\n        ].apply(lambda row: append_data_to_overlapping_links_data(row), axis=1)\n        clashing_overlapping_edges[\n            clashing_overlapping_edges[\"link_id_right\"].notna()\n            &amp; clashing_overlapping_edges[\"link_id_left\"].isna()\n        ].apply(lambda row: append_data_to_unique_clashing_links_data(row), axis=1)\n\n        right.remove_links(set(clashing_overlapping_edges[\"link_id_right\"].dropna()))\n\n    # resolve clashing link ids for links in right which don't exist in left\n    clashing_right_link_ids = set(df[df[\"left\"].isna()][\"link_id_right\"]) &amp; set(\n        df[\"link_id_left\"].dropna()\n    )\n    # some link ids could have been picked up before and deleted, only consider the ones which don't overlap\n    clashing_right_link_ids = set(right.link_id_mapping.keys()) &amp; clashing_right_link_ids\n    if clashing_right_link_ids:\n        # generate the index avoiding indices from left, that way they're unique across both graphs\n        [\n            right.reindex_link(\n                link, right.generate_index_for_edge(set(left.link_id_mapping.keys()))\n            )\n            for link in clashing_right_link_ids\n        ]\n\n    # Impose link id and multi index if from left on right, basically add the links we deleted from right but using\n    # left's indexing, keep the data from right using the dictionaries where we saved them\n    for left_link_id, data in overlapping_links_data.items():\n        u, v = left.link_id_mapping[left_link_id][\"from\"], left.link_id_mapping[left_link_id][\"to\"]\n        multi_idx = left.link_id_mapping[left_link_id][\"multi_edge_idx\"]\n        right.add_link(left_link_id, u, v, multi_idx, data, silent=True)\n\n    for right_link_id, data in unique_clashing_links_data.items():\n        u, v = data[\"from\"], data[\"to\"]\n        # generate unique multi index, unique in both left and right\n        right_multi_idx = set()\n        if right.graph.has_edge(u, v):\n            right_multi_idx = set(right.graph[u][v].keys())\n        left_multi_idx = set()\n        if left.graph.has_edge(u, v):\n            left_multi_idx = set(left.graph[u][v].keys())\n        existing_multi_edge_ids = right_multi_idx | left_multi_idx\n        multi_idx = next(filterfalse(set(existing_multi_edge_ids).__contains__, count(1)))\n        if right_link_id in set(left.link_id_mapping.keys()) | set(right.link_id_mapping.keys()):\n            right_link_id = right.generate_index_for_edge(set(left.link_id_mapping.keys()))\n        right.add_link(right_link_id, u, v, multi_idx, data, silent=True)\n\n    logging.info(\"Finished consolidating link indexing between the two graphs\")\n    return right\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.consolidate_node_indices","title":"<code>consolidate_node_indices(left, right)</code>","text":"<p>Changes the node indexing in right to match left spatially and resolves clashing node ids if they don't match spatially.</p> <p>The two networks need to be in matching coordinate systems.</p> PARAMETER DESCRIPTION <code>left</code> <p>GeNet network.</p> <p> TYPE: <code>Network</code> </p> <code>right</code> <p>GeNet network that needs to be updated to match left network.</p> <p> TYPE: <code>Network</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Nodes must be spatially unique.</p> RETURNS DESCRIPTION <code>Network</code> <p>Updated <code>right</code> network.</p> <p> TYPE: <code>Network</code> </p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def consolidate_node_indices(left: Network, right: Network) -&gt; Network:\n    \"\"\"Changes the node indexing in right to match left spatially and resolves clashing node ids if they don't match spatially.\n\n    The two networks need to be in matching coordinate systems.\n\n    Args:\n        left (Network): GeNet network.\n        right (Network): GeNet network that needs to be updated to match left network.\n\n    Raises:\n        RuntimeError: Nodes must be spatially unique.\n\n    Returns:\n        Network: Updated `right` network.\n    \"\"\"\n    # find spatially overlapping nodes by extracting all of the s2 spatial ids from right\n    s2_ids_right = right.node_attribute_data_under_key(\"s2_id\")\n    if len(s2_ids_right) != len(s2_ids_right.unique()):\n        raise RuntimeError(\n            \"There is more than one node in one place in the network you are trying to add\"\n        )\n    s2_ids_right.name = \"s2_id\"\n    s2_ids_right.index = s2_ids_right.index.set_names([\"right\"])\n    s2_ids_left = left.node_attribute_data_under_key(\"s2_id\")\n    # do the same for left\n    if len(s2_ids_left) != len(s2_ids_left.unique()):\n        raise RuntimeError(\n            \"There is more than one node in one place in the network you are trying to add\"\n        )\n    s2_ids_left.name = \"s2_id\"\n    s2_ids_left.index = s2_ids_left.index.set_names([\"left\"])\n    # combine spatial info on nodes in left and right into a dataframe, join on s2 ids\n    s2_id_df = (\n        pd.DataFrame(s2_ids_right)\n        .reset_index()\n        .merge(pd.DataFrame(s2_ids_left).reset_index(), on=\"s2_id\", how=\"outer\")\n    )\n\n    # check uniqueness of the node indices that are left in right\n    clashing_right_node_ids = set(s2_id_df[s2_id_df[\"left\"].isna()][\"right\"]) &amp; set(\n        s2_id_df[\"left\"].dropna()\n    )\n    if clashing_right_node_ids:\n        # generate the index avoiding indices from left, that way they're unique across both graphs\n        [\n            right.reindex_node(node, right.generate_index_for_node([i for i, a in left.nodes()]))\n            for node in clashing_right_node_ids\n        ]\n\n    # finally change node ids for overlapping nodes\n    # TODO check that a new index is not being generated if an index exists in right but hasnt been overwritten yet\n    [\n        right.reindex_node(s2_id_df.loc[idx, \"right\"], s2_id_df.loc[idx, \"left\"])\n        for idx in s2_id_df.dropna()[s2_id_df[\"right\"] != s2_id_df[\"left\"]].index\n    ]\n    logging.info(\"Finished consolidating node indexing between the two graphs\")\n    return right\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.convert_list_of_link_ids_to_network_nodes","title":"<code>convert_list_of_link_ids_to_network_nodes(network, link_ids)</code>","text":"<p>Extracts nodes corresponding to link ids in the order of given link_ids list.</p> <p>Useful for extracting network routes.</p> PARAMETER DESCRIPTION <code>network</code> <p>GeNet network.</p> <p> TYPE: <code>Network</code> </p> <code>link_ids</code> <p>Link IDs whose nodes are to be extracted.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Node IDs.</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def convert_list_of_link_ids_to_network_nodes(network: Network, link_ids: list) -&gt; list:\n    \"\"\"Extracts nodes corresponding to link ids in the order of given link_ids list.\n\n    Useful for extracting network routes.\n\n    Args:\n        network (Network): GeNet network.\n        link_ids (list): Link IDs whose nodes are to be extracted.\n\n    Returns:\n        list: Node IDs.\n    \"\"\"\n    paths: list = []\n    connected_path: list = []\n    for link_id in link_ids:\n        x, y = network.link_id_mapping[link_id][\"from\"], network.link_id_mapping[link_id][\"to\"]\n        if not connected_path:\n            connected_path = [x, y]\n        elif connected_path[-1] != x:\n            paths.append(connected_path)\n            connected_path = [x, y]\n        else:\n            connected_path.append(y)\n    paths.append(connected_path)\n    return paths\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.extract_on_attributes","title":"<code>extract_on_attributes(iterator, conditions, how=any, mixed_dtypes=True)</code>","text":"<p>Extracts ids in iterator based on values of attributes attached to the items.</p> <p>Fails silently, assumes not all items have those attributes. In the case were the attributes stored are a list or set, like in the case of a simplified network (there will be a mix of objects that are sets and not), an intersection of values satisfying condition(s) is considered in case of iterable value, if not empty, it is deemed successful by default. To disable this behaviour set mixed_dtypes to False.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>list or set of two-tuples: (id of the item, attributes of the item)</p> <p> TYPE: <code>Iterator[tuple[str, dict]]</code> </p> <code>conditions</code> <p>{'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}}, where 'target_value' could be:</p> <ul> <li> <p>single value, string, int, float, where the edge_data[key] == value (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])</p> </li> <li> <p>list or set of single values as above, where edge_data[key] in [value1, value2] (if mixed_dtypes==True and in case of set/list edge_data[key], set(edge_data[key]) &amp; set([value1, value2]) is non-empty)</p> </li> <li> <p>for int or float values, two-tuple bound (lower_bound, upper_bound) where lower_bound &lt;= edge_data[key] &lt;= upper_bound (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)</p> </li> <li> <p>function that returns a boolean given the value e.g. <pre><code>def below_exclusive_upper_bound(value):\n    return value &lt; 100\n</code></pre> (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in edge_data[key] returns True after applying function)</p> </li> </ul> <p> TYPE: <code>Union[list, dict]</code> </p> <code>how</code> <p>The level of rigour used to match conditions. Defaults to any. - all: means all conditions need to be met - any: means at least one condition needs to be met</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>any</code> </p> <code>mixed_dtypes</code> <p>If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list</code> <p>list of ids in input iterator satisfying conditions</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def extract_on_attributes(\n    iterator: Iterator[tuple[str, dict]],\n    conditions: Union[list, dict],\n    how: Callable = any,\n    mixed_dtypes: bool = True,\n) -&gt; list:\n    \"\"\"Extracts ids in iterator based on values of attributes attached to the items.\n\n    Fails silently, assumes not all items have those attributes.\n    In the case were the attributes stored are a list or set,\n    like in the case of a simplified network (there will be a mix of objects that are sets and not),\n    an intersection of values satisfying condition(s) is considered in case of iterable value, if not empty, it is deemed successful by default.\n    To disable this behaviour set mixed_dtypes to False.\n\n    Args:\n        iterator (Iterator[tuple[str, dict]]): list or set of two-tuples: (id of the item, attributes of the item)\n        conditions (Union[list, dict]):\n            {'attribute_key': 'target_value'} or nested {'attribute_key': {'another_key': {'yet_another_key': 'target_value'}}},\n            where 'target_value' could be:\n\n            - single value, string, int, float, where the edge_data[key] == value\n            (if mixed_dtypes==True and in case of set/list edge_data[key], value is in edge_data[key])\n\n            - list or set of single values as above, where edge_data[key] in [value1, value2]\n            (if mixed_dtypes==True and in case of set/list edge_data[key],\n            set(edge_data[key]) &amp; set([value1, value2]) is non-empty)\n\n            - for int or float values, two-tuple bound (lower_bound, upper_bound) where\n            lower_bound &lt;= edge_data[key] &lt;= upper_bound\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] satisfies lower_bound &lt;= item &lt;= upper_bound)\n\n            - function that returns a boolean given the value e.g.\n            ```python\n            def below_exclusive_upper_bound(value):\n                return value &lt; 100\n            ```\n            (if mixed_dtypes==True and in case of set/list edge_data[key], at least one item in\n            edge_data[key] returns True after applying function)\n\n        how (Callable, optional):\n            The level of rigour used to match conditions. Defaults to any.\n            - all: means all conditions need to be met\n            - any: means at least one condition needs to be met\n\n        mixed_dtypes (bool, optional):\n            If True, will consider the intersection of single values or lists of values in queried dictionary keys, e.g. as in simplified networks.\n            Defaults to True.\n\n    Returns:\n        list: list of ids in input iterator satisfying conditions\n    \"\"\"\n    filter = Filter(conditions, how, mixed_dtypes)\n    return [_id for _id, attribs in iterator if filter.satisfies_conditions(attribs)]\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.find_shortest_path_link","title":"<code>find_shortest_path_link(link_attribute_dictionary, modes=None)</code>","text":"<p>Finds link that is deemed quickest if freespeed present.</p> <p>Relies on (link) id being stored on edge data (default if using genet Network's <code>add_link</code> or <code>add_edge</code> methods or reading data using genet's Network methods.) Throws a <code>RuntimeError</code> if a link id is not found.</p> PARAMETER DESCRIPTION <code>link_attribute_dictionary</code> <p>Link attribute dictionary, e.g. <code>{multi_index_id: {'length': 10}}</code>.</p> <p> TYPE: <code>dict</code> </p> <code>modes</code> <p>If passed and there is more than one possible edge that has the same length and speed, will also check if there is a link with modes that match exactly with <code>modes</code>. Defaults to None.</p> <p> TYPE: <code>Optional[Union[list, str]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Link ID must exist.</p> RETURNS DESCRIPTION <code>str</code> <p>Shortest path link ID</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def find_shortest_path_link(\n    link_attribute_dictionary: dict, modes: Optional[Union[list, str]] = None\n) -&gt; str:\n    \"\"\"Finds link that is deemed quickest if freespeed present.\n\n    Relies on (link) id being stored on edge data (default if using genet Network's `add_link` or `add_edge` methods or reading data using genet's Network methods.)\n    Throws a `RuntimeError` if a link id is not found.\n\n    Args:\n        link_attribute_dictionary (dict): Link attribute dictionary, e.g. `{multi_index_id: {'length': 10}}`.\n        modes (Optional[Union[list, str]], optional):\n            If passed and there is more than one possible edge that has the same length and speed, will also check if there is a link with modes that match exactly with `modes`.\n            Defaults to None.\n\n    Raises:\n        RuntimeError: Link ID must exist.\n\n    Returns:\n        str: Shortest path link ID\n    \"\"\"\n    selected_link = None\n    if len(link_attribute_dictionary) &gt; 1:\n        # check if any link is better than the other\n        if modes:\n            for multi_idx, attribs in link_attribute_dictionary.items():\n                if \"modes\" in attribs:\n                    if isinstance(modes, str):\n                        modes = [modes]\n                    if set(attribs[\"modes\"]) == set(modes):\n                        selected_link = attribs[\"id\"]\n        if selected_link is None:\n            current_freespeed = None\n            for multi_idx, attribs in link_attribute_dictionary.items():\n                if \"freespeed\" in attribs:\n                    if current_freespeed is None:\n                        current_freespeed = attribs[\"freespeed\"]\n                        selected_link = attribs[\"id\"]\n                    elif attribs[\"freespeed\"] &gt; current_freespeed:\n                        current_freespeed = attribs[\"freespeed\"]\n                        selected_link = attribs[\"id\"]\n    else:\n        selected_link = link_attribute_dictionary[list(link_attribute_dictionary.keys())[0]][\"id\"]\n    if selected_link is None:\n        raise RuntimeError(\"Failed to find suitable link_id for shortest path\")\n    else:\n        return selected_link\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.get_attribute_data_under_key","title":"<code>get_attribute_data_under_key(iterator, key)</code>","text":"<p>Returns all data stored under key in attribute dictionaries for iterators yielding (index, attribute_dictionary).</p> <p>Inherits index from the iterator.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>list or iterator yielding (index, attribute_dictionary)</p> <p> TYPE: <code>Iterable</code> </p> <code>key</code> <p>A string, e.g. 'modes'. A dictionary, if accessing nested information, e.g. <code>{'attributes': 'osm:way:name'}</code> or <code>{'attributes': {'osm:way:name': 'text'}}</code>.</p> <p> TYPE: <code>Union[str, dict]</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>dictionary where keys are indices and values are data stored under the key</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def get_attribute_data_under_key(iterator: Iterable, key: Union[str, dict]) -&gt; dict:\n    \"\"\"Returns all data stored under key in attribute dictionaries for iterators yielding (index, attribute_dictionary).\n\n    Inherits index from the iterator.\n\n    Args:\n        iterator (Iterable): list or iterator yielding (index, attribute_dictionary)\n        key (Union[str, dict]):\n            A string, e.g. 'modes'.\n            A dictionary, if accessing nested information, e.g. `{'attributes': 'osm:way:name'}` or `{'attributes': {'osm:way:name': 'text'}}`.\n\n    Returns:\n        dict: dictionary where keys are indices and values are data stored under the key\n    \"\"\"\n\n    def get_the_data(attributes, key):\n        if isinstance(key, dict):\n            for k, v in key.items():\n                if k in attributes:\n                    if isinstance(v, dict):\n                        get_the_data(attributes[k], v)\n                    elif v in attributes[k]:\n                        data[_id] = attributes[k][v]\n        else:\n            if key in attributes:\n                data[_id] = attributes[key]\n\n    data: dict = {}\n\n    for _id, _attribs in iterator:\n        get_the_data(_attribs, key)\n\n    return data\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.get_attribute_schema","title":"<code>get_attribute_schema(iterator, data=False)</code>","text":"Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def get_attribute_schema(iterator, data=False):\n    def get_identical_twin_if_exists(parent, name_of_node_to_be):\n        for child in parent.children:\n            if name_of_node_to_be == child.name:\n                return child\n        return None\n\n    def append_to_tree(d: dict, parent):\n        for k, v in d.items():\n            twin = get_identical_twin_if_exists(parent, k)\n            if isinstance(v, dict):\n                if not twin:\n                    twin = Node(k, parent=parent)\n                append_to_tree(v, twin)\n            elif not twin:\n                if data:\n                    if isinstance(v, (list, set)):\n                        values = set(v)\n                    else:\n                        values = {v}\n                    Node(k, parent=parent, values=values)\n                else:\n                    Node(k, parent=parent)\n            elif data:\n                node = get_identical_twin_if_exists(parent, k)\n                if isinstance(v, (list, set)):\n                    values = set(v)\n                else:\n                    values = {v}\n                node.values = node.values | values\n\n    root = Node(\"attribute\")\n\n    for _id, _attribs in iterator:\n        append_to_tree(_attribs, root)\n\n    return root\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.parse_leaf","title":"<code>parse_leaf(leaf)</code>","text":"PARAMETER DESCRIPTION <code>leaf</code> <p>Leaf node.</p> <p> TYPE: <code>Node</code> </p> RETURNS DESCRIPTION <code>Union[str, dict]</code> <p>Union[str, dict]: str or dictionary with string key value pairs, for use as keys to extraction methods.</p> Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def parse_leaf(leaf: Node) -&gt; Union[str, dict]:\n    \"\"\"\n\n    Args:\n        leaf (Node): Leaf node.\n\n    Returns:\n        Union[str, dict]: str or dictionary with string key value pairs, for use as keys to extraction methods.\n    \"\"\"\n    if leaf.depth &gt; 1:\n        dict_path = {leaf.path[1].name: leaf.path[2].name}\n        if leaf.depth &gt; 2:\n            for node in leaf.path[3:]:\n                dict_path = dict_support.nest_at_leaf(dict_path, node.name)\n        return dict_path\n    else:\n        return leaf.name\n</code></pre>"},{"location":"reference/genet/utils/graph_operations/#genet.utils.graph_operations.render_tree","title":"<code>render_tree(root, data=False)</code>","text":"Source code in <code>src/genet/utils/graph_operations.py</code> <pre><code>def render_tree(root, data=False):\n    for pre, fill, node in RenderTree(root):\n        if hasattr(node, \"values\") and data:\n            print(\"%s%s: %s\" % (pre, node.name, list(node.values)[:5]))\n        else:\n            print(\"%s%s\" % (pre, node.name))\n</code></pre>"},{"location":"reference/genet/utils/io/","title":"genet.utils.io","text":""},{"location":"reference/genet/utils/io/#genet.utils.io.SUPPORTED_FILE_FORMATS","title":"<code>SUPPORTED_FILE_FORMATS = ['parquet', 'geoparquet', 'geojson', 'shp', 'shapefile']</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/io/#genet.utils.io.check_file_type_is_supported","title":"<code>check_file_type_is_supported(filetype)</code>","text":"<p>Checks there is support for the given file type</p> PARAMETER DESCRIPTION <code>filetype</code> <p>The file type to save a spatial object to.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p><code>filetype</code> is not a supported file type</p> Source code in <code>src/genet/utils/io.py</code> <pre><code>def check_file_type_is_supported(filetype: str):\n    \"\"\"Checks there is support for the given file type\n\n    Args:\n        filetype (str, optional): The file type to save a spatial object to.\n\n    Raises:\n        RuntimeError: `filetype` is not a supported file type\n    \"\"\"\n    if filetype.lower() not in SUPPORTED_FILE_FORMATS:\n        raise RuntimeError(\n            f\"{filetype} is not a supported file type: {', '.join(SUPPORTED_FILE_FORMATS)}\"\n        )\n</code></pre>"},{"location":"reference/genet/utils/io/#genet.utils.io.save_geodataframe","title":"<code>save_geodataframe(gdf, filename, output_dir, filetype='parquet')</code>","text":"<p>Saves geopandas.GeoDataFrame to the requested file format</p> PARAMETER DESCRIPTION <code>gdf</code> <p>GeoDataFrame to save to disk.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>filename</code> <p>Name of the file, without extension.</p> <p> TYPE: <code>str</code> </p> <code>output_dir</code> <p>Path to folder where to save the file.</p> <p> TYPE: <code>str</code> </p> <code>filetype</code> <p>The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported. Defaults to parquet format.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parquet'</code> </p> Source code in <code>src/genet/utils/io.py</code> <pre><code>def save_geodataframe(\n    gdf: gpd.GeoDataFrame, filename: str, output_dir: str, filetype: str = \"parquet\"\n):\n    \"\"\"Saves geopandas.GeoDataFrame to the requested file format\n\n    Args:\n        gdf (gpd.GeoDataFrame): GeoDataFrame to save to disk.\n        filename (str): Name of the file, without extension.\n        output_dir (str): Path to folder where to save the file.\n        filetype (str, optional):\n            The file type to save the GeoDataFrame to: geojson, geoparquet or shp are supported.\n            Defaults to parquet format.\n    \"\"\"\n    if not gdf.empty:\n        check_file_type_is_supported(filetype)\n\n        _gdf = sanitiser.sanitise_geodataframe(gdf.copy())\n        persistence.ensure_dir(output_dir)\n\n        if filetype.lower() in [\"parquet\", \"geoparquet\"]:\n            _gdf.to_parquet(os.path.join(output_dir, f\"{filename}.parquet\"))\n        elif filetype.lower() == \"geojson\":\n            _gdf.to_file(\n                os.path.join(output_dir, f\"{filename}.geojson\"), driver=\"GeoJSON\", engine=\"pyogrio\"\n            )\n        elif filetype.lower() in [\"shp\", \"shapefile\"]:\n            for col in [col for col in _gdf.columns if is_datetime(_gdf[col])]:\n                _gdf[col] = _gdf[col].astype(str)\n            _gdf.to_file(os.path.join(output_dir, f\"{filename}.shp\"))\n</code></pre>"},{"location":"reference/genet/utils/java_dtypes/","title":"genet.utils.java_dtypes","text":""},{"location":"reference/genet/utils/java_dtypes/#genet.utils.java_dtypes.JAVA_DTYPE_MAP","title":"<code>JAVA_DTYPE_MAP = {'java.lang.Array': list, 'java.lang.Boolean': bool, 'java.lang.Double': float, 'java.lang.Float': float, 'java.lang.Long': float, 'java.lang.Integer': int, 'java.lang.Byte': int, 'java.lang.Short': int, 'java.lang.Char': str, 'java.lang.String': str}</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/java_dtypes/#genet.utils.java_dtypes.PYTHON_DTYPE_MAP","title":"<code>PYTHON_DTYPE_MAP = {list: 'java.lang.Array', set: 'java.lang.Array', bool: 'java.lang.Boolean', float: 'java.lang.Float', int: 'java.lang.Integer', str: 'java.lang.String'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/java_dtypes/#genet.utils.java_dtypes.java_to_python_dtype","title":"<code>java_to_python_dtype(java_dtype)</code>","text":"Source code in <code>src/genet/utils/java_dtypes.py</code> <pre><code>def java_to_python_dtype(java_dtype: str) -&gt; type:\n    if java_dtype in JAVA_DTYPE_MAP:\n        return JAVA_DTYPE_MAP[java_dtype]\n    else:\n        raise NotImplementedError(\n            f\"Java type: {java_dtype} is not understood. The following Java data types are \"\n            f\"supported: {list(JAVA_DTYPE_MAP)}\"\n        )\n</code></pre>"},{"location":"reference/genet/utils/java_dtypes/#genet.utils.java_dtypes.python_to_java_dtype","title":"<code>python_to_java_dtype(python_dtype)</code>","text":"Source code in <code>src/genet/utils/java_dtypes.py</code> <pre><code>def python_to_java_dtype(python_dtype: type) -&gt; str:\n    if python_dtype in PYTHON_DTYPE_MAP:\n        return PYTHON_DTYPE_MAP[python_dtype]\n    else:\n        raise NotImplementedError(\n            f\"Python type: {python_dtype} is not recognised or implemented to be mapped to a \"\n            f\"Java type. The following types are supported: {list(PYTHON_DTYPE_MAP)}\"\n        )\n</code></pre>"},{"location":"reference/genet/utils/pandas_helpers/","title":"genet.utils.pandas_helpers","text":""},{"location":"reference/genet/utils/pandas_helpers/#genet.utils.pandas_helpers.get_pandas_dtype","title":"<code>get_pandas_dtype(dict)</code>","text":"Source code in <code>src/genet/utils/pandas_helpers.py</code> <pre><code>def get_pandas_dtype(dict):\n    pandas_dtype = object\n    if dict:\n        first_value = list(dict.values())[0]\n        python_type = type(first_value)\n        if python_type is int:\n            pandas_dtype = pd.Int64Dtype.type\n        if python_type is float:\n            pandas_dtype = pd.Float64Dtype.type\n    return pandas_dtype\n</code></pre>"},{"location":"reference/genet/utils/pandas_helpers/#genet.utils.pandas_helpers.notna","title":"<code>notna(value)</code>","text":"Source code in <code>src/genet/utils/pandas_helpers.py</code> <pre><code>def notna(value):\n    nn = pd.notna(value)\n    if isinstance(nn, ndarray):\n        return any(nn)\n    return nn\n</code></pre>"},{"location":"reference/genet/utils/parallel/","title":"genet.utils.parallel","text":""},{"location":"reference/genet/utils/parallel/#genet.utils.parallel.T","title":"<code>T = TypeVar('T', bound=Iterable)</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/parallel/#genet.utils.parallel.combine_dict","title":"<code>combine_dict(list_dict)</code>","text":"<p>Flattens list of dicts into a single dict.</p> PARAMETER DESCRIPTION <code>list_dict</code> <p>list of dicts to flatten.</p> <p> TYPE: <code>list[dict]</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Flattened dict.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/utils/parallel.py</code> <pre><code>def combine_dict(list_dict: list[dict]) -&gt; dict:\n    \"\"\"Flattens list of dicts into a single dict.\n\n    Args:\n        list_dict (list[dict]): list of dicts to flatten.\n\n    Returns:\n        dict: Flattened dict.\n    \"\"\"\n    return_dict: dict = {}\n    for res in list_dict:\n        return_dict = {**return_dict, **res}\n    return return_dict\n</code></pre>"},{"location":"reference/genet/utils/parallel/#genet.utils.parallel.combine_list","title":"<code>combine_list(list_list)</code>","text":"<p>Flattens list of lists into a single list.</p> PARAMETER DESCRIPTION <code>list_list</code> <p>list of lists to flatten.</p> <p> TYPE: <code>list[list]</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Flattened list.</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/genet/utils/parallel.py</code> <pre><code>def combine_list(list_list: list[list]) -&gt; list:\n    \"\"\"Flattens list of lists into a single list.\n\n    Args:\n        list_list (list[list]): list of lists to flatten.\n\n    Returns:\n        list: Flattened list.\n    \"\"\"\n    return_list = []\n    for res in list_list:\n        return_list.extend(res)\n    return return_list\n</code></pre>"},{"location":"reference/genet/utils/parallel/#genet.utils.parallel.multiprocess_wrap","title":"<code>multiprocess_wrap(data, split, apply, combine, processes=1, **kwargs)</code>","text":"<p>Batch process data using a <code>split-apply-combine</code> approach.</p> <p>Results of all parallel processes are consolidated using the given <code>combine</code> function.</p> PARAMETER DESCRIPTION <code>data</code> <p>Data the <code>apply</code> function expects, which will be partitioned by <code>split</code> function if the number of parallel <code>processes</code> &gt; 1.</p> <p> TYPE: <code>Iterable</code> </p> <code>split</code> <p>Function which partitions <code>data</code> into list of batches of same type as <code>data</code> to be processed in parallel. <code>processes</code> argument must be greater than 1 if you want data to be split.</p> <p> TYPE: <code>Callable</code> </p> <code>apply</code> <p>Function that expects <code>data</code> or a subset of it (if <code>data</code> has been split).</p> <p> TYPE: <code>Callable</code> </p> <code>combine</code> <p>Function which expects a list of the returns of function <code>apply</code> and combines it back into what <code>apply</code> would have returned if it had been run in a single process.</p> <p> TYPE: <code>Callable</code> </p> <code>processes</code> <p>Max number of processes to use for computations. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <p>Keyword Args: will be passed to the <code>apply</code> function.</p> RETURNS DESCRIPTION <code>Iterable</code> <p>output of (in order of application) <code>split</code>, <code>apply</code>, then <code>combine</code> functions.</p> <p> TYPE: <code>T</code> </p> Source code in <code>src/genet/utils/parallel.py</code> <pre><code>def multiprocess_wrap(\n    data: T, split: Callable, apply: Callable, combine: Callable, processes: int = 1, **kwargs\n) -&gt; T:\n    \"\"\"Batch process data using a `split-apply-combine` approach.\n\n    Results of all parallel processes are consolidated using the given `combine` function.\n\n    Args:\n        data (Iterable): Data the `apply` function expects, which will be partitioned by `split` function if the number of parallel `processes` &gt; 1.\n        split (Callable):\n            Function which partitions `data` into list of batches of same type as `data` to be processed in parallel.\n            `processes` argument must be greater than 1 if you want data to be split.\n        apply (Callable): Function that expects `data` or a subset of it (if `data` has been split).\n        combine (Callable):\n            Function which expects a list of the returns of function `apply` and combines it back into what `apply` would have returned if it had been run in a single process.\n        processes (int, optional): Max number of processes to use for computations. Defaults to 1.\n\n    Keyword Args: will be passed to the `apply` function.\n\n    Returns:\n        Iterable: output of (in order of application) `split`, `apply`, then `combine` functions.\n    \"\"\"\n    if processes == 1:\n        return apply(data, **kwargs)\n    try:\n        data_partitioned = split(data, processes=processes)\n    except TypeError:\n        data_partitioned = split(data)\n\n    pool = mp.Pool(processes=processes)\n\n    results = [pool.apply_async(apply, (data_bunch,), kwargs) for data_bunch in data_partitioned]\n\n    output = [p.get() for p in results]\n\n    return combine(output)\n</code></pre>"},{"location":"reference/genet/utils/parallel/#genet.utils.parallel.split_dict","title":"<code>split_dict(_dict, processes=1)</code>","text":"<p>Partitions dict into list of subset dicts of _dict</p> PARAMETER DESCRIPTION <code>_dict</code> <p>Input dictionary to split.</p> <p> TYPE: <code>dict</code> </p> <code>processes</code> <p>_description. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list[dict]</code> <p>list[dict]: List of dictionaries.</p> Source code in <code>src/genet/utils/parallel.py</code> <pre><code>def split_dict(_dict: dict, processes: int = 1) -&gt; list[dict]:\n    \"\"\"Partitions dict into list of subset dicts of _dict\n\n    Args:\n        _dict (dict): Input dictionary to split.\n        processes (int, optional): _description. Defaults to 1.\n\n    Returns:\n        list[dict]: List of dictionaries.\n    \"\"\"\n    k = ceil(len(_dict) / processes)\n    if len(_dict) &lt;= k:\n        return [_dict]\n    else:\n        keys = list(_dict.keys())\n        keys_partitioned = split_list(keys, processes=processes)\n        return [{key: _dict[key] for key in keys_bunch} for keys_bunch in keys_partitioned]\n</code></pre>"},{"location":"reference/genet/utils/parallel/#genet.utils.parallel.split_list","title":"<code>split_list(_list, processes=1)</code>","text":"<p>Partitions list into list of subsets of _list.</p> PARAMETER DESCRIPTION <code>_list</code> <p>Input list</p> <p> TYPE: <code>list</code> </p> <code>processes</code> <p>Number of processes to split data across. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of lists</p> <p> TYPE: <code>list[list]</code> </p> Source code in <code>src/genet/utils/parallel.py</code> <pre><code>def split_list(_list: list, processes: int = 1) -&gt; list[list]:\n    \"\"\"Partitions list into list of subsets of _list.\n\n    Args:\n        _list (list): Input list\n        processes (int, optional): Number of processes to split data across. Defaults to 1.\n\n    Returns:\n        list: List of lists\n    \"\"\"\n    k = ceil(len(_list) / processes)\n    if len(_list) &lt;= k:\n        return [_list]\n    else:\n        n = int(len(_list) // k)\n        l_partitioned = [_list[(k * i) : (k * (i + 1))] for i in range(n)]\n        leftovers = _list[(k * n) :]\n        if leftovers:\n            l_partitioned.append(leftovers)\n        logging.info(\"{} or {} batches of size {} ish\".format(n, n + 1, k))\n        return l_partitioned\n</code></pre>"},{"location":"reference/genet/utils/persistence/","title":"genet.utils.persistence","text":""},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.ensure_dir","title":"<code>ensure_dir(direc)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def ensure_dir(direc):\n    if not os.path.exists(direc):\n        try:\n            os.makedirs(direc)\n        except PermissionError as e:\n            logging.warning(e)\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.is_csv","title":"<code>is_csv(path)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def is_csv(path: Union[Path, str]):\n    return _check_type_and_suffix(path, \".csv\")\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.is_geojson","title":"<code>is_geojson(path)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def is_geojson(path: Union[Path, str]):\n    return _check_type_and_suffix(path, \".geojson\")\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.is_json","title":"<code>is_json(path)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def is_json(path: Union[Path, str]):\n    return _check_type_and_suffix(path, \".json\")\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.is_yml","title":"<code>is_yml(path)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def is_yml(path: Union[Path, str]):\n    return _check_type_and_suffix(path, [\".yml\", \".yaml\"])\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.is_zip","title":"<code>is_zip(path)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def is_zip(path: Union[Path, str]):\n    return _check_type_and_suffix(path, \".zip\")\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.listify","title":"<code>listify(value)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def listify(value: Union[str, list, set]):\n    if isinstance(value, str):\n        return [value]\n    elif isinstance(value, (list, set)):\n        return list(value)\n    elif value is None:\n        return []\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.setify","title":"<code>setify(value)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def setify(value: Union[str, list, set]):\n    if isinstance(value, (str, int, float)):\n        return {value}\n    elif isinstance(value, (list, set)):\n        return set(value)\n    elif value is None:\n        return set()\n    else:\n        raise NotImplementedError(f\"Value: {value} cannot be setified\")\n</code></pre>"},{"location":"reference/genet/utils/persistence/#genet.utils.persistence.zip_folder","title":"<code>zip_folder(folder_path)</code>","text":"Source code in <code>src/genet/utils/persistence.py</code> <pre><code>def zip_folder(folder_path):\n    shutil.make_archive(folder_path, \"zip\", folder_path)\n</code></pre>"},{"location":"reference/genet/utils/plot/","title":"genet.utils.plot","text":""},{"location":"reference/genet/utils/plot/#genet.utils.plot.KEPLER_CONFIGS","title":"<code>KEPLER_CONFIGS = {'base_config': {'version': 'v1', 'config': {'visState': {'filters': [], 'layers': [], 'interactionConfig': {'tooltip': {'fieldsToShow': {}, 'compareMode': False, 'compareType': 'absolute', 'enabled': True}, 'brush': {'size': 0.5, 'enabled': False}, 'geocoder': {'enabled': False}, 'coordinate': {'enabled': False}}, 'layerBlending': 'normal', 'splitMaps': [], 'animationConfig': {'currentTime': None, 'speed': 1}}, 'mapStyle': {'styleType': 'dark', 'topLayerGroups': {}, 'visibleLayerGroups': {'label': False, 'road': True, 'border': False, 'building': True, 'water': True, 'land': True, '3d building': False}, 'threeDBuildingColor': [9.665468314072013, 17.18305478057247, 31.1442867897876], 'mapStyles': {}}}}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/plot/#genet.utils.plot.LAYERS","title":"<code>LAYERS = {'network_links': {'fieldsToShow': {'network_links': [{'name': 'id', 'format': None}, {'name': 'from', 'format': None}, {'name': 'to', 'format': None}, {'name': 'freespeed', 'format': None}, {'name': 'capacity', 'format': None}]}, 'layer': {'id': 'network_links', 'type': 'geojson', 'config': {'dataId': 'network_links', 'label': 'network_links', 'color': [227, 227, 227], 'highlightColor': [252, 242, 26, 255], 'columns': {'geojson': 'geometry'}, 'isVisible': True, 'visConfig': {'opacity': 0.8, 'strokeOpacity': 0.8, 'thickness': 0.5, 'strokeColor': None, 'radius': 10, 'sizeRange': [0, 10], 'radiusRange': [0, 50], 'heightRange': [0, 500], 'elevationScale': 5, 'enableElevationZoomFactor': True, 'stroked': True, 'filled': False, 'enable3d': False, 'wireframe': False}, 'hidden': False, 'textLabel': [{'field': None, 'color': [255, 255, 255], 'size': 18, 'offset': [0, 0], 'anchor': 'start', 'alignment': 'center'}]}, 'visualChannels': {'colorField': None, 'colorScale': 'quantize', 'strokeColorField': None, 'strokeColorScale': 'quantize', 'sizeField': None, 'sizeScale': 'linear', 'heightField': None, 'heightScale': 'linear', 'radiusField': None, 'radiusScale': 'linear'}}}, 'schedule_routes': {'fieldsToShow': {'schedule_routes': [{'name': 'route_id', 'format': None}, {'name': 'mode', 'format': None}, {'name': 'route_short_name', 'format': None}, {'name': 'service_id', 'format': None}]}, 'layer': {'id': 'schedule_routes', 'type': 'geojson', 'config': {'dataId': 'schedule_routes', 'label': 'schedule_routes', 'color': [30, 150, 190], 'highlightColor': [252, 242, 26, 255], 'columns': {'geojson': 'geometry'}, 'isVisible': True, 'visConfig': {'opacity': 0.8, 'strokeOpacity': 0.49, 'thickness': 1.8, 'strokeColor': None, 'strokeColorRange': {'name': 'Uber Viz Qualitative 4', 'type': 'qualitative', 'category': 'Uber', 'colors': ['#12939A', '#DDB27C', '#88572C', '#FF991F', '#F15C17', '#223F9A', '#DA70BF', '#125C77', '#4DC19C', '#776E57', '#17B8BE', '#F6D18A', '#B7885E', '#FFCB99', '#F89570', '#829AE3', '#E79FD5', '#1E96BE', '#89DAC1', '#B3AD9E']}, 'radius': 10, 'sizeRange': [0, 10], 'radiusRange': [0, 50], 'heightRange': [0, 500], 'elevationScale': 5, 'enableElevationZoomFactor': True, 'stroked': True, 'filled': False, 'enable3d': False, 'wireframe': False}, 'hidden': False, 'textLabel': [{'field': None, 'color': [255, 255, 255], 'size': 18, 'offset': [0, 0], 'anchor': 'start', 'alignment': 'center'}]}, 'visualChannels': {'colorField': None, 'colorScale': 'quantize', 'strokeColorField': {'name': 'mode', 'type': 'string'}, 'strokeColorScale': 'ordinal', 'sizeField': None, 'sizeScale': 'linear', 'heightField': None, 'heightScale': 'linear', 'radiusField': None, 'radiusScale': 'linear'}}}, 'schedule_links': {'fieldsToShow': {'schedule_links': [{'name': 'u', 'format': None}, {'name': 'v', 'format': None}]}, 'layer': {'id': 'schedule_links', 'type': 'geojson', 'config': {'dataId': 'schedule_links', 'label': 'schedule_links', 'color': [249, 168, 37], 'highlightColor': [252, 242, 26, 255], 'columns': {'geojson': 'geometry'}, 'isVisible': True, 'visConfig': {'opacity': 0.8, 'strokeOpacity': 0.8, 'thickness': 0.5, 'strokeColor': None, 'radius': 10, 'sizeRange': [0, 10], 'radiusRange': [0, 50], 'heightRange': [0, 500], 'elevationScale': 5, 'enableElevationZoomFactor': True, 'stroked': True, 'filled': False, 'enable3d': False, 'wireframe': False}, 'hidden': False, 'textLabel': [{'field': None, 'color': [255, 255, 255], 'size': 18, 'offset': [0, 0], 'anchor': 'start', 'alignment': 'center'}]}, 'visualChannels': {'colorField': None, 'colorScale': 'quantize', 'strokeColorField': None, 'strokeColorScale': 'quantize', 'sizeField': None, 'sizeScale': 'linear', 'heightField': None, 'heightScale': 'linear', 'radiusField': None, 'radiusScale': 'linear'}}}, 'schedule_stops': {'fieldsToShow': {'schedule_stops': [{'name': 'id', 'format': None}, {'name': 'x', 'format': None}, {'name': 'y', 'format': None}, {'name': 'name', 'format': None}, {'name': 'linkRefId', 'format': None}]}, 'layer': {'id': 'schedule_stops', 'type': 'point', 'config': {'dataId': 'schedule_stops', 'label': 'schedule_stops', 'color': [249, 95, 37], 'highlightColor': [252, 242, 26, 255], 'columns': {'lat': 'lat', 'lng': 'lon', 'altitude': None}, 'isVisible': True, 'visConfig': {'opacity': 0.8, 'strokeOpacity': 0.8, 'thickness': 0.5, 'strokeColor': None, 'radius': 10, 'sizeRange': [0, 10], 'radiusRange': [0, 50], 'heightRange': [0, 500], 'elevationScale': 5, 'enableElevationZoomFactor': True, 'stroked': False, 'filled': True, 'enable3d': False, 'wireframe': False}, 'hidden': False, 'textLabel': [{'field': {'name': 'name', 'type': 'string'}, 'color': [255, 255, 255], 'size': 11, 'offset': [0, 0], 'anchor': 'start', 'alignment': 'center'}]}, 'visualChannels': {'colorField': None, 'colorScale': 'quantize', 'strokeColorField': None, 'strokeColorScale': 'quantize', 'sizeField': None, 'sizeScale': 'linear', 'heightField': None, 'heightScale': 'linear', 'radiusField': None, 'radiusScale': 'linear'}}}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/plot/#genet.utils.plot.plot_geodataframes_on_kepler_map","title":"<code>plot_geodataframes_on_kepler_map(gdfs, height=750, kepler_config=None)</code>","text":"<p>Plots geodataframes on a kepler map.</p> PARAMETER DESCRIPTION <code>gdfs</code> <p>{'gdf name': gdf} dictionary of geodataframes.</p> <p> TYPE: <code>dict[str, GeoDataFrame]</code> </p> <code>height</code> <p>height for the kepler map. Defaults to 750.</p> <p> TYPE: <code>int</code> DEFAULT: <code>750</code> </p> <code>kepler_config</code> <p>If given, kepler config or one of the keys in the predefined configs in KEPLER_CONFIGS. Defaults to None.</p> <p> TYPE: <code>Optional[dict | str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>KeplerGl</code> <p>keplergl.KeplerGl: Kepler plot object</p> Source code in <code>src/genet/utils/plot.py</code> <pre><code>def plot_geodataframes_on_kepler_map(\n    gdfs: dict[str, gpd.GeoDataFrame],\n    height: int = 750,\n    kepler_config: Optional[Union[dict, str]] = None,\n) -&gt; keplergl.KeplerGl:\n    \"\"\"Plots geodataframes on a kepler map.\n\n    Args:\n        gdfs (dict[str, gpd.GeoDataFrame]): {'gdf name': gdf} dictionary of geodataframes.\n        height (int, optional): height for the kepler map. Defaults to 750.\n        kepler_config (Optional[dict | str], optional): If given, kepler config or one of the keys in the predefined configs in KEPLER_CONFIGS. Defaults to None.\n\n    Returns:\n        keplergl.KeplerGl: Kepler plot object\n    \"\"\"\n    if isinstance(kepler_config, str) and kepler_config in KEPLER_CONFIGS:\n        kepler_config = KEPLER_CONFIGS[kepler_config]\n    elif isinstance(kepler_config, dict):\n        kepler_config = kepler_config\n    else:\n        kepler_config = {}\n    return keplergl.KeplerGl(data=gdfs, height=height, config=kepler_config)\n</code></pre>"},{"location":"reference/genet/utils/secrets_vault/","title":"genet.utils.secrets_vault","text":""},{"location":"reference/genet/utils/secrets_vault/#genet.utils.secrets_vault.get_google_directions_api_key","title":"<code>get_google_directions_api_key(secret_name=None, region_name=None)</code>","text":"<p>Extracts google directions api key from environmental variable or secrets manager.</p> PARAMETER DESCRIPTION <code>secret_name</code> <p>If given and API key is not an environment variable, will search for the secret in the AWS secrets manager. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p>If given and API key is not an environment variable, will search for the secret in the given AWS region account. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Optional[str]: Google API key, if there is one to find.</p> Source code in <code>src/genet/utils/secrets_vault.py</code> <pre><code>def get_google_directions_api_key(\n    secret_name: Optional[str] = None, region_name: Optional[str] = None\n) -&gt; Optional[str]:\n    \"\"\"Extracts google directions api key from environmental variable or secrets manager.\n\n    Args:\n        secret_name (Optional[str], optional):\n            If given and API key is not an environment variable, will search for the secret in the AWS secrets manager.\n            Defaults to None.\n        region_name (Optional[str], optional):\n            If given and API key is not an environment variable, will search for the secret in the given AWS region account.\n            Defaults to None.\n\n    Returns:\n        Optional[str]: Google API key, if there is one to find.\n    \"\"\"\n    key: Optional[str] = os.getenv(\"GOOGLE_DIR_API_KEY\")\n\n    if key is None and (secret_name is not None and region_name is not None):\n        key_dict = get_secret_as_dict(secret_name, region_name)\n        if \"key\" in key_dict:\n            key = key_dict[\"key\"]\n        elif \"api_key\" in key_dict:\n            key = key_dict[\"api_key\"]\n    return key\n</code></pre>"},{"location":"reference/genet/utils/secrets_vault/#genet.utils.secrets_vault.get_secret","title":"<code>get_secret(secret_name, region_name)</code>","text":"<p>Extracts api key from aws secrets manager.</p> PARAMETER DESCRIPTION <code>secret_name</code> <p>Will search for the secret in the AWS secrets manager.</p> <p> TYPE: <code>str</code> </p> <code>region_name</code> <p>Will search for the secret in the given AWS region account.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>JSON response string.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/utils/secrets_vault.py</code> <pre><code>def get_secret(secret_name: str, region_name: str) -&gt; str:\n    \"\"\"Extracts api key from aws secrets manager.\n\n    Args:\n        secret_name (str):\n            Will search for the secret in the AWS secrets manager.\n        region_name (str):\n            Will search for the secret in the given AWS region account.\n\n    Returns:\n        str: JSON response string.\n\n    \"\"\"\n    client = boto3.client(\"secretsmanager\", region_name=region_name)\n\n    print(\"Looking for secret '{}' in the vault\".format(secret_name))\n\n    try:\n        response = client.get_secret_value(SecretId=secret_name)\n    except client.exceptions.ResourceNotFoundException:\n        return None\n    if \"SecretString\" in response:\n        print(\"Found string secret for '{}'\".format(secret_name))\n        return response[\"SecretString\"]\n    else:\n        print(\"Found binary secret for '{}'\".format(secret_name))\n        return response[\"SecretBinary\"]\n</code></pre>"},{"location":"reference/genet/utils/secrets_vault/#genet.utils.secrets_vault.get_secret_as_dict","title":"<code>get_secret_as_dict(secret_name, region_name)</code>","text":"Source code in <code>src/genet/utils/secrets_vault.py</code> <pre><code>def get_secret_as_dict(secret_name: str, region_name: str) -&gt; dict:\n    string_secret = get_secret(secret_name, region_name)\n    if string_secret is not None:\n        return json.loads(string_secret)\n    else:\n        return {}\n</code></pre>"},{"location":"reference/genet/utils/simplification/","title":"genet.utils.simplification","text":""},{"location":"reference/genet/utils/simplification/#genet.utils.simplification.simplify_graph","title":"<code>simplify_graph(n, no_processes=1)</code>","text":"<p>Simplify a graph's topology by removing interstitial nodes.</p> <p>MONKEY PATCH OF OSMNX'S GRAPH SIMPLIFICATION ALGO</p> <p>Simplify graph topology by removing all nodes that are not intersections or dead-ends. Create an edge directly between the end points that encapsulate them, but retain the geometry of the original edges, saved as attribute in new edge.</p> <p>Updates network graph, indexing and schedule routes in-place. Adds a new attribute to n that records map between old and new link indices</p> PARAMETER DESCRIPTION <code>n</code> <p>GeNet network.</p> <p> TYPE: <code>Network</code> </p> <code>no_processes</code> <p>Number of processes to split some of the processes across. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/genet/utils/simplification.py</code> <pre><code>def simplify_graph(n: \"genet.core.Network\", no_processes=1):\n    \"\"\"Simplify a graph's topology by removing interstitial nodes.\n\n    MONKEY PATCH OF OSMNX'S GRAPH SIMPLIFICATION ALGO\n\n    Simplify graph topology by removing all nodes that are not intersections or dead-ends.\n    Create an edge directly between the end points that encapsulate them,\n    but retain the geometry of the original edges, saved as attribute in new edge.\n\n    Updates network graph, indexing and schedule routes in-place.\n    Adds a new attribute to n that records map between old and new link indices\n\n    Args:\n        n (Network): GeNet network.\n        no_processes (int, optional):\n            Number of processes to split some of the processes across. Defaults to 1.\n    \"\"\"\n    logging.info(\"Begin simplifying the graph\")\n    initial_node_count = len(list(n.graph.nodes()))\n    initial_edge_count = len(list(n.graph.edges()))\n\n    logging.info(\"Generating paths to be simplified\")\n    # generate each path that needs to be simplified\n    edges_to_simplify = [\n        list(x)\n        for x in set(\n            tuple(x) for x in _get_edge_groups_to_simplify(n.graph, no_processes=no_processes)\n        )\n    ]\n    logging.info(f\"Found {len(edges_to_simplify)} paths to simplify.\")\n\n    indexed_paths_to_simplify = dict(\n        zip(n.generate_indices_for_n_edges(len(edges_to_simplify)), edges_to_simplify)\n    )\n    indexed_paths_to_simplify = _assemble_path_data(n, indexed_paths_to_simplify)\n\n    nodes_to_remove = set()\n    for k, data in indexed_paths_to_simplify.items():\n        nodes_to_remove |= set(data[\"nodes_to_remove\"])\n    n.remove_nodes(nodes_to_remove, ignore_change_log=True, silent=True)\n\n    logging.info(\"Processing links for all paths to be simplified\")\n    links_to_add = parallel.multiprocess_wrap(\n        data=indexed_paths_to_simplify,\n        split=parallel.split_dict,\n        apply=_process_path,\n        combine=parallel.combine_dict,\n        processes=no_processes,\n    )\n\n    logging.info(\"Adding new simplified links\")\n    # add links\n    reindexing_dict = n.add_links(links_to_add, ignore_change_log=True)[0]\n\n    # generate link simplification map between old indices and new, add changelog event\n    for old_id, new_id in reindexing_dict.items():\n        indexed_paths_to_simplify[new_id] = indexed_paths_to_simplify[old_id]\n        del indexed_paths_to_simplify[old_id]\n    new_ids = list(indexed_paths_to_simplify.keys())\n    old_ids = [set(indexed_paths_to_simplify[_id][\"ids\"]) for _id in new_ids]\n    n.change_log = n.change_log.simplify_bunch(\n        old_ids, new_ids, indexed_paths_to_simplify, links_to_add\n    )\n    del links_to_add\n\n    # generate map between old and new ids\n    n.link_simplification_map = {}\n    for old_id_list, new_id in zip(old_ids, new_ids):\n        for _id in old_id_list:\n            n.link_simplification_map[_id] = new_id\n    n.update_link_auxiliary_files(n.link_simplification_map)\n\n    logging.info(\n        f\"Simplified graph: {initial_node_count} to {len(n.graph)} nodes, {initial_edge_count} to \"\n        f\"{len(n.graph.edges())} edges\"\n    )\n\n    if n.schedule:\n        logging.info(\"Updating the Schedule\")\n        # update stop's link reference ids\n        n.schedule.apply_function_to_stops(n.link_simplification_map, \"linkRefId\")\n        logging.info(\"Updated Stop Link Reference Ids\")\n\n        # update schedule routes\n        df_routes = n.schedule.route_attribute_data(keys=[\"network_links\"])\n        df_routes[\"network_links\"] = df_routes[\"network_links\"].apply(\n            lambda x: update_link_ids(x, n.link_simplification_map)\n        )\n        n.schedule.apply_attributes_to_routes(df_routes.T.to_dict())\n        logging.info(\"Updated Network Routes\")\n    logging.info(\"Finished simplifying network\")\n</code></pre>"},{"location":"reference/genet/utils/simplification/#genet.utils.simplification.update_link_ids","title":"<code>update_link_ids(old_route, link_mapping)</code>","text":"Source code in <code>src/genet/utils/simplification.py</code> <pre><code>def update_link_ids(old_route, link_mapping):\n    new_route = []\n    for link in old_route:\n        updated_route_link = link\n        try:\n            updated_route_link = link_mapping[link]\n        except KeyError:\n            pass\n        if not new_route:\n            new_route = [updated_route_link]\n        elif new_route[-1] != updated_route_link:\n            new_route.append(updated_route_link)\n    return new_route\n</code></pre>"},{"location":"reference/genet/utils/spatial/","title":"genet.utils.spatial","text":""},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.APPROX_EARTH_RADIUS","title":"<code>APPROX_EARTH_RADIUS = 6371008.8</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.S2_LEVELS_FOR_SPATIAL_INDEXING","title":"<code>S2_LEVELS_FOR_SPATIAL_INDEXING = [0, 6, 8, 12, 18, 24, 30]</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree","title":"<code>SpatialTree(n=None)</code>","text":"<p>               Bases: <code>DiGraph</code></p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def __init__(self, n=None):\n    super().__init__()\n    self.links = gpd.GeoDataFrame(columns=[\"link_id\", \"modes\", \"geometry\"])\n    if n is not None:\n        self.add_links(n)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.links","title":"<code>links = gpd.GeoDataFrame(columns=['link_id', 'modes', 'geometry'])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.add_links","title":"<code>add_links(n)</code>","text":"<p>Generates a spatial tree from links in a network.</p> <p>Nodes of the spatial tree are generated to represent the links of the network. Edges of the spatial tree are generated between the network links which share <code>to</code> and <code>from</code> nodes; i.e. the two links are connected at a node.</p> PARAMETER DESCRIPTION <code>n</code> <p>GeNet network.</p> <p> TYPE: <code>Network</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def add_links(self, n: \"genet.core.Network\"):\n    \"\"\"Generates a spatial tree from links in a network.\n\n    Nodes of the spatial tree are generated to represent the links of the network.\n    Edges of the spatial tree are generated between the network links which share `to` and `from` nodes;\n    i.e. the two links are connected at a node.\n\n    Args:\n        n (genet.core.Network): GeNet network.\n    \"\"\"\n    self.links = n.to_geodataframe()[\"links\"].to_crs(\"epsg:4326\")\n    self.links = self.links.rename(columns={\"id\": \"link_id\"})\n    self.links = self.links.set_index(\"link_id\", drop=False)\n\n    nodes = self.links.set_index(\"link_id\").T.to_dict()\n    self.add_nodes_from(nodes)\n\n    cols = [\"from\", \"to\", \"link_id\"]\n    edge_data_cols = list(\n        set(self.links.columns) - set(cols + [\"modes\", \"geometry\", \"u\", \"v\", \"key\"])\n    )\n    edges = pd.merge(\n        self.links[cols + edge_data_cols],\n        self.links[cols],\n        left_on=\"to\",\n        right_on=\"from\",\n        suffixes=(\"_to\", \"_from\"),\n    )\n    edge_data = edges[edge_data_cols].T.to_dict()\n    self.add_edges_from(\n        list(\n            zip(\n                edges[\"link_id_to\"],\n                edges[\"link_id_from\"],\n                [edge_data[idx] for idx in edges[\"link_id_to\"].index],\n            )\n        )\n    )\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.closest_links","title":"<code>closest_links(gdf_points, distance_radius)</code>","text":"<p>Finds closest links from a list of points within a given radius.</p> <p>Given a GeoDataFrame <code>gdf_points</code> with a <code>geometry</code> column of shapely.geometry.Points, finds closest links within <code>distance_radius</code> from the spatial tree which accept <code>mode</code>.</p> <p>Does not work very close to the poles.</p> PARAMETER DESCRIPTION <code>gdf_points</code> <p>Uniquely indexed, in crs: EPSG:4326 and only containing shapely.geometry.Points (lon,lat).</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>distance_radius</code> <p>Metres in which to consider possible links.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: Closest links to points.</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def closest_links(\n    self, gdf_points: gpd.GeoDataFrame, distance_radius: float\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Finds closest links from a list of points within a given radius.\n\n    Given a GeoDataFrame `gdf_points` with a `geometry` column of shapely.geometry.Points,\n    finds closest links within `distance_radius` from the spatial tree which accept `mode`.\n\n    Does not work very close to the poles.\n\n    Args:\n        gdf_points (gpd.GeoDataFrame): Uniquely indexed, in crs: EPSG:4326 and only containing shapely.geometry.Points (lon,lat).\n        distance_radius (float): Metres in which to consider possible links.\n\n    Returns:\n        gpd.GeoDataFrame: Closest links to points.\n    \"\"\"\n    bdds = gdf_points[\"geometry\"].bounds\n    approx_lat = (bdds[\"miny\"].mean() + bdds[\"maxy\"].mean()) / 2\n    approx_degree_radius = approximate_metres_distance_in_4326_degrees(\n        distance_radius, approx_lat\n    )\n    gdf_points[\"geometry\"] = gdf_points[\"geometry\"].apply(\n        lambda x: grow_point(x, approx_degree_radius)\n    )\n    try:\n        closest_links = gpd.sjoin(\n            self.links[[\"link_id\", \"geometry\"]], gdf_points, how=\"right\", predicate=\"intersects\"\n        )\n        return closest_links\n    except EmptySpatialTree:\n        return gpd.GeoDataFrame(\n            columns=set(gdf_points.columns) | {\"index_left\", \"link_id\", \"geometry\"},\n            crs=\"epsg:4326\",\n        )\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.modal_links_geodataframe","title":"<code>modal_links_geodataframe(modes)</code>","text":"<p>Subsets the links geodataframe on modes</p> PARAMETER DESCRIPTION <code>modes</code> <p>single or set of modes.</p> <p> TYPE: <code>Union[str, set[str]]</code> </p> RAISES DESCRIPTION <code>EmptySpatialTree</code> <p>At least one link must include one of the input modes.</p> RETURNS DESCRIPTION <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: links that include subset of modes.</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def modal_links_geodataframe(self, modes: Union[str, set[str]]) -&gt; gpd.GeoDataFrame:\n    \"\"\"Subsets the links geodataframe on modes\n\n    Args:\n        modes (Union[str, set[str]]): single or set of modes.\n\n    Raises:\n        EmptySpatialTree: At least one link must include one of the input modes.\n\n    Returns:\n        gpd.GeoDataFrame: links that include subset of modes.\n    \"\"\"\n    if isinstance(modes, str):\n        modes = {modes}\n    _df = self.links[self.links.apply(lambda x: spatial_output.modal_subset(x, modes), axis=1)]\n    if _df.empty:\n        raise EmptySpatialTree(f\"No links found satisfying modes: {modes}\")\n    return _df\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.modal_subtree","title":"<code>modal_subtree(modes)</code>","text":"<p>Create a networkx subgraph from subset of links which match the input modes.</p> PARAMETER DESCRIPTION <code>modes</code> <p>single or set of modes.</p> <p> TYPE: <code>Union[str, set[str]]</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>nx.Graph: Subgraph of Self.</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def modal_subtree(self, modes: Union[str, set[str]]) -&gt; nx.Graph:\n    \"\"\"Create a networkx subgraph from subset of links which match the input modes.\n\n    Args:\n        modes (Union[str, set[str]]): single or set of modes.\n\n    Returns:\n        nx.Graph: Subgraph of Self.\n    \"\"\"\n\n    sub_tree = self.__class__()\n    links = gpd.GeoDataFrame(self.modal_links_geodataframe(modes))\n    sub_tree = self.subgraph(links[\"link_id\"])\n    sub_tree.links = links\n    return sub_tree\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.path","title":"<code>path(G, source, target, weight=None)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def path(self, G, source, target, weight=None):\n    try:\n        return nx.shortest_path(G, source, target, weight=weight)\n    except (nx.NetworkXNoPath, nx.NodeNotFound):\n        pass\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.path_length","title":"<code>path_length(G, source, target, weight=None)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def path_length(self, G, source, target, weight=None):\n    try:\n        return nx.dijkstra_path_length(G, source=source, target=target, weight=weight)\n    except nx.NetworkXNoPath:\n        pass\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.shortest_path_lengths","title":"<code>shortest_path_lengths(df_pt_edges, from_col='u', to_col='v', weight='length')</code>","text":"PARAMETER DESCRIPTION <code>df_pt_edges</code> <p>DataFrame with a <code>from_col</code> and <code>to_col</code> defining links stored in the graph for which a path length is required.</p> <p> TYPE: <code>DataFrame</code> </p> <code>from_col</code> <p>Name of the column which gives ID for the source link. Defaults to \"u\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'u'</code> </p> <code>to_col</code> <p>Name of the column which gives ID for the target link. Defaults to \"v\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'v'</code> </p> <code>weight</code> <p>Weight for routing. Defaults to \"length\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'length'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: <code>df_pt_edges</code> with an extra column 'shortest_path'</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def shortest_path_lengths(\n    self,\n    df_pt_edges: pd.DataFrame,\n    from_col: str = \"u\",\n    to_col: str = \"v\",\n    weight: str = \"length\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n\n    Args:\n        df_pt_edges (pd.DataFrame):\n            DataFrame with a `from_col` and `to_col` defining links stored in the graph for which a path length is required.\n        from_col (str, optional): Name of the column which gives ID for the source link. Defaults to \"u\".\n        to_col (str, optional): Name of the column which gives ID for the target link. Defaults to \"v\".\n        weight (str, optional): Weight for routing. Defaults to \"length\".\n\n    Returns:\n        pd.DataFrame: `df_pt_edges` with an extra column 'shortest_path'\n    \"\"\"\n    if df_pt_edges.empty:\n        df_pt_edges[\"path_lengths\"] = None\n    else:\n        try:\n            df_pt_edges[\"path_lengths\"] = df_pt_edges.apply(\n                lambda x: self.path_length(\n                    G=self, source=x[from_col], target=x[to_col], weight=weight\n                ),\n                axis=1,\n            )\n        except EmptySpatialTree:\n            df_pt_edges[\"path_lengths\"] = None\n    return df_pt_edges\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.SpatialTree.shortest_paths","title":"<code>shortest_paths(df_pt_edges, from_col='u', to_col='v', weight='length')</code>","text":"PARAMETER DESCRIPTION <code>df_pt_edges</code> <p>DataFrame with a <code>from_col</code> and <code>to_col</code> defining links stored in the graph for which a path is required</p> <p> TYPE: <code>DataFrame</code> </p> <code>from_col</code> <p>Name of the column which gives ID for the source link. Defaults to \"u\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'u'</code> </p> <code>to_col</code> <p>Name of the column which gives ID for the target link. Defaults to \"v\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'v'</code> </p> <code>weight</code> <p>Weight for routing. Defaults to \"length\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'length'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: <code>df_pt_edges</code> with an extra column 'shortest_path'</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def shortest_paths(\n    self,\n    df_pt_edges: pd.DataFrame,\n    from_col: str = \"u\",\n    to_col: str = \"v\",\n    weight: str = \"length\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n\n    Args:\n        df_pt_edges (pd.DataFrame):\n            DataFrame with a `from_col` and `to_col` defining links stored in the graph for which a path is required\n        from_col (str, optional): Name of the column which gives ID for the source link. Defaults to \"u\".\n        to_col (str, optional): Name of the column which gives ID for the target link. Defaults to \"v\".\n        weight (str, optional): Weight for routing. Defaults to \"length\".\n\n    Returns:\n        pd.DataFrame: `df_pt_edges` with an extra column 'shortest_path'\n    \"\"\"\n    if df_pt_edges.empty:\n        df_pt_edges[\"shortest_path\"] = None\n    else:\n        try:\n            df_pt_edges[\"shortest_path\"] = df_pt_edges.apply(\n                lambda x: self.path(\n                    G=self, source=x[from_col], target=x[to_col], weight=weight\n                ),\n                axis=1,\n            )\n        except EmptySpatialTree:\n            logging.warning(\"Shortest path could not be found due to an empty SpatialTree\")\n            df_pt_edges[\"shortest_path\"] = None\n    return df_pt_edges\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.approximate_metres_distance_in_4326_degrees","title":"<code>approximate_metres_distance_in_4326_degrees(distance, lat)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def approximate_metres_distance_in_4326_degrees(distance, lat):\n    # https://gis.stackexchange.com/questions/2951/algorithm-for-offsetting-a-latitude-longitude-by-some-amount-of-meters\n    return (\n        (float(distance) / 111111) + float(distance) / (111111 * np.cos(np.radians(float(lat))))\n    ) / 2\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.change_proj","title":"<code>change_proj(x, y, crs_transformer)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def change_proj(x, y, crs_transformer):\n    return crs_transformer.transform(x, y)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.compute_average_proximity_to_polyline","title":"<code>compute_average_proximity_to_polyline(poly_1, poly_2)</code>","text":"<p>Computes average distance between points in poly_1 and closest points in poly_2.</p> <p>Works best when poly_1 is less dense with points than poly_2.</p> PARAMETER DESCRIPTION <code>poly_1</code> <p>google encoded polyline.</p> <p> TYPE: <code>str</code> </p> <code>poly_2</code> <p>google encoded polyline</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Average distance between points in poly_1 and their respective closest points in poly_2.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def compute_average_proximity_to_polyline(poly_1: str, poly_2: str) -&gt; float:\n    \"\"\"Computes average distance between points in poly_1 and closest points in poly_2.\n\n    Works best when poly_1 is less dense with points than poly_2.\n\n    Args:\n        poly_1 (str): google encoded polyline.\n        poly_2 (str): google encoded polyline\n\n    Returns:\n        float: Average distance between points in poly_1 and their respective closest points in poly_2.\n    \"\"\"\n    s2_poly_list_1 = decode_polyline_to_s2_points(poly_1)\n    s2_poly_list_2 = decode_polyline_to_s2_points(poly_2)\n\n    closest_distances = []\n    for point in s2_poly_list_1:\n        d = None\n        for other_line_point in s2_poly_list_2:\n            dist = distance_between_s2cellids(point, other_line_point)\n            if (d is None) or (d &gt; dist):\n                d = dist\n        closest_distances.append(d)\n    return statistics.mean(closest_distances)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.continue_line_from_two_points","title":"<code>continue_line_from_two_points(p1, p2)</code>","text":"<p>Builds a line from p1, p2 and another point, ahead, the same distance and direction from p2 as p1.</p> PARAMETER DESCRIPTION <code>p1</code> <p>Start point of line.</p> <p> TYPE: <code>Point</code> </p> <code>p2</code> <p>End point of line.</p> <p> TYPE: <code>Point</code> </p> RETURNS DESCRIPTION <code>LineString</code> <p>Line from p1 to p2.</p> <p> TYPE: <code>LineString</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def continue_line_from_two_points(p1: Point, p2: Point) -&gt; LineString:\n    \"\"\"Builds a line from p1, p2 and another point, ahead, the same distance and direction from p2 as p1.\n\n    Args:\n        p1 (Point): Start point of line.\n        p2 (Point): End point of line.\n\n    Returns:\n        LineString: Line from p1 to p2.\n    \"\"\"\n    return LineString([p1, p2, (p2.x + (p2.x - p1.x), p2.y + (p2.y - p1.y))])\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.decode_polyline_to_s2_points","title":"<code>decode_polyline_to_s2_points(_polyline)</code>","text":"PARAMETER DESCRIPTION <code>_polyline</code> <p>google encoded polyline.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[int]</code> <p>list[int]: S2 points describing the polyline.</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def decode_polyline_to_s2_points(_polyline: str) -&gt; list[int]:\n    \"\"\"\n\n    Args:\n        _polyline (str): google encoded polyline.\n\n    Returns:\n        list[int]: S2 points describing the polyline.\n    \"\"\"\n    decoded = polyline.decode(_polyline)\n    return [generate_index_s2(lat, lon) for lat, lon in decoded]\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.decode_polyline_to_shapely_linestring","title":"<code>decode_polyline_to_shapely_linestring(_polyline)</code>","text":"PARAMETER DESCRIPTION <code>_polyline</code> <p>google encoded polyline</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>LineString</code> <p>Shapely linestring representation of input polyline.</p> <p> TYPE: <code>LineString</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def decode_polyline_to_shapely_linestring(_polyline: str) -&gt; LineString:\n    \"\"\"\n\n    Args:\n        _polyline (str): google encoded polyline\n\n    Returns:\n        LineString: Shapely linestring representation of input polyline.\n    \"\"\"\n    decoded = polyline.decode(_polyline)\n    return LineString(decoded)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.distance_between_s2cellids","title":"<code>distance_between_s2cellids(s2cellid1, s2cellid2)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def distance_between_s2cellids(s2cellid1, s2cellid2):\n    if isinstance(s2cellid1, int):\n        s2cellid1 = s2.CellId(s2cellid1)\n    elif isinstance(s2cellid1, np.int64):\n        s2cellid1 = s2.CellId(int(s2cellid1))\n    if isinstance(s2cellid2, int):\n        s2cellid2 = s2.CellId(s2cellid2)\n    elif isinstance(s2cellid2, np.int64):\n        s2cellid2 = s2.CellId(int(s2cellid2))\n    distance = s2cellid1.to_lat_lng().get_distance(s2cellid2.to_lat_lng()).radians\n    return distance * APPROX_EARTH_RADIUS\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.encode_shapely_linestring_to_polyline","title":"<code>encode_shapely_linestring_to_polyline(linestring)</code>","text":"PARAMETER DESCRIPTION <code>linestring</code> <p>Shapely LineString to encode.</p> <p> TYPE: <code>LineString</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Google encoded polyline.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def encode_shapely_linestring_to_polyline(linestring: LineString) -&gt; str:\n    \"\"\"\n\n    Args:\n        linestring (LineString): Shapely LineString to encode.\n\n    Returns:\n        str: Google encoded polyline.\n    \"\"\"\n    return polyline.encode(linestring.coords)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.generate_index_s2","title":"<code>generate_index_s2(lat, lng)</code>","text":"<p>Returns s2.CellId from lat and lon</p> PARAMETER DESCRIPTION <code>lat</code> <p>Latitude.</p> <p> TYPE: <code>float</code> </p> <code>lng</code> <p>Longitude.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>int</code> <p>S2 cell ID.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def generate_index_s2(lat: float, lng: float) -&gt; int:\n    \"\"\"Returns s2.CellId from lat and lon\n\n    Args:\n        lat (float): Latitude.\n        lng (float): Longitude.\n\n    Returns:\n        int: S2 cell ID.\n    \"\"\"\n    return s2.CellId.from_lat_lng(s2.LatLng.from_degrees(lat, lng)).id()\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.generate_s2_geometry","title":"<code>generate_s2_geometry(points)</code>","text":"<p>Generate ordered list of s2.CellIds</p> PARAMETER DESCRIPTION <code>points</code> <p>Points to convert to S2 Cell IDs</p> <p> TYPE: <code>Union[LineString, list[tuple[float, float]], list[Point]]</code> </p> RETURNS DESCRIPTION <code>list[int]</code> <p>list[int]: List of S2 Cell IDs</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def generate_s2_geometry(\n    points: Union[LineString, list[tuple[float, float]], list[Point]]\n) -&gt; list[int]:\n    \"\"\"Generate ordered list of s2.CellIds\n\n    Args:\n        points (Union[LineString, list[tuple[float, float]], list[Point]]): Points to convert to S2 Cell IDs\n\n    Returns:\n        list[int]: List of S2 Cell IDs\n    \"\"\"\n    if isinstance(points, LineString):\n        points = list(points.coords)\n    try:\n        return [generate_index_s2(pt.x, pt.y) for pt in points]\n    except AttributeError:\n        return [generate_index_s2(pt[0], pt[1]) for pt in points]\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.get_nearest","title":"<code>get_nearest(src_points, candidates, k_neighbors=1)</code>","text":"<p>Find nearest neighbors for all source points from a set of candidate points</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def get_nearest(src_points, candidates, k_neighbors=1):\n    # https://autogis-site.readthedocs.io/en/latest/notebooks/L3/06_nearest-neighbor-faster.html\n    \"\"\"Find nearest neighbors for all source points from a set of candidate points\"\"\"\n\n    # Create tree from the candidate points\n    tree = BallTree(candidates, leaf_size=15, metric=\"haversine\")\n\n    # Find closest points and distances\n    distances, indices = tree.query(src_points, k=k_neighbors)\n\n    # Transpose to get distances and indices into arrays\n    distances = distances.transpose()\n    indices = indices.transpose()\n\n    # Get closest indices and distances (i.e. array at index 0)\n    # note: for the second closest points, you would take index 1, etc.\n    closest = indices[0]\n    closest_dist = distances[0]\n\n    # Return indices and distances\n    return (closest, closest_dist)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.grow_point","title":"<code>grow_point(x, distance)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def grow_point(x, distance):\n    return x.buffer(distance)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.map_azimuth_to_name","title":"<code>map_azimuth_to_name(azimuth)</code>","text":"PARAMETER DESCRIPTION <code>azimuth</code> <p>degrees from North (0).</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>assumes -180 =&lt; azimuth =&lt; 180.</p> RETURNS DESCRIPTION <code>str</code> <p>String defining compass direction, e.g. \"North Bound\".</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def map_azimuth_to_name(azimuth: float) -&gt; str:\n    \"\"\"\n\n    Args:\n        azimuth (float): degrees from North (0).\n\n    Raises:\n        NotImplementedError: assumes -180 =&lt; azimuth =&lt; 180.\n\n    Returns:\n        str: String defining compass direction, e.g. \"North Bound\".\n    \"\"\"\n    azimuth_to_name = {\n        (-22.5, 22.5): \"North Bound\",\n        (22.5, 67.5): \"North-East Bound\",\n        (67.5, 112.5): \"East Bound\",\n        (112.5, 157.5): \"South-East Bound\",\n        (-157.5, -112.5): \"South-West Bound\",\n        (-112.5, -67.5): \"West Bound\",\n        (-67.5, -22.5): \"North-West Bound\",\n    }\n    if azimuth &gt; 180 or azimuth &lt; -180:\n        raise NotImplementedError(\n            f\"Azimuth value of {azimuth} given. Only implemented for -180 =&lt; azimuth =&lt; 180\"\n        )\n    for (lower_bound, upper_bound), name in azimuth_to_name.items():\n        if lower_bound &lt; azimuth &lt;= upper_bound:\n            return name\n    # (-157.5, -180 | 180, 157.5): 'South Bound'\n    if azimuth &gt; 157.5 or azimuth &lt;= -157.5:\n        return \"South Bound\"\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.merge_linestrings","title":"<code>merge_linestrings(linestring_list)</code>","text":"PARAMETER DESCRIPTION <code>linestring_list</code> <p>ordered list of shapely.geometry.Linestring objects.</p> <p> TYPE: <code>list[LineString]</code> </p> RETURNS DESCRIPTION <code>Union[LineString, MultiLineString]</code> <p>Union[LineString, MultiLineString]: Assumes lines are contiguous. If they are not, will result in a MultiLineString.</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def merge_linestrings(linestring_list: list[LineString]) -&gt; Union[LineString, MultiLineString]:\n    \"\"\"\n\n    Args:\n        linestring_list (list[LineString]): ordered list of shapely.geometry.Linestring objects.\n\n    Returns:\n        Union[LineString, MultiLineString]:\n            Assumes lines are contiguous. If they are not, will result in a MultiLineString.\n    \"\"\"\n    multi_line = MultiLineString(linestring_list)\n    return linemerge(multi_line)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.nearest_neighbor","title":"<code>nearest_neighbor(left_gdf, right_gdf, return_dist=False)</code>","text":"<p>For each point in left_gdf, find closest point in right GeoDataFrame and return them.</p> <p>NOTICE: Assumes that the input Points are in WGS84 projection (lat/lon).</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def nearest_neighbor(left_gdf, right_gdf, return_dist=False):\n    # https://autogis-site.readthedocs.io/en/latest/notebooks/L3/06_nearest-neighbor-faster.html\n    \"\"\"\n    For each point in left_gdf, find closest point in right GeoDataFrame and return them.\n\n    NOTICE: Assumes that the input Points are in WGS84 projection (lat/lon).\n    \"\"\"\n\n    left_geom_col = left_gdf.geometry.name\n    right_geom_col = right_gdf.geometry.name\n\n    # Ensure that index in right gdf is formed of sequential numbers\n    right = right_gdf.copy().reset_index(drop=True)\n\n    # Parse coordinates from points and insert them into a numpy array as RADIANS\n    # Notice: should be in Lat/Lon format\n    left_radians = np.array(\n        left_gdf[left_geom_col]\n        .apply(lambda geom: (geom.y * np.pi / 180, geom.x * np.pi / 180))\n        .to_list()\n    )\n    right_radians = np.array(\n        right[right_geom_col]\n        .apply(lambda geom: (geom.y * np.pi / 180, geom.x * np.pi / 180))\n        .to_list()\n    )\n\n    # Find the nearest points\n    # -----------------------\n    # closest ==&gt; index in right_gdf that corresponds to the closest point\n    # dist ==&gt; distance between the nearest neighbors (in meters)\n\n    closest, dist = get_nearest(src_points=left_radians, candidates=right_radians)\n\n    # Return points from right GeoDataFrame that are closest to points in left GeoDataFrame\n    closest_points = right.loc[closest]\n\n    # Ensure that the index corresponds the one in left_gdf\n    closest_points = closest_points.set_index(left_gdf.index)\n\n    # Add distance if requested\n    if return_dist:\n        # Convert to meters from radians\n        closest_points[\"distance\"] = dist * APPROX_EARTH_RADIUS\n\n    return closest_points\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.read_geojson_to_shapely","title":"<code>read_geojson_to_shapely(geojson_file)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def read_geojson_to_shapely(geojson_file):\n    # https://gist.github.com/pramukta/6d1a2de485d7dc4c5480bf5fbb7b93d2#file-shapely_geojson_recipe-py\n    with open(geojson_file) as f:\n        features = json.load(f)[\"features\"]\n    return GeometryCollection([shape(feature[\"geometry\"]).buffer(0) for feature in features])\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.s2_hex_to_cell_union","title":"<code>s2_hex_to_cell_union(hex_area)</code>","text":"Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def s2_hex_to_cell_union(hex_area):\n    hex_area = hex_area.split(\",\")\n    cell_ids = []\n    for token in hex_area:\n        cell_ids.append(s2.CellId.from_token(token))\n    return s2.CellUnion(cell_ids=cell_ids)\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.snap_point_to_line","title":"<code>snap_point_to_line(point, line, distance_threshold=1e-08)</code>","text":"<p>Snap a point to a line, if over a distance threshold.</p> <p>Not using 'contains' method due to too high accuracy required to evaluate to True.</p> PARAMETER DESCRIPTION <code>point</code> <p>Point to be potentially snapped to line.</p> <p> TYPE: <code>Point</code> </p> <code>line</code> <p>Line to use for the Point to snap to</p> <p> TYPE: <code>LineString</code> </p> <code>distance_threshold</code> <p>Acceptable distance of point from line before snapping. Defaults to 1e-8.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> RETURNS DESCRIPTION <code>Point</code> <p>Point on line that is closest to input <code>point</code> or <code>point</code> itself, if it is within <code>distance_threshold</code>.</p> <p> TYPE: <code>Point</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def snap_point_to_line(point: Point, line: LineString, distance_threshold: float = 1e-8) -&gt; Point:\n    \"\"\"Snap a point to a line, if over a distance threshold.\n\n    Not using 'contains' method due to too high accuracy required to evaluate to True.\n\n    Args:\n        point (Point): Point to be potentially snapped to line.\n        line (LineString): Line to use for the Point to snap to\n        distance_threshold (float, optional): Acceptable distance of point from line before snapping. Defaults to 1e-8.\n\n    Returns:\n        Point: Point on line that is closest to input `point` or `point` itself, if it is within `distance_threshold`.\n    \"\"\"\n    if line.distance(point) &gt; distance_threshold:\n        point = line.interpolate(line.project(point))\n    return point\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.split_line_at_point","title":"<code>split_line_at_point(point, line)</code>","text":"<p>Returns a two-tuple of linestring slices of given line, split at the given point.</p> <p>If the point is not close enough to the line, it will be snapped.</p> <p>The order in the returned tuple preserves the given line.</p> PARAMETER DESCRIPTION <code>point</code> <p>point used for dividing the line</p> <p> TYPE: <code>Point</code> </p> <code>line</code> <p>line to divide</p> <p> TYPE: <code>LineString</code> </p> RETURNS DESCRIPTION <code>tuple[LineString, LineString]</code> <p>tuple[LineString, LineString]: If given line from A - B, the output will be (A - point, point - B) - subject to point needing to snap closer to the line.</p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def split_line_at_point(point: Point, line: LineString) -&gt; tuple[LineString, LineString]:\n    \"\"\"Returns a two-tuple of linestring slices of given line, split at the given point.\n\n    If the point is not close enough to the line, it will be snapped.\n\n    The order in the returned tuple preserves the given line.\n\n    Args:\n        point (Point): point used for dividing the line\n        line (LineString): line to divide\n\n    Returns:\n        tuple[LineString, LineString]:\n            If given line from A - B, the output will be (A - point, point - B) - subject to point needing to snap closer to the line.\n    \"\"\"\n    # the point has to be on the line for shapely split\n    # https://shapely.readthedocs.io/en/stable/manual.html#splitting\n    projected_point = snap_point_to_line(point, line, distance_threshold=0)\n    result = tuple(split(line, projected_point).geoms)\n    if len(result) == 1:\n        # our lines can have curves which makes them impossible to split with a point, instead we build a line to cut\n        # it, the end points of the linestring will likely not match with the point projected to the curved line, but\n        # are very close.\n        if point.distance(projected_point) &lt; 1e-8:\n            # the points are too close\n            logging.warning(\n                \"Given point is very close, but not cannot be placed on the line. We move it slightly \"\n                \"and the resulting split may not be exact.\"\n            )\n            point = Point(round(point.x, 2), round(point.y, 2))\n        split_line = continue_line_from_two_points(point, projected_point)\n        result = tuple(split(line, split_line).geoms)\n    return result\n</code></pre>"},{"location":"reference/genet/utils/spatial/#genet.utils.spatial.swap_x_y_in_linestring","title":"<code>swap_x_y_in_linestring(linestring)</code>","text":"<p>Swaps x with y in a shapely linestring.</p> <p>e.g. from LineString([(1,2), (3,4)]) to LineString([(2,1), (4,3)]).</p> PARAMETER DESCRIPTION <code>linestring</code> <p>Input linestring.</p> <p> TYPE: <code>LineString</code> </p> RETURNS DESCRIPTION <code>LineString</code> <p>Input linestring with swapped x and y coordinates.</p> <p> TYPE: <code>LineString</code> </p> Source code in <code>src/genet/utils/spatial.py</code> <pre><code>def swap_x_y_in_linestring(linestring: LineString) -&gt; LineString:\n    \"\"\"Swaps x with y in a shapely linestring.\n\n    e.g. from LineString([(1,2), (3,4)]) to LineString([(2,1), (4,3)]).\n\n    Args:\n        linestring (LineString): Input linestring.\n\n    Returns:\n        LineString: Input linestring with swapped x and y coordinates.\n    \"\"\"\n    return LineString((p[1], p[0]) for p in linestring.coords)\n</code></pre>"},{"location":"reference/genet/validate/network/","title":"genet.validate.network","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.Condition","title":"<code>Condition(condition)</code>  <code>dataclass</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.Condition.condition","title":"<code>condition</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.Condition.evaluate","title":"<code>evaluate(value)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def evaluate(self, value):\n    return self.condition(value)\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox","title":"<code>ConditionsToolbox(zero=FloatCondition(zero_value), negative=FloatCondition(negative_value), infinite=FloatCondition(infinity_value), fractional=FloatCondition(fractional_value), none=Condition(none_condition))</code>  <code>dataclass</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox.fractional","title":"<code>fractional = FloatCondition(fractional_value)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox.infinite","title":"<code>infinite = FloatCondition(infinity_value)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox.negative","title":"<code>negative = FloatCondition(negative_value)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox.none","title":"<code>none = Condition(none_condition)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox.zero","title":"<code>zero = FloatCondition(zero_value)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox.condition_names","title":"<code>condition_names()</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def condition_names(self) -&gt; list:\n    return [field.name for field in fields(self)]\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.ConditionsToolbox.get_condition_evaluator","title":"<code>get_condition_evaluator(condition)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def get_condition_evaluator(self, condition: str) -&gt; callable:\n    if condition in self.__dict__:\n        return self.__dict__[condition].evaluate\n    else:\n        raise NotImplementedError(f\"Condition {condition} is not defined.\")\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.FloatCondition","title":"<code>FloatCondition(condition)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Condition</code></p>"},{"location":"reference/genet/validate/network/#genet.validate.network.FloatCondition.condition","title":"<code>condition</code>  <code>instance-attribute</code>","text":""},{"location":"reference/genet/validate/network/#genet.validate.network.FloatCondition.evaluate","title":"<code>evaluate(value)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def evaluate(self, value):\n    return evaluate_condition_for_floatable(value, self.condition)\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.describe_graph_connectivity","title":"<code>describe_graph_connectivity(G)</code>","text":"<p>Computes dead ends, unreachable nodes, and strongly connected components of G.</p> PARAMETER DESCRIPTION <code>G</code> <p>Network graph.</p> <p> TYPE: <code>Graph</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Summary of problem nodes and strongly connected components of G.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/genet/validate/network.py</code> <pre><code>def describe_graph_connectivity(G: nx.Graph) -&gt; dict:\n    \"\"\"Computes dead ends, unreachable nodes, and strongly connected components of G.\n\n    Args:\n        G (nx.Graph): Network graph.\n\n    Returns:\n        dict: Summary of problem nodes and strongly connected components of G.\n    \"\"\"\n    dict_to_return = {}\n    # find dead ends or unreachable nodes\n    dict_to_return[\"problem_nodes\"] = find_problem_nodes(G)\n    # find number of connected subgraphs\n    dict_to_return[\"number_of_connected_subgraphs\"] = len(find_connected_subgraphs(G))\n    return dict_to_return\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.evaluate_condition_for_floatable","title":"<code>evaluate_condition_for_floatable(value, condition)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def evaluate_condition_for_floatable(value, condition):\n    try:\n        value = float(value)\n        return condition(value)\n    except (ValueError, TypeError):\n        return False\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.find_connected_subgraphs","title":"<code>find_connected_subgraphs(G)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def find_connected_subgraphs(G):\n    return [\n        (list(c), len(c))\n        for c in sorted(nx.strongly_connected_components(G), key=len, reverse=True)\n    ]\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.find_problem_nodes","title":"<code>find_problem_nodes(G)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def find_problem_nodes(G):\n    problem_nodes = {}\n    problem_nodes[\"dead_ends\"] = []\n    problem_nodes[\"unreachable_node\"] = []\n    for node in G.nodes:\n        if G.in_degree(node) == 0:\n            problem_nodes[\"unreachable_node\"].append(node)\n        if G.out_degree(node) == 0:\n            problem_nodes[\"dead_ends\"].append(node)\n    return problem_nodes\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.fractional_value","title":"<code>fractional_value(value)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def fractional_value(value):\n    return 1.0 &gt; value &gt; 0.0\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.infinity_value","title":"<code>infinity_value(value)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def infinity_value(value):\n    return math.isinf(value)\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.negative_value","title":"<code>negative_value(value)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def negative_value(value):\n    return value &lt; 0.0\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.none_condition","title":"<code>none_condition(value)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def none_condition(value):\n    return value in [None, \"None\"]\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.validate_attribute_data","title":"<code>validate_attribute_data(attributes, necessary_attributes)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def validate_attribute_data(attributes, necessary_attributes):\n    missing_attribs = set(necessary_attributes) - set(attributes)\n    if missing_attribs:\n        raise AttributeError(f\"Attributes: {missing_attribs} missing from data: {attributes}\")\n</code></pre>"},{"location":"reference/genet/validate/network/#genet.validate.network.zero_value","title":"<code>zero_value(value)</code>","text":"Source code in <code>src/genet/validate/network.py</code> <pre><code>def zero_value(value):\n    return value == 0.0\n</code></pre>"},{"location":"reference/genet/validate/schedule/","title":"genet.validate.schedule","text":""},{"location":"reference/genet/validate/schedule/#genet.validate.schedule.generate_validation_report","title":"<code>generate_validation_report(schedule)</code>","text":"Source code in <code>src/genet/validate/schedule.py</code> <pre><code>def generate_validation_report(schedule):\n    logging.info(\"Checking validity of the Schedule\")\n    report = {\"schedule_level\": {}, \"service_level\": {}, \"route_level\": {}, \"vehicle_level\": {}}\n\n    logging.info(\"Computing headway stats\")\n    df_headway = schedule.headway_stats().set_index(\"route_id\")\n\n    route_validity = {}\n    for route in schedule.routes():\n        is_valid_route, invalid_stages = route.is_valid_route(return_reason=True)\n        route_validity[route.id] = {\n            \"is_valid_route\": is_valid_route,\n            \"invalid_stages\": invalid_stages,\n            \"headway_stats\": df_headway.loc[\n                route.id,\n                [\"mean_headway_mins\", \"std_headway_mins\", \"max_headway_mins\", \"min_headway_mins\"],\n            ].to_dict(),\n        }\n\n    for service_id in schedule.service_ids():\n        invalid_stages = []\n        invalid_routes = []\n        report[\"route_level\"][service_id] = {}\n        for route_id in schedule.service_to_route_map()[service_id]:\n            if not route_validity[route_id][\"is_valid_route\"]:\n                invalid_routes.append(route_id)\n                logging.warning(f\"Route ID: {route_id} under Service ID: {service_id} is not valid\")\n            report[\"route_level\"][service_id][route_id] = route_validity[route_id]\n\n        if invalid_routes:\n            is_valid_service = False\n            has_valid_routes = False\n            invalid_stages.append(\"not_has_valid_routes\")\n        else:\n            is_valid_service = True\n            has_valid_routes = True\n\n        report[\"service_level\"][service_id] = {\n            \"is_valid_service\": is_valid_service,\n            \"invalid_stages\": invalid_stages,\n            \"has_valid_routes\": has_valid_routes,\n            \"invalid_routes\": invalid_routes,\n        }\n        if not is_valid_service:\n            logging.warning(f\"Service with ID: {service_id} is not valid\")\n\n    invalid_stages = []\n    invalid_services = [\n        service_id\n        for service_id in schedule.service_ids()\n        if not report[\"service_level\"][service_id][\"is_valid_service\"]\n    ]\n\n    logging.info(\"Checking validity of PT vehicles\")\n    has_valid_vehicle_def = schedule.validate_vehicle_definitions()\n    missing_vehicle_types = schedule.get_missing_vehicle_information()\n\n    report[\"vehicle_level\"] = {\n        \"vehicle_definitions_valid\": has_valid_vehicle_def,\n        \"vehicle_definitions_validity_components\": {\n            \"missing_vehicles\": {\n                \"missing_vehicles_types\": missing_vehicle_types[\"missing_vehicle_types\"],\n                \"vehicles_affected\": missing_vehicle_types[\"vehicles_affected\"],\n            },\n            \"unused_vehicles\": schedule.unused_vehicles(),\n            \"multiple_use_vehicles\": schedule.check_vehicle_uniqueness(),\n        },\n    }\n\n    if invalid_services or (not has_valid_vehicle_def):\n        is_valid_schedule = False\n        has_valid_services = False\n        if invalid_services:\n            invalid_stages.append(\"not_has_valid_services\")\n        if not has_valid_vehicle_def:\n            invalid_stages.append(\"not_has_valid_vehicle_definitions\")\n    else:\n        is_valid_schedule = True\n        has_valid_services = True\n\n    report[\"schedule_level\"] = {\n        \"is_valid_schedule\": is_valid_schedule,\n        \"invalid_stages\": invalid_stages,\n        \"has_valid_services\": has_valid_services,\n        \"invalid_services\": invalid_services,\n    }\n\n    zero_headways = df_headway[df_headway[\"min_headway_mins\"] == 0]\n    report[\"schedule_level\"][\"headways\"] = {}\n    if not zero_headways.empty:\n        report[\"schedule_level\"][\"headways\"][\"has_zero_min_headways\"] = True\n        report[\"schedule_level\"][\"headways\"][\"routes\"] = {\n            \"number_of_affected\": len(zero_headways),\n            \"ids\": list(zero_headways.index),\n        }\n        report[\"schedule_level\"][\"headways\"][\"services\"] = {\n            \"number_of_affected\": len(zero_headways[\"service_id\"].unique()),\n            \"ids\": list(zero_headways[\"service_id\"].unique()),\n        }\n\n        logging.warning(\n            f\"Found {len(zero_headways)} PT Routes 0 minimum headway between trips. \"\n            f\"The following Services are affected: {report['schedule_level']['headways']['services']}\"\n        )\n    else:\n        report[\"schedule_level\"][\"headways\"][\"has_zero_min_headways\"] = False\n\n    logging.info(\"Computing speeds\")\n    df_speeds = schedule.speed_geodataframe()\n    logging.info(\n        \"Checking speeds for prohibitive values 0 and infinity. You should verify speed values separately\"\n    )\n    report[\"schedule_level\"][\"speeds\"] = {}\n    for val in [0, math.inf]:\n        val_df = df_speeds[df_speeds[\"speed\"] == val]\n        if not val_df.empty:\n            report[\"schedule_level\"][\"speeds\"][f\"{val}_m/s\"] = {\n                \"routes\": list(val_df[\"route_id\"].unique())\n            }\n\n    if not is_valid_schedule:\n        logging.warning(\"This schedule is not valid\")\n\n    return report\n</code></pre>"},{"location":"reference/genet/variables/","title":"genet.variables","text":""},{"location":"reference/genet/variables/#genet.variables.EPSG4326","title":"<code>EPSG4326 = 'epsg:4326'</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.EXTENDED_TYPE_DICT","title":"<code>EXTENDED_TYPE_DICT = {'tram': [0], 'subway': [1], 'rail': [2], 'bus': [3], 'ferry': [4], 'cablecar': [5], 'gondola': [6], 'funicular': [7]}</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.EXTENDED_TYPE_MAP","title":"<code>EXTENDED_TYPE_MAP = dict(zip(new_keys, new_values))</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.NECESSARY_NETWORK_LINK_ATTRIBUTES","title":"<code>NECESSARY_NETWORK_LINK_ATTRIBUTES = ['id', 'from', 'to', 'length', 'freespeed', 'capacity', 'permlanes', 'modes']</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.NECESSARY_NETWORK_NODE_ATTRIBUTES","title":"<code>NECESSARY_NETWORK_NODE_ATTRIBUTES = ['id', 'x', 'y']</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.NECESSARY_STOP_FACILITY_ATTRIBUTES","title":"<code>NECESSARY_STOP_FACILITY_ATTRIBUTES = ['id', 'x', 'y']</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.OPTIONAL_NETWORK_LINK_ATTRIBUTES","title":"<code>OPTIONAL_NETWORK_LINK_ATTRIBUTES = ['oneway', 'origid', 'type', 'attributes']</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.OPTIONAL_NETWORK_NODE_ATTRIBUTES","title":"<code>OPTIONAL_NETWORK_NODE_ATTRIBUTES = ['z', 'type', 'origid', 'attributes']</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.OPTIONAL_STOP_FACILITY_ATTRIBUTES","title":"<code>OPTIONAL_STOP_FACILITY_ATTRIBUTES = ['z', 'linkRefId', 'name', 'stopAreaId', 'isBlocking', 'attributes']</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.new_keys","title":"<code>new_keys = []</code>  <code>module-attribute</code>","text":""},{"location":"reference/genet/variables/#genet.variables.new_values","title":"<code>new_values = []</code>  <code>module-attribute</code>","text":""}]}